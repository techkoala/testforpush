[{"categories":["Linux"],"content":" 翻译一篇服务器基本配置的好文章 这是我一直想写的一篇文章。虽然说明如何设置自托管应用程序很简单，但在薄弱的基础上托管应用程序毫无意义。在每篇教程的开头都介绍服务器设置是一件非常麻烦的事，所以我也为自己写了这篇文章，作为我如何为自己托管的应用程序设置服务器的参考。我会从基本的东西开始，比如使用 SSH 正确登录、非根用户设置以及为每个应用程序创建用户。我还会介绍 NGINX 设置、一些让服务器管理更轻松的生活质量工具、日志管理和基本网络安全。 ","date":"2024-10-11","objectID":"/server_setup_basics/:0:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#"},{"categories":["Linux"],"content":" SSH首先是登录。您需要一种安全访问设备的方法。不要使用用户名和密码。你需要使用 SSH（安全外壳），并确保 SSH 是唯一的登录方式。为此，你需要一个 SSH 密钥和一个新的用户账户。在新配置的 VPS 上，你将以根用户身份登录，你需要保护根用户账户。首先在 VPS 或远程机器上创建一个新的普通用户，并将其添加到 “sudo “组： sudo adduser techkoala sudo usermod -aG sudo techkoala 然后在本地电脑是执行： ssh-keygen -t ed25519 -C \"your_email@example.com\" 按照说明操作，它会问你想把文件保存在哪里，以及是否需要密码。请确保设置了字符串密码。要将公钥复制到服务器上，请在本地计算机上运行： ssh-copy-id -i ~/.ssh/id_ed25519.pub newuser@your_server_ip 请记住，newuser@your-server-ip 是用户名，也是你要将公钥复制到的远程设备。提示输入密码时，输入的是远程设备上的账户密码，而不是你刚刚为 SSH 密钥设置的密码。一旦验证通过，它就会复制公钥，现在你就可以通过 SSH 登录了。要关闭用户名和密码登录，请键入： sudo vim /etc/ssh/sshd_config 找到下列值，并按你在这里看到的进行设置 Port 2222 # Change default port (use a number between 1024 and 65535) PermitRootLogin no # Disable root login PasswordAuthentication no # Disable password authentication PubkeyAuthentication yes # Enable public key authentication AuthorizedKeysFile .ssh/authorized_keys # Specify authorized_keys file location AllowUsers newuser # Only allow specific users to login 这将禁止除 SSH 之外的所有登录方式，只能通过你复制了公钥的用户登录。停止以 Root 身份登录，只允许你指定的用户登录。点击 CTL+S 保存，点击 CTL+x 退出文件编辑器。重启 SSH： sudo systemctl restart ssh 这可能会导致你退出 SSH 会话。如果出现这种情况，这时可以测试其他登录方法，看看是否被拒绝，然后再继续。此外，不言而喻，你需要妥善保管私钥，一旦丢失，你将无法再远程登录： Protocol 2 # Use only SSH protocol version 2 MaxAuthTries 3 # Limit authentication attempts ClientAliveInterval 300 # Client alive interval in seconds ClientAliveCountMax 2 # Maximum client alive count 现在，让我们再深入研究一下用户，看看如何利用他们来提高组织性和安全性。 ","date":"2024-10-11","objectID":"/server_setup_basics/:1:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#ssh"},{"categories":["Linux"],"content":" Users在管理 Linux 服务器时，用户非常重要。服务器管理中有一个理念叫做 “最小权限原则”，其基本意思是，你要给予应用程序或进程完成工作所需的最小权限。Root 拥有无限的权限，没有应用程序真正需要它。为正在运行的应用程序设置用户权限有几个好处。如果正在运行的应用程序受到威胁，它可以限制潜在的损害。当运行多个应用程序时，它可以增加隔离性，有助于审计，让你知道哪些应用程序正在使用哪些系统资源。 简而言之，用户是组织系统的好帮手，在出现问题时能帮助你排除故障。要添加新用户，请运行 sudo useradd -rms /usr/sbin/nologin -c \"a comment\" youruser 该命令将创建一个用户，并为其提供一个存放应用程序数据的主目录，但不允许以该用户身份登录。-c标志是可选的，但最好能知道用户的用途，如 “运行 Nextcloud “之类。将应用程序文件克隆到 /opt 目录中： sudo mkdir /opt/myapp 该命令会创建一个用户，并为其提供一个存放应用程序数据的主目录，但不允许以该用户身份登录。-c标志是可选的，但最好能知道用户的用途，如 “运行 Nextcloud “之类。将应用程序文件克隆到 /opt 目录中： sudo chown appuser:appuser /opt/myapp 好了，这样就锁定了你的登录，你也应该对如何使用用户有了一定的了解。接下来是日志。 ","date":"2024-10-11","objectID":"/server_setup_basics/:2:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#users"},{"categories":["Linux"],"content":" Logs日志对系统管理至关重要。它们可以跟踪系统健康状况，帮助排除故障和检测威胁。因此，你需要设置适当的日志轮换，这样日志就不会占用系统太多空间，而且更易于阅读和管理。要设置正确的日志轮换，需要编辑位于 /etc 目录下的 logrotate.conf 文件。单个应用程序的配置通常存储在 /etc/logrotate.d/，因此 NGINX 的配置示例如下： /var/log/nginx/*.log { weekly missingok rotate 52 compress delaycompress notifempty create 0640 www-data adm sharedscripts postrotate [ -f /var/run/nginx.pid ] \u0026\u0026 kill -USR1 `cat /var/run/nginx.pid` endscript } 该配置每周轮换日志，保留 52 周的日志，压缩旧日志，以正确的权限创建新日志，然后在轮换后向 NGINX 发出信号以重新打开日志文件。您可以使用以下配置进行测试 sudo logrotate -d /etc/logrotate.conf 这将显示它在不实际旋转日志的情况下会做什么。有了这些设置，你就可以开始做更高级的事情了，比如根据日志条目触发警报。现在，这对单台服务器来说还算不错，但如果你管理的服务器不止一台，最好还是了解一下 Grafana Loki、Graylog 和 Fluentd 等工具。在此我就不详细介绍了，但如果你想提高你的日志游戏水平，这些都是不错的起点。 ","date":"2024-10-11","objectID":"/server_setup_basics/:3:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#logs"},{"categories":["Linux"],"content":" Backups备份，更重要的是测试备份，在服务器管理中极其重要。请记住：除非经过测试，否则备份就不是备份。未经测试的备份基本上是无用的。 备份主要有三种类型。完全备份、差异备份和增量备份。完全备份是磁盘上所有数据的完整副本。这种备份占用资源最多，但最容易恢复。差异备份备份的是上次完整备份后的所有变化，这是一种在空间和恢复速度上都处于中间位置的备份策略。增量备份备份自上次备份后发生变化的数据，这是最快的备份方式，但恢复起来可能最复杂。 我是这样想的。我使用增量备份来备份照片、文档或项目文件和经常编辑的文件夹。我会使用完全备份来备份整个服务器或磁盘。差异备份用于备份完整文件夹，如 /etc、/opt 和日志文件夹。 现在该如何存储呢？如果您遵循 3-2-1 原则，您就会如虎添翼。3 份数据副本、2 种存储类型和 1 个异地备份。我想说的是，如果这看起来太多，那么 “异地 “存储是最重要的，不能省略。万一发生灾难性的数据崩溃，拥有一个带有备份的硬盘是非常宝贵的。异地/离线备份还能让您免受勒索软件的威胁。因此，请牢记这一点。现在有大量的备份软件。我使用 Sync-thing、Borg 备份和老式 FTP 的组合。 请记住，备份、日志和服务器监控是一个根据您的需求不断发展的过程。您实施的具体策略应符合您的需求和数据的关键性。 ","date":"2024-10-11","objectID":"/server_setup_basics/:4:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#backups"},{"categories":["Linux"],"content":" Basic Network Safety保护服务器安全的下一步是锁定那些不需要暴露在互联网上的端口，并禁止那些在不应该登录的情况下尝试登录的东西。UFW 和 Fail2Ban 是目前广泛使用的两种工具。它们简单易用，UFW 可让你为端口设置流量规则，而 Fail2Ban 则会在 IP 地址进入不应进入的端口或在某些预定义规则后仍无法登录时将其封禁。UFW 或不复杂的防火墙通常会预装在许多 VPS 服务中，Fail2Ban 也是如此，但如果你使用的是新机器且不确定，请运行： sudo apt install ufw sudo apt install fail2ban ","date":"2024-10-11","objectID":"/server_setup_basics/:5:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#basic-network-safety"},{"categories":["Linux"],"content":" UFW关于 Fail2Ban，我们稍后再讨论，现在让我们重点讨论 UFW 设置。首先运行一些默认策略： sudo ufw default deny incoming sudo ufw allow outgoing 这被认为是最佳做法，因为它遵循了我前面提到的 “最少权限 “理念。它减少了机器的攻击面，让你可以精确控制暴露的内容。简而言之，这种配置在安全性和功能性之间取得了平衡。你的服务器可以根据需要接入互联网，但外部实体只能通过你明确允许的方式连接到你的服务器。现在，让我们允许一些东西进入。 sudo ufw allow ssh sudo ufw allow 80 sudo ufw allow 443 如果要运行网络服务器，则需要打开 80 端口和 443 端口。80 端口用于 HTTP，443 端口用于 HTTPS。默认情况下，22 端口是 SSH，如果更改了端口，则需要指定端口，而不是使用 “allow ssh “命令。下面是其他一些有用的命令： #List rules with numbers: sudo ufw status numbered #Delete by number: sudo ufw delete NUMBER #Delete by rule specification: sudo ufw delete allow 80 #You can allow connections from specific IP addresses: sudo ufw allow from 192.168.1.100 #You can also only allow an IP to connect to a specfic port with: sudo ufw allow from 192.168.1.100 to any port 22 #If you neeed to allow a range of ports: sudo ufw allow 6000:6007/tcp #To further protect from brut force attacks you can rate limit specific ports with: sudo ufw limit ssh #This would limit port 22 to 6 connections in 30 seconds from a single IP. To see the status of the firewall you can use: #Adding this goves you more info sudo ufw status verbose #and to reset incase you need to start over: sudo ufw reset #and to enable and disable: sudo ufw enable sudo ufw disable #finaly to enable logging and adjusting the log level: sudo ufw logging on sudo ufw logging medium # levels are low, medium, high, full 现在开始 Fail2Ban。 ","date":"2024-10-11","objectID":"/server_setup_basics/:5:1","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#ufw"},{"categories":["Linux"],"content":" Fail2Ban主要配置文件位于 /etc/fail2ban/jail.conf，但建议创建本地配置文件： sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local sudo nano /etc/fail2ban/jail.local jail.local 部分的[DEFAULT]部分有一些基本设置，它们是 bantime = 10m findtime = 10m maxretry = 5 封禁时间是指 IP 被封禁的时间。查找时间是 Fail2Ban 寻找重复失败的时间范围，最大重试次数是 IP 被禁用前的失败次数。您可以根据需要调整这些参数。您还可以设置自定义封禁，Fail2Ban 也支持 SSH 等常用服务的封禁。您还可以采取更多步骤，但我认为这已经涵盖了基本内容。 ","date":"2024-10-11","objectID":"/server_setup_basics/:5:2","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#fail2ban"},{"categories":["Linux"],"content":" NGINX您可以使用的网络服务器有很多。Apache, Caddy, nginx, IIS 等等。我使用 Nginx。这是我所熟悉的，而且它运行得非常好。Nginx（发音为 engine-x）是一个网络服务器、反向代理和负载平衡器。作为 Web 服务器，它擅长提供静态内容，并能以相当低的资源占用率处理大量并发连接。作为反向代理，它可以位于应用程序服务器之前，将流量转发给它们，同时确保应用程序的安全。它的负载平衡功能可有效平衡服务器之间的流量，提高可靠性和可扩展性。 通过 apt 安装时，nginx 的默认位置是 /etc/nginx/，nginx.conf 主要用于全局服务器配置，包括 /etc/nginx/sites-enabled 文件夹中的文件。这种模块化结构便于管理多个站点。需要注意的两个文件夹是 sites-enabled 文件夹和 sites-available 文件夹。您可以将可用站点视为测试站点配置的暂存区，而启用站点则用于实时站点和应用程序。常见的做法是在可用站点中的站点中设置和测试配置，然后当你准备上线并获得 SSL 证书时，将文件链接到启用站点文件夹。具体方法如下 ln -s /etc/nginx/sites-available/yoursitefile /etc/nginx/sites-enabled 然后重新加载nginx，并再次检查nginx状态： sudo systemctl reload nginx sudo systemctl status nginx 您的网站现在应该已经上线。 下面，我将向您展示一些模板化的 Nginx 网站配置。请务必考虑您的应用程序或网站需求，因为这些只是起点。对于静态网站，这是一个不错的起点。 基本静态网站配置： server { listen 80; listen [::]:80; server_name example.com www.example.com; root /var/www/example.com/html; index index.html index.htm; location / { try_files $uri $uri/ =404; } # Security headers add_header X-Frame-Options \"SAMEORIGIN\" always; add_header X-XSS-Protection \"1; mode=block\" always; add_header X-Content-Type-Options \"nosniff\" always; add_header Referrer-Policy \"no-referrer-when-downgrade\" always; add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always; # Logging access_log /var/log/nginx/example.com.access.log; error_log /var/log/nginx/example.com.error.log warn; # SSL configuration (uncomment after running Certbot) # listen 443 ssl http2; # listen [::]:443 ssl http2; # ssl_protocols TLSv1.2 TLSv1.3; # ssl_prefer_server_ciphers on; # ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; # Certbot will add its own SSL certificate paths # ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; # ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; } 代理通行证配置： server { listen 80; listen [::]:80; server_name app.example.com; location / { proxy_pass http://localhost:3000; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # Security headers add_header X-Frame-Options \"SAMEORIGIN\" always; add_header X-XSS-Protection \"1; mode=block\" always; add_header X-Content-Type-Options \"nosniff\" always; add_header Referrer-Policy \"no-referrer-when-downgrade\" always; add_header Content-Security-Policy \"default-src 'self' http: https: data: blob: 'unsafe-inline'\" always; # Logging access_log /var/log/nginx/app.example.com.access.log; error_log /var/log/nginx/app.example.com.error.log warn; # SSL configuration (uncomment after running Certbot) # listen 443 ssl http2; # listen [::]:443 ssl http2; # ssl_protocols TLSv1.2 TLSv1.3; # ssl_prefer_server_ciphers on; # ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; # Certbot will add its own SSL certificate paths # ssl_certificate /etc/letsencrypt/live/app.example.com/fullchain.pem; # ssl_certificate_key /etc/letsencrypt/live/app.example.com/privkey.pem; } WebSocket 升级配置： server { listen 80; listen [::]:80; server_name ws.example.com; location / { proxy_pass http://localhost:8080; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } # Security headers add_header X-Frame-Options \"SAMEORIGIN\" always; add_header X-XSS-Protection \"1; mode=block\" always; add_header X-Content-Type-Options \"nosniff\" always; add_header Referrer-Policy \"no-referrer-when-downgrade\" always; add_heade","date":"2024-10-11","objectID":"/server_setup_basics/:5:3","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#nginx"},{"categories":["Linux"],"content":" Quality Of Life Tools关于 “让系统管理更轻松的工具 “这个话题，我将介绍一些我在服务器上使用的工具，我认为它们能让管理变得更轻松。我不会深入介绍任何工具。所有这些都是可选的，没有特定的顺序。其中很多都是我在网站上找到的，如果你和我一样是个终端迷，那么这个网站很值得浏览。 第一个工具，这是我的个人必备清单。Btop 是一款资源终端监控器。它能实时显示电脑的 CPU、内存、磁盘、网络和运行附魔的可视化使用统计信息，它由 C++ 编写，可通过大多数软件包管理器安装。 对于有大量外部连接的服务器（如 nostr 中继站），类似的工具很有帮助。Neoss 的目标是取代常用的 ss 命令，满足基本使用需求。它提供了一个使用中的 TCP 和 UDP 套接字列表及其各自的统计信息。与 SS 原始输出相比，它的主要优势在于清晰简洁的 TUI（终端用户界面），允许你对连接到机器的内容进行排序、刷新和导航。它通过 NPM 安装，这意味着你需要安装 JavaScript。 是一款基于终端的网络服务器日志分析器。它非常适合在终端上快速实时查看日志，还能实时生成 HTML、JSON 和 CSV 报告。GoAccess 可通过大多数软件包管理器安装，适用于所有平台。 接下来要介绍的是 Its，它是一款功能强大的基于文本的文件管理器，具有双面显示屏和许多操作文件和目录的功能。它还具有跨平台特性，可通过大多数软件包管理器进行安装。 与服务器文件管理同属一个主题的是 .NET Framework。这是我的必备清单。它是一款磁盘使用分析器，专门用于查找占用空间的文件。它运行速度快，操作简单。它可以安装在大多数系统和软件包管理器上。Windows 需要安装 Linux 子系统才能使用它。 希望你能从中找到一些有用的东西。我想谈的最后一个话题是 DNS，这是个比较大的话题，所以我不会做大规模的深入探讨，但如果你是自助托管，掌握一些 DNS 的基本知识还是有帮助的。 ","date":"2024-10-11","objectID":"/server_setup_basics/:6:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#quality-of-life-tools"},{"categories":["Linux"],"content":" DNSDNS 或域名系统是我们所熟知的互联网运作方式的核心部分。不管你喜欢还是讨厌，如果你想访问更广泛的互联网，我们就必须使用它。(我不喜欢它现在的样子，但我不会在这里说这个）。基本上，把 DNS 想象成电话簿。它可以让你在每次需要搜索互联网时输入 duckduckgo.com，而不是 “52.250.42.157”。它将人类容易记住的东西转化为计算机所需的信息，从而真正到达 “duckduckgo.com”。 如果您使用的是 VPS 主机，您唯一需要知道的就是在决定使用某个域名后，如何将 A 记录指向您的服务器 IP。几乎所有的 VPS 主机都可以为你提供一个静态 IP，所以这主要是一种设置和遗忘类型的交易。 在家托管会遇到一些挑战。一个突出的问题是（我经常听到的一个有效问题）没有静态 IP 地址。如今，由于需要 IP 地址的在线设备数量众多，我们要做的事情很多，而且大多数 IP 地址都是动态分配的，除非你从 ISP 付费购买。但还是有解决办法的。这就是动态 DNS 或 DDNS。每当 IP 地址发生变化时，DNS 服务器就会自动更新。设置动态 DNS 的方法多种多样。您可以托管自己的服务或使用主机。下面是一些主机和项目的链接，可供参考。 简而言之，它是这样工作的。你可以选择一个服务提供商，也可以自己设置。你可以获得一个域名，将客户端安装在家庭路由器或服务器上，客户端会定期检查 IP 地址是否发生变化，如果发生变化，它就会更新该域名的 DNS 记录。 ","date":"2024-10-11","objectID":"/server_setup_basics/:7:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#dns"},{"categories":["Linux"],"content":" Docker在这里我不会介绍如何安装 docker。无论如何，最好还是按照官方的安装指南来安装。但我想谈几点。首先，docker 在测试新应用程序时非常有用。但我认为也仅此而已。我个人不太喜欢使用 docker，而是尽可能直接运行应用程序。以下是一些值得注意的利弊。 ","date":"2024-10-11","objectID":"/server_setup_basics/:8:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#docker"},{"categories":["Linux"],"content":" 优点如果你的系统可以运行 docker，你就可以运行大多数 docker 应用程序。它有助于隔离，减少应用程序之间的冲突。在某些情况下，它可以帮助提高效率，因为它比传统的虚拟机占用更少的资源。微服务架构也很有用，因为它可以将应用程序分解成更小的可管理服务，从而实现服务的独立扩展。最后，该社区规模庞大，文档完善，社区支持总是很有帮助，而且还有大量现成的 docker 映像可供部署。 ","date":"2024-10-11","objectID":"/server_setup_basics/:8:1","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#优点"},{"categories":["Linux"],"content":" 缺点首先是开销。虽然它比传统的虚拟机要好，但它比直接在主机上运行要耗费更多的资源，而且输入/输出操作可能会更慢。docker 共享系统内核的事实意味着，一个受损的应用程序可能会影响系统。持久化数据是可行的，但增加了一层复杂性，可能会导致新用户的数据丢失，也会使备份变得更加复杂。使用 docker 时，网络连接也会变得更加复杂，因此不会那么简单。值得注意的是，如果使用 UFW 或 firewalld 作为防火墙，docker 会绕过这些规则。Docker 只与 iptables 兼容。此外，管理良好的 docker 容器有助于管理服务器资源，但管理不当也会对资源造成损害。容器可能会变得过大，从而影响磁盘大小，而错误的配置则会占用过多的服务器资源。在监控和调试应用程序时，尤其是跨多个容器时，它还会增加额外的复杂性。 ","date":"2024-10-11","objectID":"/server_setup_basics/:8:2","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#缺点"},{"categories":["Linux"],"content":" 总结好了，关于服务器设置和工具的基础知识就介绍到这里。有一个工具可以帮你完成大部分工作。我写它是为了让自己的服务器设置更快。你可以在这里获得它，它包含了我所有的必备工具，并做了一些基本配置。请根据自己的需要进行调整，并一如既往地注意安全。 ","date":"2024-10-11","objectID":"/server_setup_basics/:9:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#总结"},{"categories":["Linux"],"content":" 原文 [1] Server Setup Basics ","date":"2024-10-11","objectID":"/server_setup_basics/:10:0","series":null,"tags":["Linux","Translation"],"title":"服务器基础设置","uri":"/server_setup_basics/#原文"},{"categories":["RSS"],"content":" follow认证信息，欢迎关注订阅 This message is used to verify that this feed (feedId:55939235463397383) belongs to me (userId:55938341809190912). Join me in enjoying the next generation information browser https://follow.is. ","date":"2024-09-09","objectID":"/follow/:0:0","series":null,"tags":["Follow"],"title":"拥抱Follow","uri":"/follow/#"},{"categories":["Network"],"content":" 记录一下 CouchDB 搭建流程，用于同步 MoonFM、Obsidian 很早之前就购买了 MoonFM，但是鉴于没有自带同步服务，所以一直使用 Spotify 听播客。现在终于忍不了这种音乐和播客混在一起，乱七八糟的感觉了，因此抽空研究了 MoonFM 使用的 Couchdb 数据库同步方案，实现了自建同步服务。同时也刚好一并将 Obsidian 的同步服务从Remotely save迁移到了obsidian-livesync，实现了更好的同步体验！ ","date":"2023-10-11","objectID":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","series":null,"tags":["CouchDB","MoonFM","flyio"],"title":"搭建 CouchDB 数据库","uri":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/#"},{"categories":["Network"],"content":" Docker 安装 CouchDB首先需要创建一个 data 文件夹和一个 local.ini 用于 docker 内部文件夹和配置文件的映射。其中 local.ini 如下： [couchdb] single_node=true [chttpd_auth] require_valid_user = true authentication_redirect = /_utils/session.html [httpd] WWW-Authenticate = Basic realm=\"couchdb\" enable_cors = true [cors] origins = capacitor://localhost,http://localhost credentials = true headers = accept, authorization, content-type, origin, referer methods = GET, PUT, POST, HEAD, DELETE max_age = 3600 [couch_peruser] database_prefix = userdb_ delete_dbs = false enable = true docker-compose 文件如下，需要自己修改一下映射端口，账号密码等： version: \"3\" services: couchdb: ports: - \"5984:5984\" volumes: - \"./data:/opt/couchdb/data\" - \"./local.ini:/opt/couchdb/etc/local.ini\" environment: - COUCHDB_USER=管理后台账户名 - COUCHDB_PASSWORD=管理后台密码 restart: always network_mode: bridge container_name: couchdb image: couchdb 然后使用docker-compose up -d启动 docker ","date":"2023-10-11","objectID":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","series":null,"tags":["CouchDB","MoonFM","flyio"],"title":"搭建 CouchDB 数据库","uri":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/#docker-安装-couchdb"},{"categories":["Network"],"content":" 数据库管理通过http://IP地址:端口号/_utils/访问数据口后台，账号密码就是上一步自己定义的密码。 页面中就可以创建并管理自己的数据库和用户，但是我更习惯使用命令行进行管理： 以 MoonFM 同步数据库创建为例，依次执行下面的命令即可： 创建用户 curl -X PUT http://管理后台账户名:管理后台密码@IP地址:端口号/_users/org.couchdb.user:用户账号名 -H \"Accept: application/json\" -H \"Content-Type: application/json\" -d '{\"name\": \"用户账号名\", \"password\": \"用户密码\", \"roles\": [], \"type\": \"user\"}' 创建数据库 curl -X PUT http://管理后台账户名:管理后台密码@IP地址:端口号/数据库名 添加用户到数据库 curl -X PUT http://管理后台账户名:管理后台密码@IP地址:端口号/数据库名/_security -H \"Accept: application/json\" -H \"Content-Type: application/json\" -d '{\"admins\": {\"names\": [], \"roles\": []}, \"members\": {\"names\": [\"用户账号名\"], \"roles\": []}}' 获得的同步链接如下： http://用户账号名:用户账号密码@IP地址:端口号/数据库名 这里需要注意区分 curl 参数填入的管理后台账户名密码和数据库用户名密码 此后还可以进行反向代理等操作，这里可以参考使用 Nginx 实现多服务复用端口 ","date":"2023-10-11","objectID":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","series":null,"tags":["CouchDB","MoonFM","flyio"],"title":"搭建 CouchDB 数据库","uri":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/#数据库管理"},{"categories":["Network"],"content":" fly.io 搭建免费 CouchDB 数据库未完待续 ","date":"2023-10-11","objectID":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","series":null,"tags":["CouchDB","MoonFM","flyio"],"title":"搭建 CouchDB 数据库","uri":"/%E6%90%AD%E5%BB%BAcouchdb%E6%95%B0%E6%8D%AE%E5%BA%93/#flyio-搭建免费-couchdb-数据库"},{"categories":["Network"],"content":" Google 取消了 Google One 订阅用户的 VPN 功能，本文已实质性失效 更新 三月份开始，谷歌又对检测方式进行了更改，要求域名（*.googleapis.com）和原本的检测服务器来自同一区域 IP，否则将一直提示VPN连接中断 因此需增加将此网址加入检测分流中，见先连接上章节 ","date":"2023-02-24","objectID":"/google_one_vpn/:0:0","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#"},{"categories":["Network"],"content":" 机制说明首先，要想愉快使用，需要明确下面 Google One VPN 的下面几点机制： 目前仅 Android 手机可以正常连接。（当然如果你在 iPhone 上使用境外卡或使用 Android 虚拟机依然是可以的，但此不在本文讨论范围） 该服务仅在如下国家提供（且对于大陆来说，通常只有部分地区有实用性）： - 奥地利 - 澳大利亚 - 比利时 - 加拿大 - 丹麦 - 芬兰 - 法国 - 德国 - 冰岛 - 爱尔兰 - 意大利 - 日本 - 墨西哥 - 荷兰 - 挪威 - 韩国 - 西班牙 - 瑞典 - 瑞士 - 台湾 - 英国 - 美国 基于第 2 点，即使真正的服务器可以直连，那我们也需要先欺骗 IP 检测服务器，具体机制如下： 准入 IP 限制 即便通过了第 3 点连接上服务器后，Google 依然还会在你每使用 1G 流量的后，再次对你的原始 IP 进行检测。如果此时检测到你的 IP 不在上述地区了，就会强制断开 VPN 连接。 因此，不仅在于连上，还要避免 1G 断开，才叫做愉快玩耍！So,go on… ","date":"2023-02-24","objectID":"/google_one_vpn/:1:0","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#机制说明"},{"categories":["Network"],"content":" 先连接上想要连接上，其实不难，从上面的就可以看出，只需要使用受支持地区的 IP 欺骗检测服务器就可以了。 并且，检测服务器的地址是固定的，后缀如下： *.cloud.cupronickel.goog *.googleapis.com 于是，我们需要在代理工具（如 clash for android）中，将此连接加入代理清单即可。 如果你使用 rule-provider，那么可以如下写规则： payload: - DOMAIN-SUFFIX,cloud.cupronickel.goog - DOMAIN-SUFFIX,googleapis.com 手机通过代理后，即可使用 Google One app 成功连接上对应地区的 Google One VPN 服务器 ","date":"2023-02-24","objectID":"/google_one_vpn/:2:0","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#先连接上"},{"categories":["Network"],"content":" 再共享出来等手机连接上后，那么你可以使用诸如 everyproxy 这样的软件在手机上开启 HTTP 或者 socks 代理，分享给局域网的其他设备使用。 ","date":"2023-02-24","objectID":"/google_one_vpn/:3:0","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#再共享出来"},{"categories":["Network"],"content":" 愉快使用经过上面两步，你其实已经可以正常使用 VPN 了，但是前面说到了，每当你使用了 1G 流量，Google 会再次检测你的 IP，这样你就会掉线。因为手机上只能同时开启一个 VPN 软件，所以 clash 此时没有代理这个检测服务器流量了。 ","date":"2023-02-24","objectID":"/google_one_vpn/:4:0","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#愉快使用"},{"categories":["Network"],"content":" 你有软路由？如果你有软路由的话，那一切都简单很多。以 opeclash 为例： 首先，同样将上面检测服务器加入代理，并一直保持代理 将手机共享出来的 socks 代理或和 HTTP 代理作为一个节点加入文件文件中，如这样： - name: \"🪜 GoogleOne\" type: socks5 server: 192.168.XXX.XXX port: 1080 为了避免嵌套代理，请添加 VPN 服务器 IP 端到新的 rule-provider 中： - '136.22.64.0/24' - '136.22.65.0/24' - '136.22.67.0/24' - '136.22.76.0/24' - '136.22.83.0/24' - '136.22.85.0/24' - '136.22.86.0/24' - '136.22.87.0/24' - '136.22.92.0/24' - '136.22.93.0/24' - '136.22.94.0/24' - '136.22.95.0/24' - '136.22.96.0/24' - '136.22.97.0/24' - '136.22.98.0/24' - '136.22.99.0/24' - '136.22.100.0/24' - '136.22.101.0/24' - '136.22.102.0/24' - '136.22.103.0/24' - '136.22.104.0/24' - '136.22.105.0/24' - '136.22.106.0/24' - '136.22.107.0/24' - '136.22.108.0/24' - '136.22.109.0/24' - '136.22.110.0/24' - '136.23.1.0/24' - '136.23.2.0/24' - '136.23.3.0/24' - '136.23.4.0/24' - '136.23.5.0/24' - '136.23.6.0/24' - '136.23.7.0/24' - '136.23.8.0/24' - '136.23.9.0/24' - '136.23.10.0/24' - '136.23.11.0/24' - '136.23.12.0/24' - '136.23.13.0/24' - '136.23.14.0/24' - '136.23.15.0/24' - '136.23.16.0/24' - '136.23.17.0/24' - '136.23.18.0/24' - '136.23.19.0/24' - '136.23.20.0/24' - '136.23.21.0/24' - '136.23.22.0/24' - '136.23.23.0/24' - '136.23.24.0/24' - '136.23.25.0/24' - '136.23.26.0/24' - '136.23.27.0/24' - '136.23.28.0/24' - '136.23.29.0/24' - '136.23.30.0/24' - '136.23.31.0/24' - '136.23.32.0/24' - '136.23.33.0/24' - '136.23.34.0/24' - '136.23.35.0/24' - '209.107.176.0/24' - '209.107.177.0/24' - '209.107.178.0/24' - '209.107.179.0/24' - '209.107.180.0/24' - '209.107.181.0/24' - '209.107.182.0/24' - '209.107.183.0/24' - '209.107.184.0/24' - '209.107.185.0/24' - '209.107.186.0/24' - '209.107.187.0/24' - '209.107.188.0/24' - '209.107.189.0/24' - '209.107.190.0/24' - '209.107.191.0/24' 可以更加精确的将协议限定为 UDP（虽然实际上也只会走 UDP） script: shortcuts: GoogleVPNbypass: match_provider('GoogleVPNbypass') and network == 'udp' 并将其加入直连： - SCRIPT,GoogleVPNbypass,🚀 直接连接 至此，你每使用 1G 流量，由于你的前置代理一直都在，也不会掉线。并且通过将其作为节点，可以更加灵活的控制分流规则。 ","date":"2023-02-24","objectID":"/google_one_vpn/:4:1","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#你有软路由"},{"categories":["Network"],"content":" 没有软路由？那也没关系，你可以在电脑上使用 clash for windows 实现类似的效果（其他设备也一样，如 iPhone 上的 stash）。思路如下： clash for windows 的配置文件里要对代理检测服务器进行代理 手机 WiFi 代理中设置电电脑 IP 以及 7890（clash 默认代理地址） 在 clash for windows 配置文件里面新增一个 http 或者 socks 代理地址就是手机 IP 和 every proxy 共享出来的 http 或 socks 端口 ","date":"2023-02-24","objectID":"/google_one_vpn/:4:2","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#没有软路由"},{"categories":["Network"],"content":" 你只有安卓？抱歉，目前我还没有发现如何避免断开的方法。 但是你可以使用如下两种方式，出门外面的时候也能仅使用单设备连接上 VPN。 方法 1： 1. clash-设置-网络-关闭 自动路由系统流量 2. 打开clash开关 global选项卡选择一个支持的国家，例如美国，日本，台湾等 3. WiFi-设置-高级-代理-服务器写入127.0.0.1 端口填入7890 排除项填入 1.com 4. 开启Google One VPN 5. 成功后 clash global 选择direct 6. WiFi-高级设置-代理 修改 排除项1.com为任意 比如1.cn。没有排除选项的会造成网页无法打开 方法 2： 1. clash-设置-网络-关闭 自动路由系统流量 2. clash 挂一个支持的国家，例如美国，日本，台湾等。只用代理模式，不要用全局模式。 3. 在数据卡的设置里，设置一个新的 APN ，把 APN 的代理服务器里面设置为 127.0.0.1:7890 4. 直接用 Google one VPN 连接成功，成功后打开 wifi 和关闭 clash 均能保持连接状态 注意：连接成功后记得把clash设置为直连模式，且不可切换APN或关闭clash ","date":"2023-02-24","objectID":"/google_one_vpn/:4:3","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#你只有安卓"},{"categories":["Network"],"content":" 参考 开始使用 Google One VPN ","date":"2023-02-24","objectID":"/google_one_vpn/:5:0","series":null,"tags":["Google","VPN","Openclash"],"title":"Google One VPN 愉快玩耍指南","uri":"/google_one_vpn/#参考"},{"categories":["WirelessCommunication"],"content":" Wi-Fi 7 物理层变化总结 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#"},{"categories":["WirelessCommunication"],"content":" PHY 变化以目前的 802.11be Draft 1.0 版本为蓝本，Wi-Fi 7 相比 Wi-Fi 6 在技术上没有根本性的改变，主要是在原来的基础上对以下特性进行了加强或改进： 6GHz 频段和 320MHz 带宽 4K QAM 调制 增强 MIMO MLD（MLO 的基础） OFDMA 改进 下两图展示了 WiFi 发展历程中重要的参数信息的变化： ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#phy-变化"},{"categories":["WirelessCommunication"],"content":" 6GHz\u0026320MHz6GHz 的频段并非 Wi-Fi 7 首次采用（由 Wi-Fi 6E 引入），但是 Wi-Fi 7 在此基础上将 Wi-Fi 6/6E 最大单信道宽带由 160MHz 提升到了 320MHz 。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#6ghz320mhz"},{"categories":["WirelessCommunication"],"content":" 6GHz随着 6GHz 频段的引入，未来 Wi-Fi 的频段一共将有三部分组成，如下图所示： 具体到 6GHz 的位置，其可容纳的信道数量如下： 新的 6GHz 频段 (5925-7125 MHz)，宽度为 1.2 GHz，可容纳 3 或 6 个 320MHz 的频带，4 个 240MHz 的频带，7 个 160MHz 的频带，或 14 个 80MHz 的频带。支持首选扫描信道 (PSC) 的通道 (5, 21, 37, 53, 69, 85, 101, 117, 133, 149, 165, 181, 197) , 进行快速被动扫描。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:1:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#6ghz"},{"categories":["WirelessCommunication"],"content":" 320MHz320MHz信道化: 由6GHz的任意2个连续160MHz组成，包含2种类型： 320MHz-1（信道号为 31, 95, 159） 320MHz-2（信道号为 63, 127, 191） ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:2:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#320mhz"},{"categories":["WirelessCommunication"],"content":" 冲突虽然一些国家和地区（如美国和欧盟）已经批准 6GHz 中或宽或窄的频段用于 Wi-Fi，但采用 6GHz 也需要考虑如下几种场景可能占用 6GHz 带来冲突： 5G NR-U（5G New Radio in Unlicensed Spectrum）在 3GPP R16 版本里定义，5G 空中接口可工作于免许可频段。在一些地区，如美国，NR-U 也将被用于部署在 6GHz 频段的服务。此外，基于 NR-U Sidelink 的 C-V2X 服务如果部署，也会占用 6GHz 部分频宽。 美国已经划分了 5.9GHz 的 20MHz 给 5G C-V2X，部署需要考虑共存问题。 2023 年世界无线大会 WRC-23 将会讨论是否将 6GHz 频谱授权给 6G。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:3:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#冲突"},{"categories":["WirelessCommunication"],"content":" 4K-QAM","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#4k-qam"},{"categories":["WirelessCommunication"],"content":" 为什么要有 QAM？QAM 在用于 Wi-Fi 数字信号调制时，与普通幅度调制和相位调制相比能得到更高的速率。因为幅度调制和相位调制仅有 2 种符号（symbol）来区分 0 或 1。 幅度调制：通过改变载波的振幅来区分 0 和 1。 相位调制：通过改变载波的相位来区分 0 和 1。例如我们常见的 BPSK，就是使用 0° 和 180° 共 2 个相位表示 0 和 1，即 2 种符号；QPSK 则是使用 0°、90°、180° 和 270° 共 4 个相位，能够表示 00、01、10 和 11 共 4 种符号，传递 2 bit 的信息。其实 QPSK 就是一种特殊的 QAM，即 4-QAM。 而 QAM 则有更多的符号，每个符号都有相应的相位和幅度值。 以 16-QAM 为例，通过 QAM 调制可得到 16 个不同的波形，分别代表 0000，0001…. 这也意味着一共有 16 种符号，一个符号可以传递 4 bit 信息。 16-QAM示意图 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:1:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#为什么要有-qam"},{"categories":["WirelessCommunication"],"content":" QAM 是如何工作的？QAM 是将信号加载到 2 个正交的载波上（通常是正弦和余弦），通过对这两个载波幅度调整并叠加，最终得到相位和幅度都调制过的信号。这两个载波通常被称为 I 信号，另一个被称为 Q 信号，所以这种调制方式也被称为 IQ 调制。 IQ 调制 由于 QAM 最终调制后的信号包含了相位和幅度的变换，因此 QAM 也被认为相位调制和幅度调制的组合。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:2:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#qam-是如何工作的"},{"categories":["WirelessCommunication"],"content":" QAM 的星座图在数字信号调制中，星座图通常用于表示 QAM 调制二维图形。星座图相对于 IQ 调制而言，将数据调制信息映射到极坐标中，这些信息包含了信号的幅度信息和相位信息。 星座图上的每一个点，都表示一个符号。该点 I 轴和 Q 轴的分量分别代表着正交的载波上的幅度调整。该点到原点的距离 A 就是调制后的幅度，夹角 φ 就是调制后的相位。 而星座图上点的数量，决定了每个符号传输的比特数。例如： 256-QAM，256 是 2 的 8 次方，每个符号能传输 8bit 的数据。 1024-QAM，1024 是 2 的 10 次方，每个符号能传输 10bit 的数据。 4096-QAM，4096 是 2 的 12 次方，每个符号能传输 12bit 的数据。 因此，作为比 Wi-Fi 6 1024-QAM 更高阶的 4096-QAM，数据传输的峰值速率进一步提高 20%。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:3:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#qam-的星座图"},{"categories":["WirelessCommunication"],"content":" QAM 对 Wi-Fi 标准速率影响在 Wi-Fi 标准中，定义了调制和编码方案 MCS（Modulation and Coding Scheme）。MCS 对应一组调制和编码方式。以 Wi-Fi 6 为例，MCS 索引有 12 个。 Wi-Fi 6 中 MCS 索引对应的调制方式以及编码率 如果 MCS 为 1，则使用的是 QPSK 的调制方式；如果 MCS 为 11，则使用的是 1024 的调制方式。 对于每个 MCS 的索引值，根据信道带宽、空间流数和保护间隔（Guard Interval，GI）可以计算出不同的速率。 计算公式如下： Wi-Fi 标准的速率计算公式 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:4:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#qam-对-wi-fi-标准速率影响"},{"categories":["WirelessCommunication"],"content":" 代价尽管较高阶的调制速率能够为无线电通信系统提供更快的数据速率和更高水平的频谱效率，但这是有代价的。较高阶的调制方案对噪声和干扰的适应性要差得多。 因为发送一个符号所用的载波频宽是固定的，发送时长也是一定的，较高阶意味着两个符号之间差异就越小。这不仅对接收双方的器件要求很高，而且对环境的要求也很高。也就是说，如果环境过于恶劣，终端将无法使用高阶的 QAM 模式通信，只能使用较低阶次的调制模式。 4K-QAM 对信号的 EVM 要求已经到了 -38dB 了，已经是一个非常高的要求了 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:5:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#代价"},{"categories":["WirelessCommunication"],"content":" MIMO 增强在 Wi-Fi 6 里面，最大的空间流是 8×8，在 Wi-Fi 7 里面，最大空间流提升到了 16×16。不过需要注意一点的是，这个空间流实际上是跑的 MU-MIMO，而不是单纯的 MIMO，实际里面终端部分不会有那么多的天线链路。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#mimo-增强"},{"categories":["WirelessCommunication"],"content":" MLDMLD（Multi-Link Device）其实是MLO在物理层（PHY）的体现，传统的WiFi仅仅包含单个链路的连接能力，MLD能够允许一块IC里面包含多个device的连接能力。在之前部分厂商已经具备并实现该技术，如QCA的DBS以及MTK的DBDC，落实到具体的功能为双WiFi技术。 下图为传统的芯片结构，由两个独立的RF前端，一个基带处理部分，然后对应到上层接口，该方案只可以做到双频单发（DBSC）。 改进后的芯片结构大致如下图，由两个独立的 RF 前端，这两个独立的 RF 前端对应到两个独立的基带处理，然后对应到上层接口，因此可以在一块 IC 内部，做到两个频段同时连接，即双频双发（DBDC）。 802.11be对MLD部分做了一些改动，一个MLD设备由多个AP或者多个STA组成，并且引入新的MAC来标识MLD设备。新增的功能总结大致如下三点： 多链路发现和设置：MLD具有能够动态更新每对链路上同时进行帧交换的能力。每个单独的AP/STA还可以提供关于同一MLD内其他附属AP/STA的操作参数的信息。 流量链路映射：在多链路集里面，对数据帧进行分类的服务质量（QoS）标识符（TID）会映射到所有链路中。该映射会被MLD下所有链路协商更新。此外，MLD接收方将利用buff缓存对多个链路传输的相同TID的QoS数据帧进行重排。 信道访问和节省功率：MLD的每个AP/STA都会通过它自己所在链路频段接入信道，并独自维护其自身的功率状态。为了更有效的对STA功率管理，AP还可以利用多条链路中已连接的其中一条链路，通过缓冲数据来通知其他链路的功率调整。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#mld"},{"categories":["WirelessCommunication"],"content":" OFDMA 增强","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#ofdma-增强"},{"categories":["WirelessCommunication"],"content":" RUOFDMA 允许同时提供具有不同带宽需求的多个用户，从而有效利用可用频谱。子载波被分成若干组，每组表示为具有最小尺寸为 26 个子载波（2MHz 宽）和最大尺寸为 996 个子载波（77.8MHz 宽）的资源单元（RU）。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:1:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#ru"},{"categories":["WirelessCommunication"],"content":" 前导码打孔 \u0026 MRU 假设 S20 被雷达信号占用： Wi-Fi 6，STA 只能使用 P20 传输信号，40MHz 带宽被浪费 Wi-Fi 7，允许分配打孔 RU 组成 MRU，STA 可以使用 60MHz 带宽 打孔的类型：1. 静态打孔（建立 BSS 时打孔）；2. 动态打孔（传输 PPDU 时，在静态打孔的基础上，打孔附加的信道） 80MHz 允许打孔 20MHz 信道，160MHz 允许打孔 20/40MHz，320MHz 允许打孔 40/80/80+40MHz Wi-Fi 7 支持在 EHT PPDU 中使用 MRU，以获得更高的频谱效率，实际上 MRU 就是支持多种 tone 根据需要进行组合，使得 RU 分配更加灵活，减小延迟。 ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:2:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#前导码打孔--mru"},{"categories":["WirelessCommunication"],"content":" 参考[1] Key Advantages of Wi-Fi 7 MediaTek Whitepaper ","date":"2023-01-20","objectID":"/wi-fi7_phy_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 物理层解读","uri":"/wi-fi7_phy_synopsis/#参考"},{"categories":["WirelessCommunication"],"content":" Wi-Fi 7 变化的总结 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:0:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#"},{"categories":["WirelessCommunication"],"content":" Wi-Fi 7 的发布时间IEEE 802.11be EHT 工作组已于 2019 年 5 月成立，802.11be（Wi-Fi 7）的开发工作仍在进行中，整个协议标准将按照两个 Release 发布，Release1 预计在 2021 年将发布第一版草案 Draft1.0，预期在 2022 年底发布标准；Release2 预计在 2022 年初启动，并且在 2024 年底完成标准发布。 会议进程 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:1:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#wi-fi-7-的发布时间"},{"categories":["WirelessCommunication"],"content":" Wi-Fi 7 vs Wi-Fi 6 特性对比 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:2:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#wi-fi-7-vs-wi-fi-6"},{"categories":["WirelessCommunication"],"content":" Wi-Fi 7 支持的新特性Wi-Fi 7 协议的目标是将 WLAN 网络的吞吐率提升到 30Gbps，并且提供低时延的接入保障。为了满足这个目标，整个协议在 PHY 层和 MAC 层都做了相应的改变。相对于 Wi-Fi 6 协议，Wi-Fi 7 协议带来的主要技术变革点如下： ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:0","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#wi-fi-7-支持的新特性"},{"categories":["WirelessCommunication"],"content":" 新频段相比 Wi-Fi 6，7 引入了 6GHz 频段（6e 也有），上下限分别为 5.925 —— 7.125 GHz： 频段说明 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:1","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#新频段"},{"categories":["WirelessCommunication"],"content":" 支持最大 320MHz 带宽2.4GHz 和 5GHz 频段免授权频谱有限且拥挤，现有 Wi-Fi 在运行 VR/AR 等新兴应用时，不可避免地会遇到 QoS 低的问题。为了实现最大吞吐量不低于 30Gbps 的目标，Wi-Fi 7 将继续引入 6GHz 频段，并增加新的带宽模式，包括连续 240MHz，非连续 160+80MHz，连续 320 MHz 和非连续 160+160MHz。 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:2","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#支持最大-320mhz-带宽"},{"categories":["WirelessCommunication"],"content":" 支持 Multi-RU 机制在 Wi-Fi 6 中，每个用户只能在分配到的特定 RU 上发送或接收帧，大大限制了频谱资源调度的灵活性。为解决该问题，进一步提升频谱效率，Wi-Fi 7 中定义了允许将多个 RU 分配给单用户的机制。当然，为了平衡实现的复杂度和频谱的利用率，协议中对 RU 的组合做了一定的限制，即：小规格 RU（小于 242-Tone 的 RU）只能与小规格 RU 合并，大规格 RU（大于等于 242-Tone 的 RU）只能与大规格 RU 合并，不允许小规格 RU 和大规格 RU 混合使用。 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:3","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#支持-multi-ru-机制"},{"categories":["WirelessCommunication"],"content":" 引入更高阶的 4096-QAM 调制技术Wi-Fi 6 的最高调制方式是 1024-QAM，其中调制符号承载 10bits。为了进一步提升速率，Wi-Fi 7 将会引入 4096-QAM，使得调制符号承载 12bit。在相同的编码下，Wi-Fi 7 的 4096-QAM 比 Wi-Fi 6 的 1024-QAM 可以获得 20% 的速率提升。 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:4","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#引入更高阶的-4096-qam-调制技术"},{"categories":["WirelessCommunication"],"content":" 引入 Multi-Link 多链路机制为了实现所有可用频谱资源的高效利用，迫切需要在 2.4 GHz、5 GHz 和 6 GHz 上建立新的频谱管理、协调和传输机制。工作组定义了多链路聚合相关的技术，主要包括增强型多链路聚合的 MAC 架构、多链路信道接入和多链路传输等相关技术。 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:5","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#引入-multi-link-多链路机制"},{"categories":["WirelessCommunication"],"content":" 支持更多的数据流，MIMO 功能增强在 Wi-Fi 7 中，空间流的数从 Wi-Fi 6 的 8 个增加到 16 个，理论上可以将物理传输速率提升两倍以上。支持更多的数据流也将会带来更强大的特性——分布式 MIMO，意为 16 条数据流可以不由一个接入点提供，而是由多个接入点同时提供，这意味着多个 AP 之间需要相互协同进行工作。 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:6","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#支持更多的数据流mimo-功能增强"},{"categories":["WirelessCommunication"],"content":" 支持多 AP 间的协同调度目前在 802.11 的协议框架内，AP 之间实际上是没有太多协作的关系。自动调优、智能漫游等常见的 WLAN 功能都属于厂商自定义的特性。AP 间协作的目的也仅是优化信道选择，调整 AP 间负载等，以实现射频资源高效利用、均衡分配的目的。Wi-Fi 7 中的多 AP 间的协同调度，包括小区间的在时域和频域的协调规划，小区间的干扰协调，以及分布式 MIMO，可以有效降低 AP 之间的干扰，极大的提升空口资源的利用率。 多 AP 间的协同调度的方式有很多，包括 C-OFDMA（Coordinated Orthogonal Frequency-Division Multiple Access）、CSR（Coordinated Spatial Reuse）、CBF（Coordinated Beamforming）和 JXT（Joint Transmission）等。 ","date":"2023-01-20","objectID":"/wi-fi7_synopsis/:3:7","series":null,"tags":["Wi-Fi"],"title":"Wi-Fi 7 概述","uri":"/wi-fi7_synopsis/#支持多-ap-间的协同调度"},{"categories":["VM"],"content":" 如何调整已建立的 Hyper-V 虚拟机磁盘大小？本文以 Ubuntu 为例，对此进行介绍。 ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:0:0","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#"},{"categories":["VM"],"content":" 说明此教程适用于使用 LVM 格式化的任何 Ubuntu 文件系统。 如果你在使用 VMware，基本步骤与下面的教程类似，区别参见这里。 ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:1:0","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#说明"},{"categories":["VM"],"content":" TL;DR fdisk -l (note it’s partition 3 by looking at the current Size) parted resizepart, Fix, 3, 100% (type this instead), quit pvresize /dev/sda3 lvextend -l +100%FREE /dev/mapper/ubuntu–vg-ubuntu–lv resize2fs /dev/mapper/ubuntu–vg-ubuntu–lv df -h ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:2:0","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#tldr"},{"categories":["VM"],"content":" 具体步骤","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:3:0","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#具体步骤"},{"categories":["VM"],"content":" 查看剩余磁盘大小在下面的输出中，请注意 /root 卷只有 3.9 GB 的磁盘空间： user@server:~$ df -h Filesystem Size Used Avail Use% Mounted on udev 1.9G 0 1.9G 0% /dev tmpfs 394M 1.1M 393M 1% /run /dev/mapper/ubuntu--vg-ubuntu--lv 3.9G 3.2G 489M 87% / tmpfs 2.0G 0 2.0G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup /dev/loop0 89M 89M 0 100% /snap/core/7270 /dev/sda2 976M 77M 833M 9% /boot /dev/loop1 90M 90M 0 100% /snap/core/7713 tmpfs 394M 0 394M 0% /run/user/1000 接下来，在输出中可以看出实际上还有更多可用空间未利用。例如 /dev/sda3 卷上有 24G。另一个 1GB 用于启动卷和 BIOS 启动 user@server:~# fdisk -l Disk /dev/loop0: 88.5 MiB, 92778496 bytes, 181208 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk /dev/loop1: 89 MiB, 93327360 bytes, 182280 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes ... Disk /dev/sda: 25 GiB, 26843545600 bytes, 52428800 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes Disklabel type: gpt Disk identifier: ED41F7A6-5D09-457B-A55C-C7F1E30DE419 Device Start End Sectors Size Type /dev/sda1 2048 4095 2048 1M BIOS boot /dev/sda2 4096 2101247 2097152 1G Linux filesystem /dev/sda3 2101248 52426751 50325504 24G Linux filesystem Disk /dev/mapper/ubuntu--vg-ubuntu--lv: 4 GiB, 4294967296 bytes, 8388608 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 4096 bytes I/O size (minimum/optimal): 4096 bytes / 4096 bytes ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:3:1","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#查看剩余磁盘大小"},{"categories":["VM"],"content":" 调整虚拟机磁盘大小进入 Hyper-V 虚拟机设置界面，编辑硬盘驱动器，然后对此进行扩容，此后重启虚拟机。 ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:3:2","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#调整虚拟机磁盘大小"},{"categories":["VM"],"content":" 重新分区下面利用 parted 进行对新加的磁盘进行分区。 user@server:~# parted GNU Parted 3.2 Using /dev/sda Welcome to GNU Parted! Type 'help' to view a list of commands. (parted) print Model: Msft Virtual Disk (scsi) Disk /dev/sda: 26.8GB Sector size (logical/physical): 512B/4096B Partition Table: gpt Disk Flags: Number Start End Size File system Name Flags 1 1049kB 2097kB 1049kB bios_grub 2 2097kB 1076MB 1074MB ext4 3 1076MB 26.8GB 25.8GB (parted) quit user@server:~# parted GNU Parted 3.2 Using /dev/sda Welcome to GNU Parted! Type 'help' to view a list of commands. (parted) resizepart Partition number? 3 End? [26.8GB]? (parted) quit Information: You may need to update /etc/fstab. user@server:~# pvresize /dev/sda3 Physical volume \"/dev/sda3\" changed 1 physical volume(s) resized / 0 physical volume(s) not resized ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:3:3","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#重新分区"},{"categories":["VM"],"content":" 扩容接下来，对 LVM 虚拟磁盘进行扩容。 user@server:~# resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv resize2fs 1.44.1 (24-Mar-2018) Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /; on-line resizing required old_desc_blocks = 1, new_desc_blocks = 3 The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now 6029312 (4k) blocks long. ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:3:4","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#扩容"},{"categories":["VM"],"content":" 确认 user@server:~# df -h Filesystem Size Used Avail Use% Mounted on udev 1.9G 0 1.9G 0% /dev tmpfs 394M 1.1M 393M 1% /run /dev/mapper/ubuntu--vg-ubuntu--lv 23G 3.2G 19G 15% / tmpfs 2.0G 0 2.0G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 2.0G 0 2.0G 0% /sys/fs/cgroup /dev/loop0 89M 89M 0 100% /snap/core/7270 /dev/sda2 976M 77M 833M 9% /boot /dev/loop1 90M 90M 0 100% /snap/core/7713 tmpfs 394M 0 394M 0% /run/user/1000 user@server:~# ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:3:5","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#确认"},{"categories":["VM"],"content":" 参考 [1] How to resize an Ubuntu 18.04/20.04 LVM disk ","date":"2021-09-02","objectID":"/resize_vm_lvm_disk_size/:4:0","series":null,"tags":["Hyper-V","Linux"],"title":"快速调整 Hyper-V 虚拟机磁盘大小","uri":"/resize_vm_lvm_disk_size/#参考"},{"categories":null,"content":" 噢，你的 wife 丢了~ ","date":"2021-06-04","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"},{"categories":["Linux"],"content":" 一些提升 Bash 使用效率的小技巧 在使用 Bash 时，我们通常使用 上 ↑ 下 ↓ 箭头来快速切换历史命令，然而一些重复的、不想要的命令（例如最简单的 ls，敲击比切换快，同时也会增加切换到别的命令的按键次数）也在历史记录里保存，这降低了切换的效率。下面一些技巧可以更好的帮助我们切换到想要的命令： 说明 下文中需要编辑的内容均在.bashrc中，使用常用的文本编辑器打开它，例如： $ vim ~/.bashrc ","date":"2021-06-04","objectID":"/bash_tricks/:0:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#"},{"categories":["Linux"],"content":" 使用 HISTIGNORE 移除历史记录中无意义的命令有一些命令极为常用常用、或者敲击简单，我们不想它出现在历史记录里，那么在.bashrc中添加下述内容忽略它即可： export HISTIGNORE='pwd:exit:fg:bg:top:clear:history:ls:uptime:df' 作为补充，如果我们不希望某些敏感的命令出现在历史记录中，例如在命令行中指定密码或 API 密钥，那么可以使用下面的选项来确保任何以空格开头的命令不会出现在历史文件中： export HISTCONTROL=ignorespace 另外： export HISTCONTROL=ignoredups 则表示当同一个命令重复出现时，只存储命令的一个副本。 ","date":"2021-06-04","objectID":"/bash_tricks/:1:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#使用-histignore-移除历史记录中无意义的命令"},{"categories":["Linux"],"content":" 设置历史记录数量为了防止不必要的丢失，可以适当的将记录数量调整的更大： shopt -s histappend export HISTSIZE=10000 ","date":"2021-06-04","objectID":"/bash_tricks/:2:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#设置历史记录数量"},{"categories":["Linux"],"content":" 更有效的调用命令!!可以调用前一行的命令。 例如： $ pwd /etc $ !! pwd /etc 同时，!!也可以作为参数加入别的命令配合使用，例如： $ sudo !! 就将使用 root 权限再次执行此前的命令。 此外，我们还可以通过在历史命令提供的行号前加一个!来运行历史上的命令，但是请注意不要打错行号，避免执行出错： $ rm -r temp/ $ mkdir temp $ touch temp/test $ !! touch temp/test $ history | tail -4 179 rm -r temp/ 180 mkdir temp 181 touch temp/test 182 touch temp/test 183 history | tail -5 $ !179:p rm -r temp $ !180 touch temp/test 我们也可以用前面的!来调用一个命令的最后一次出现，例如: $ !ping 将运行我们最后运行的以 ping 开头的命令。 为了上述内容出错，可以添加一个:p来显示命令内容，而不实际执行它们。 ","date":"2021-06-04","objectID":"/bash_tricks/:3:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#更有效的调用命令"},{"categories":["Linux"],"content":" 使用 !$ 和 !* 调用前一行参数和!!不同，!$和!*仅指代前一行，命令的部分内容。 $ mv list.txt items.txt $ vim !$ vim items.txt $ cp !$ shopping.txt cp items.txt shopping.txt 可以看到!$指代上一行命令的最后一个参数。 而!*指代上一行命令除了第一个以外的所有参数： $ rm /var/log/httpd/access.log /var/log/httpd/error.log $ touch !* touch /var/log/httpd/access.log /var/log/httpd/error.log ","date":"2021-06-04","objectID":"/bash_tricks/:4:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#使用--和--调用前一行参数"},{"categories":["Linux"],"content":" 用 ^ 替换前一行的匹配词^符号允许你在切换一个匹配的单词后重复前一个命令，比如说： $ rm /var/log/httpd/error.log $ ^error^access rm /var/log/httpd/access.log ","date":"2021-06-04","objectID":"/bash_tricks/:5:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#用--替换前一行的匹配词"},{"categories":["Linux"],"content":" 参考 [1] Be more productive with use of your BASH history ","date":"2021-06-04","objectID":"/bash_tricks/:6:0","series":null,"tags":["Commands","Linux","Trick"],"title":"不容错过的 Bash 技巧","uri":"/bash_tricks/#参考"},{"categories":["Network"],"content":" inoreader 等现有服务要么付费要么有限制，有服务器的话自建 FreshRSS 是一个很好的选择 注意 境外服务器是保证服务可用性的条件之一 ","date":"2021-05-28","objectID":"/frsshrss/:0:0","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#"},{"categories":["Network"],"content":" FreshRSS Docker 配置创建一个新目录 ~/freshrss 并进入该位置，新建 docker-compose.yml # 创建 FreshRSS 目录并进入 mkdir ~/freshrss \u0026\u0026 cd ~/freshrss # 新建\u0026编辑配置文件 vim docker-compose.yml ","date":"2021-05-28","objectID":"/frsshrss/:1:0","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#freshrss-docker-配置"},{"categories":["Network"],"content":" docker-compose.yml配置文件内容见下： # ~/freshrss/docker-compose.yml version: \"3\" services: freshrss-db: image: postgres:latest # 官方示例中给出了 MySQL/MarriaDB/PostgreSQL 三种方案 container_name: freshrss-db hostname: freshrss-db restart: always volumes: - freshrss-db:/var/lib/postgresql/data environment: POSTGRES_USER: freshrss # 数据库配置，请自行修改、避免使用默认配置 POSTGRES_PASSWORD: freshrss # 数据库配置，请自行修改、避免使用默认配置 POSTGRES_DB: freshrss # 数据库配置，请自行修改、避免使用默认配置 freshrss-app: image: freshrss/freshrss:latest container_name: freshrss-app hostname: freshrss-app restart: always ports: - \"39954:80\" # 映射端口 depends_on: - freshrss-db volumes: - ./data:/var/www/FreshRSS/data - ./extensions:/var/www/FreshRSS/extensions environment: CRON_MIN: '*/45' # RSS 刷新周期，单位为分钟，*/45 表示每 45 分钟刷新一次 TZ: Asia/Shanghai # 时区 volumes: freshrss-db: 确认配置后，运行： $ docker-compose up -d ","date":"2021-05-28","objectID":"/frsshrss/:1:1","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#docker-composeyml"},{"categories":["Network"],"content":" FreshRSS 设置","date":"2021-05-28","objectID":"/frsshrss/:2:0","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#freshrss-设置"},{"categories":["Network"],"content":" 初始化数据库连接需要注意的点： 主机名填写 freshrss-db（数据库 docker 容器名） 用户名、密码、数据库分别对应之前 Docker Compose 配置文件中的 POSTGRES_USER、POSTGRES_PASSWORD、POSTGRES_DB 表前缀任意填 ","date":"2021-05-28","objectID":"/frsshrss/:2:1","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#初始化"},{"categories":["Network"],"content":" 设置最好关闭阅读 =\u003e 合适将文章标记为已读的在滚动浏览后，否则即便不点击打开文章、只要你划过去就标记为已读 ","date":"2021-05-28","objectID":"/frsshrss/:2:2","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#设置"},{"categories":["Network"],"content":" 扩展一个重要的扩展是 Auto Refresh，实现自动刷新源 点击扩展页面中的相应扩展，会跳转到相应的下载地址，将扩展下载后上传到 FreshRSS 安装目录下的 extensions 文件夹（之前部署 FreshRSS 的 Docker Compose 配置文件中已经将 ~/freshrss/extensions/ 对应了 FreshRSS 在容器内的扩展位置，所以只需要将扩展拖至 ~/freshrss/extensions/ 即可） 将解压后的 xExtension-AutoRefresh 文件夹放到 ~/freshrss/extensions 目中，到 FreshRSS 设置-\u003e 扩展 启用，刷新时间需要修改 xExtension-AutoRefresh/static/script.js ，其中时间相关单位是 ms ","date":"2021-05-28","objectID":"/frsshrss/:2:3","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#扩展"},{"categories":["Network"],"content":" Nginx 反向代理参见使用 Nginx 实现多服务复用端口 ","date":"2021-05-28","objectID":"/frsshrss/:3:0","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#nginx-反向代理"},{"categories":["Network"],"content":" 配合第三方软件推荐搭配Feedme 、Fluent reader食用更佳 在此之前需要到开启认证 =\u003e 允许 API 访问，并在用户账户 =\u003e API 管理中设置相应的 API 密码 需要注意，Feedme服务应选择FreshRSS 参数配置如下： 域名：https://xxx.techkoala.top/api/fever.php # Fluent reader 域名：https://xxx.techkoala.top/api/greader.php # Feedme 使用 fever会出现 Auth Failed 用户名：注册用户名 密码：API 密码 ","date":"2021-05-28","objectID":"/frsshrss/:4:0","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#配合第三方软件"},{"categories":["Network"],"content":" 参考 [1] 使用 Docker 部署 FreshRSS 自建专属 RSS 服务 ","date":"2021-05-28","objectID":"/frsshrss/:5:0","series":null,"tags":["Software","RSS","Docker","FreshRSS"],"title":"Docker 搭建 FreshRSS 专属 RSS 服务 ","uri":"/frsshrss/#参考"},{"categories":["Software"],"content":" 记录一些常用的 youtube-dl 命令，拯救脑容量。 ","date":"2021-05-18","objectID":"/youtube-dl_tricks/:0:0","series":null,"tags":["Software","youtube-dl"],"title":"常用 youtube-dl 命令","uri":"/youtube-dl_tricks/#"},{"categories":["Software"],"content":" 下载播放列表视频+音频Windows youtube-dl.exe -o \"D:\\xxxxxx\\%(title)s.%(ext)s\" -f bestvideo+bestaudio https://www.youtube.com/playlist?list=x ","date":"2021-05-18","objectID":"/youtube-dl_tricks/:1:0","series":null,"tags":["Software","youtube-dl"],"title":"常用 youtube-dl 命令","uri":"/youtube-dl_tricks/#下载播放列表视频音频"},{"categories":["Software"],"content":" 仅下载播放列表音频 youtububedl.exe -o D:\\%(title)s.%(ext)s -f bestaudio --extract-audio --audio-format mp3 --audio-quality 0 https://www.youtube.com/playlist?list=xxxxxxxxxxxx -o D:\\%(title)s.%(ext)s #保留原始名称和后缀 -f bestaudio #最佳音频 --extract-audio #提取音频 --audio-format mp3 #设置音频格式，下载文件若不同，则调用ffmpeg转换 --playlist-items 1,2,5 #下载播放列表中的哪些项 --playstart-start 2 #从第二项开始下载播放列表 --playstart-end 2 -f 'bestvideo[height\u003c=1080]+bestaudio/best[height\u003c=1080]' #设置最大下载分辨率 ","date":"2021-05-18","objectID":"/youtube-dl_tricks/:2:0","series":null,"tags":["Software","youtube-dl"],"title":"常用 youtube-dl 命令","uri":"/youtube-dl_tricks/#仅下载播放列表音频"},{"categories":["Git"],"content":" 如何持久化 Gist file raw 链接地址？ ","date":"2021-05-03","objectID":"/permalink_gist_raw_file/:0:0","series":null,"tags":["Github"],"title":"持久化 Gist file raw 链接","uri":"/permalink_gist_raw_file/#"},{"categories":["Git"],"content":" 问题通常，Gist 文件的 raw 链接会随着版本二更改，但在使用上往往不便，因此需要持久化文件的 raw 链接地址。 ","date":"2021-05-03","objectID":"/permalink_gist_raw_file/:1:0","series":null,"tags":["Github"],"title":"持久化 Gist file raw 链接","uri":"/permalink_gist_raw_file/#问题"},{"categories":["Git"],"content":" 解决方法 获得 Gist 文件列表中的第一个文件： https://gist.github.com/gist_user/gist_id/raw/ 例如: https://gist.github.com/atenni/5604522/raw/ 即便更改了文件名，上述方法依然可以获得列表中的第一个文件。 获得多个文件： https://gist.github.com/gist_user/gist_id/raw/file_name 例如: https://gist.github.com/atenni/5604522/raw/README.md ","date":"2021-05-03","objectID":"/permalink_gist_raw_file/:2:0","series":null,"tags":["Github"],"title":"持久化 Gist file raw 链接","uri":"/permalink_gist_raw_file/#解决方法"},{"categories":["Git"],"content":" 参考 [1] How to permalink to a gist’s raw file ","date":"2021-05-03","objectID":"/permalink_gist_raw_file/:3:0","series":null,"tags":["Github"],"title":"持久化 Gist file raw 链接","uri":"/permalink_gist_raw_file/#参考"},{"categories":["Network"],"content":" Windows10 默认优先使用有线连接，但是如需优先使用无线连接，除了拔网线/禁用有线网卡外，还可以通过修改接口跃点数，实现不同网络连接的优先级。 ","date":"2021-04-29","objectID":"/windows_10_network_priority/:0:0","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#"},{"categories":["Network"],"content":" 优先级设置方法","date":"2021-04-29","objectID":"/windows_10_network_priority/:1:0","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#优先级设置方法"},{"categories":["Network"],"content":" 方法一：控制面板中修改接口跃点数通过以下步骤找到： 首先打开控制面板 \u003e 网络和 Internet \u003e 网络连接 找到想要修改的网络连接，右键打开属性 接下来打开Internet 协议版本 4 属性 \u003e 高级 控制面板设置界面 取消勾选自动跃点，填入需要设置的数值即可，有关数值设置的注意事项将在后续说明。 ","date":"2021-04-29","objectID":"/windows_10_network_priority/:1:1","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#方法一控制面板中修改"},{"categories":["Network"],"content":" 方法二：Powershell 中修改更便捷的方式是通过 Powershell 进行修改。 首先以管理员身份运行 Windows PowerShell，并使用命令 PS C:\\Users\\xxxx\u003e Get-NetIPInterface 获得当前所有的网络连接，其中InterfaceMetric即为接口跃点数的值。 Powershell 设置界面 找到想要修改的网络连接以及它的 ifIndex (接口索引)值，例如 x，使用命令 PS C:\\Users\\xxxx\u003e Set-NetIPInterface -InterfaceIndex x -InterfaceMetric 10 即可将其跃点数设置为 10。 想要恢复跃点数的话，运行以下命令即可： PS C:\\Users\\xxxx\u003e Set-NetIPInterface -InterfaceIndex x -AutomaticMetric enabled ","date":"2021-04-29","objectID":"/windows_10_network_priority/:1:2","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#方法二powershell-中修改"},{"categories":["Network"],"content":" 跃点数的设置范围跃点数越小，网络优先级越高。 跃点数的理论范围是 1 ~ 999，但跃点数低于 10 ，可能会导致某些网络访问失败，同时，合理的跃点数值也要参考网络带宽。 ","date":"2021-04-29","objectID":"/windows_10_network_priority/:1:3","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#跃点数的设置范围"},{"categories":["Network"],"content":" 分流方法在同时使用 Wi-Fi 和有线网络的环境下可以用 route 命令实现特定网段使用特定接口。 举例： 可以连接到互联网的 Wi-Fi 网关地址是 192.168.0.1，有线网网关 IP 是 10.0.0.1。 分流：需要访问的内网资源都位于 10.0.0.0/8 段，其他流量都走 Wi-Fi。 首先打开管理员身份的命令提示符，输入以下命令删除默认的路由表。 route delete 0.0.0.0 添加一个默认路由，指定所有流量走 Wi-Fi。 route add 0.0.0.0 mask 0.0.0.0 192.168.0.1 添加另一个路由，指定 10.0.0.1~10.255.255.254 流量走有线网络。 route add 10.0.0.0 mask 255.0.0.0 10.0.0.1 ","date":"2021-04-29","objectID":"/windows_10_network_priority/:2:0","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#分流方法"},{"categories":["Network"],"content":" 参考 [1] 修改接口跃点数，让 Win10 优先使用无线网络连接 [2] 同时连接网线和 Wi-Fi，如何优先使用 Wi-Fi？试试接口跃点数 ","date":"2021-04-29","objectID":"/windows_10_network_priority/:3:0","series":null,"tags":["LAN","Windows"],"title":"Windows 网络连接优先级设置","uri":"/windows_10_network_priority/#参考"},{"categories":["Network"],"content":" 利用 Nginx 在单一服务器上搭建多个同端口的服务 ","date":"2021-04-20","objectID":"/nginx_port_reuse/:0:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#"},{"categories":["Network"],"content":" 说明目前服务器上运行以下服务： Trojan Xray frp + Bitwarden 实现内网穿透访问 FreshRSS 三个服务使用了不同域名进行区分，但为了便捷，都使用 443 端口。 ","date":"2021-04-20","objectID":"/nginx_port_reuse/:1:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#说明"},{"categories":["Network"],"content":" 流程概览 采用 Docker 在本地服务器上搭建 Bitwarden，配置并运行 frpc 指向服务器上的 frps 在服务器上搭建其他网站或者需要使用 443 端口的服务（如：Trojan)，配置运行 frps 采用 Docker 搭建 FreshRSS，首先使用 IP:Port 完成相关配置，然后配置域名，申请证书 安装 Nginx，这里需要利用 Nginx 的 stream_ssl_preread 模块，使用nginx -V查看是否包含该模块。（该模块在 Nginx 1.19.2 已默认包含，但 Ubuntu 等发行版还在使用更老的 stable 版本，需要手动添加 mainline 版本源，并更新 Nginx 到最新版本） ","date":"2021-04-20","objectID":"/nginx_port_reuse/:2:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#流程概览"},{"categories":["Network"],"content":" 获取 SSL 证书 $ sudo apt install certbot python3-certbot-nginx $ sudo certbot --nginx -d example.com -d www.example.com ","date":"2021-04-20","objectID":"/nginx_port_reuse/:3:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#获取-ssl-证书"},{"categories":["Network"],"content":" 本地配置文件","date":"2021-04-20","objectID":"/nginx_port_reuse/:4:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#本地配置文件"},{"categories":["Network"],"content":" frpc.ini [common] server_addr = xxx.xxx.xxx.xxx # 服务器地址 server_port = xxx # 与服务器 frps 通信的端口 token = xxxxxx # frp 验证密钥 [bitwarden_https] type = https local_port = 443 custom_domains = xxx.xxx.xxx # Bitwarden 域名 ","date":"2021-04-20","objectID":"/nginx_port_reuse/:4:1","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#frpcini"},{"categories":["Network"],"content":" 本地 nginx.cof user www www; worker_processes auto; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; worker_rlimit_nofile 8192; events { worker_connections 4096; } http { include mime.types; default_type application/octet-stream; client_max_body_size 0; client_body_buffer_size 512k; sendfile on; sendfile_max_chunk 1m; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 4096; proxy_cache_path /var/run/nginx-proxy-cache levels=1:2 keys_zone=cache_one:20m inactive=1d max_size=500m; proxy_cache cache_one; proxy_temp_path /var/run/proxy_temp_dir; proxy_temp_file_write_size 128k; proxy_next_upstream error timeout invalid_header http_500 http_503 http_404; proxy_buffer_size 16k; proxy_busy_buffers_size 24k; proxy_buffers 64 4k; gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.1; gzip_comp_level 2; gzip_types text/plain application/javascript application/x-javascript text/javascript text/css application/xml; gzip_vary on; gzip_proxied expired no-cache no-store private auth; gzip_disable \"MSIE [1-6]\\.\"; server_tokens off; server { listen 443 ssl http2; server_name xxx.xxx.xxx; # 域名 ssl_certificate /xxx/cert/fullchain.pem; # 证书路径 ssl_certificate_key /xxx/cert/privkey.pem; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384; ssl_prefer_server_ciphers off; ssl_session_cache shared:SSL:10m; ssl_session_timeout 1d; location / { proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } location /notifications/hub { proxy_pass http://127.0.0.1:3012; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } location /notifications/hub/negotiate { proxy_pass http://127.0.0.1:8080; } } } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:4:2","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#本地-nginxcof"},{"categories":["Network"],"content":" 服务器配置文件","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#服务器配置文件"},{"categories":["Network"],"content":" 服务器 nginx.cof user www-data; worker_processes auto; pid /var/run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 768; # multi_accept on; } stream { map $ssl_preread_server_name $name { xxx.techkoala.net frps-bitwarden; # Bitwarden 域名 xxx.techkoala.net trojan; # Trojan 域名 xxx.techkoala.net rss; # FreshRSS 域名 xxx.techkoala.net xtls; # Xray 域名 } upstream frps-bitwarden { server 127.0.0.1:8080; # Bitwarden的 frps 端口 } upstream trojan { server 127.0.0.1:4443; # Trojan 本地监听端口 } upstream rss { server 172.17.0.1:39955; # FreshRSS Docker IP 以及映射本地监听端口 } upstream xtls { server 127.0.0.1:8443; # Xray 本地监听端口 } server { listen 443 reuseport; listen [::]:443 reuseport; proxy_pass $name; ssl_preread on; # 开启 ssl_preread } } http { ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*; # 启用的网站配置放置在此文件夹下 } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:1","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#服务器-nginxcof"},{"categories":["Network"],"content":" Bitwarden 相关配置 frps.ini [common] bind_port = xxxx # 与本地 frpc 通信的端口 vhost_https_port = xxxx # 虚拟 https 端口，需要和 nginx.conf 内一致 authentication_method = token token = xxxxxx # frp 验证密钥 Bitwarden Nginx 站点配置放置在/etc/nginx/sites-available/下，文件与域名同名 ## Bitwarden 配置。只负责只将 http 重定向至 https ## Bitwarden 的 SSL 握手交给本地服务器端的 Nginx 处理 server { listen 80; listen [::]:80; server_name xxx.techkoala.net; # Bitwarden 域名 return 301 https://xxx.techkoala.net$request_uri; # Bitwarden 域名 } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:2","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#bitwarden-相关配置"},{"categories":["Network"],"content":" Bitwarden 相关配置 frps.ini [common] bind_port = xxxx # 与本地 frpc 通信的端口 vhost_https_port = xxxx # 虚拟 https 端口，需要和 nginx.conf 内一致 authentication_method = token token = xxxxxx # frp 验证密钥 Bitwarden Nginx 站点配置放置在/etc/nginx/sites-available/下，文件与域名同名 ## Bitwarden 配置。只负责只将 http 重定向至 https ## Bitwarden 的 SSL 握手交给本地服务器端的 Nginx 处理 server { listen 80; listen [::]:80; server_name xxx.techkoala.net; # Bitwarden 域名 return 301 https://xxx.techkoala.net$request_uri; # Bitwarden 域名 } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:2","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#frpsini"},{"categories":["Network"],"content":" Bitwarden 相关配置 frps.ini [common] bind_port = xxxx # 与本地 frpc 通信的端口 vhost_https_port = xxxx # 虚拟 https 端口，需要和 nginx.conf 内一致 authentication_method = token token = xxxxxx # frp 验证密钥 Bitwarden Nginx 站点配置放置在/etc/nginx/sites-available/下，文件与域名同名 ## Bitwarden 配置。只负责只将 http 重定向至 https ## Bitwarden 的 SSL 握手交给本地服务器端的 Nginx 处理 server { listen 80; listen [::]:80; server_name xxx.techkoala.net; # Bitwarden 域名 return 301 https://xxx.techkoala.net$request_uri; # Bitwarden 域名 } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:2","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#bitwarden-nginx-站点配置"},{"categories":["Network"],"content":" Trojan 相关配置 Trojan Nginx 配置放置在/etc/nginx/sites-available/下，文件与域名同名 server { listen 127.0.0.1:80 default_server; server_name xxx.techkoala.net; # 自己的域名 location / { proxy_pass https://www.digitalocean.com; # 伪装的网站 } } server { listen 127.0.0.1:80; server_name xxx.techkoala.net; # 自己服务器的 IP return 301 https://xxx.techkoala.net$request_uri; # 自己的域名 } server { listen 0.0.0.0:80; listen [::]:80; server_name _; return 301 https://$host$request_uri; } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ Trojan 配置文件 { \"run_type\": \"server\", \"local_addr\": \"0.0.0.0\", \"local_port\": 4443, # 本地监听端口，与 nginx.conf 保持一致 \"remote_addr\": \"127.0.0.1\", \"remote_port\": 80, # 伪装站点的端口 \"password\": [ \"xxxxxx\" # 密钥 ], \"log_level\": 1, \"ssl\": { \"cert\": \"/usr/local/etc/ssl/certificate.crt\", \"key\": \"/usr/local/etc/ssl/private.key\", \"key_password\": \"\", \"cipher\": \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\", \"cipher_tls13\": \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\", \"prefer_server_cipher\": true, \"alpn\": [ \"http/1.1\" ], \"alpn_port_override\": { \"h2\": 81 }, \"reuse_session\": true, \"session_ticket\": false, \"session_timeout\": 600, \"plain_http_response\": \"\", \"curves\": \"\", \"dhparam\": \"\" }, \"tcp\": { \"prefer_ipv4\": false, \"no_delay\": true, \"keep_alive\": true, \"reuse_port\": false, \"fast_open\": false, \"fast_open_qlen\": 20 }, \"mysql\": { \"enabled\": false, \"server_addr\": \"127.0.0.1\", \"server_port\": 3306, \"database\": \"trojan\", \"username\": \"trojan\", \"password\": \"\", \"key\": \"\", \"cert\": \"\", \"ca\": \"\" } } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:3","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#trojan-相关配置"},{"categories":["Network"],"content":" Trojan 相关配置 Trojan Nginx 配置放置在/etc/nginx/sites-available/下，文件与域名同名 server { listen 127.0.0.1:80 default_server; server_name xxx.techkoala.net; # 自己的域名 location / { proxy_pass https://www.digitalocean.com; # 伪装的网站 } } server { listen 127.0.0.1:80; server_name xxx.techkoala.net; # 自己服务器的 IP return 301 https://xxx.techkoala.net$request_uri; # 自己的域名 } server { listen 0.0.0.0:80; listen [::]:80; server_name _; return 301 https://$host$request_uri; } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ Trojan 配置文件 { \"run_type\": \"server\", \"local_addr\": \"0.0.0.0\", \"local_port\": 4443, # 本地监听端口，与 nginx.conf 保持一致 \"remote_addr\": \"127.0.0.1\", \"remote_port\": 80, # 伪装站点的端口 \"password\": [ \"xxxxxx\" # 密钥 ], \"log_level\": 1, \"ssl\": { \"cert\": \"/usr/local/etc/ssl/certificate.crt\", \"key\": \"/usr/local/etc/ssl/private.key\", \"key_password\": \"\", \"cipher\": \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\", \"cipher_tls13\": \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\", \"prefer_server_cipher\": true, \"alpn\": [ \"http/1.1\" ], \"alpn_port_override\": { \"h2\": 81 }, \"reuse_session\": true, \"session_ticket\": false, \"session_timeout\": 600, \"plain_http_response\": \"\", \"curves\": \"\", \"dhparam\": \"\" }, \"tcp\": { \"prefer_ipv4\": false, \"no_delay\": true, \"keep_alive\": true, \"reuse_port\": false, \"fast_open\": false, \"fast_open_qlen\": 20 }, \"mysql\": { \"enabled\": false, \"server_addr\": \"127.0.0.1\", \"server_port\": 3306, \"database\": \"trojan\", \"username\": \"trojan\", \"password\": \"\", \"key\": \"\", \"cert\": \"\", \"ca\": \"\" } } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:3","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#trojan-nginx-配置"},{"categories":["Network"],"content":" Trojan 相关配置 Trojan Nginx 配置放置在/etc/nginx/sites-available/下，文件与域名同名 server { listen 127.0.0.1:80 default_server; server_name xxx.techkoala.net; # 自己的域名 location / { proxy_pass https://www.digitalocean.com; # 伪装的网站 } } server { listen 127.0.0.1:80; server_name xxx.techkoala.net; # 自己服务器的 IP return 301 https://xxx.techkoala.net$request_uri; # 自己的域名 } server { listen 0.0.0.0:80; listen [::]:80; server_name _; return 301 https://$host$request_uri; } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ Trojan 配置文件 { \"run_type\": \"server\", \"local_addr\": \"0.0.0.0\", \"local_port\": 4443, # 本地监听端口，与 nginx.conf 保持一致 \"remote_addr\": \"127.0.0.1\", \"remote_port\": 80, # 伪装站点的端口 \"password\": [ \"xxxxxx\" # 密钥 ], \"log_level\": 1, \"ssl\": { \"cert\": \"/usr/local/etc/ssl/certificate.crt\", \"key\": \"/usr/local/etc/ssl/private.key\", \"key_password\": \"\", \"cipher\": \"ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\", \"cipher_tls13\": \"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384\", \"prefer_server_cipher\": true, \"alpn\": [ \"http/1.1\" ], \"alpn_port_override\": { \"h2\": 81 }, \"reuse_session\": true, \"session_ticket\": false, \"session_timeout\": 600, \"plain_http_response\": \"\", \"curves\": \"\", \"dhparam\": \"\" }, \"tcp\": { \"prefer_ipv4\": false, \"no_delay\": true, \"keep_alive\": true, \"reuse_port\": false, \"fast_open\": false, \"fast_open_qlen\": 20 }, \"mysql\": { \"enabled\": false, \"server_addr\": \"127.0.0.1\", \"server_port\": 3306, \"database\": \"trojan\", \"username\": \"trojan\", \"password\": \"\", \"key\": \"\", \"cert\": \"\", \"ca\": \"\" } } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:3","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#trojan-配置文件"},{"categories":["Network"],"content":" FreshRSS 站点配置放置在/etc/nginx/sites-available/下，文件与域名同名 server { listen 80; listen [::]:80; server_name xxx.techkoala.net; return 301 https://xxx.techkoala.net$request_uri; } server { listen 39955 ssl http2; # FreshRSS 本地监听端口 #===注意，nginx 1.25.1之后这里需要修改为 listen 39955 ssl; http2 on; #=== server_name rss.techkoala.net; ssl_certificate /etc/letsencrypt/live/xxx.techkoala.net/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/xxx.techkoala.net/privkey.pem; location / { proxy_pass http://127.0.0.1:39954; # 转发到 FreshRSS 容器映射的端口 } } 链接配置文件 ln -s /etc/nginx/sites-available/xxx.techkoala.net /etc/nginx/sites-enabled/ ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:4","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#freshrss-站点配置"},{"categories":["Network"],"content":" Xray Xray Nginx 配置 server { listen 80; server_name xxx.techkoala.net; if ($host = xxxx.techkoala.net) { return 301 https://$host$request_uri; } return 404; } server { listen 127.0.0.1:23333; server_name xxxx.techkoala.net; location / { proxy_pass https://www.digitalocean.com; # 伪装的网站 } } Xray 配置 { \"log\": { \"loglevel\": \"warning\" }, \"inbounds\": [ { \"listen\": \"127.0.0.1\", # 仅监听在本地防止探测到下面的 8443 端口 \"port\": 8443, # 这里的端口对应 nginx 主配置文件内的 upstream 端口 \"protocol\": \"vless\", \"settings\": { \"clients\": [ { \"id\": \"7f46753a-6a4b-4284-94c0-760340f96f1e\", # 填写你的UUID \"flow\": \"xtls-rprx-direct\", \"level\": 0 } ], \"decryption\": \"none\", \"fallbacks\": [ { \"dest\": \"23333\" # 回落站点的端口号，与 Xray Nginx 配置一致 } ] }, \"streamSettings\": { \"network\": \"tcp\", \"security\": \"xtls\", \"xtlsSettings\": { \"alpn\": [ \"http/1.1\" ], \"certificates\": [ { \"certificateFile\": \"/usr/local/etc/ssl/fullchain.pem\", # 你的域名证书 \"keyFile\": \"/usr/local/etc/ssl/privkey.pem\" # 你的证书私钥 } ] } } } ], \"outbounds\": [ { \"protocol\": \"freedom\" } ] } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:5","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#xray"},{"categories":["Network"],"content":" Xray Xray Nginx 配置 server { listen 80; server_name xxx.techkoala.net; if ($host = xxxx.techkoala.net) { return 301 https://$host$request_uri; } return 404; } server { listen 127.0.0.1:23333; server_name xxxx.techkoala.net; location / { proxy_pass https://www.digitalocean.com; # 伪装的网站 } } Xray 配置 { \"log\": { \"loglevel\": \"warning\" }, \"inbounds\": [ { \"listen\": \"127.0.0.1\", # 仅监听在本地防止探测到下面的 8443 端口 \"port\": 8443, # 这里的端口对应 nginx 主配置文件内的 upstream 端口 \"protocol\": \"vless\", \"settings\": { \"clients\": [ { \"id\": \"7f46753a-6a4b-4284-94c0-760340f96f1e\", # 填写你的UUID \"flow\": \"xtls-rprx-direct\", \"level\": 0 } ], \"decryption\": \"none\", \"fallbacks\": [ { \"dest\": \"23333\" # 回落站点的端口号，与 Xray Nginx 配置一致 } ] }, \"streamSettings\": { \"network\": \"tcp\", \"security\": \"xtls\", \"xtlsSettings\": { \"alpn\": [ \"http/1.1\" ], \"certificates\": [ { \"certificateFile\": \"/usr/local/etc/ssl/fullchain.pem\", # 你的域名证书 \"keyFile\": \"/usr/local/etc/ssl/privkey.pem\" # 你的证书私钥 } ] } } } ], \"outbounds\": [ { \"protocol\": \"freedom\" } ] } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:5","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#xray-nginx-配置"},{"categories":["Network"],"content":" Xray Xray Nginx 配置 server { listen 80; server_name xxx.techkoala.net; if ($host = xxxx.techkoala.net) { return 301 https://$host$request_uri; } return 404; } server { listen 127.0.0.1:23333; server_name xxxx.techkoala.net; location / { proxy_pass https://www.digitalocean.com; # 伪装的网站 } } Xray 配置 { \"log\": { \"loglevel\": \"warning\" }, \"inbounds\": [ { \"listen\": \"127.0.0.1\", # 仅监听在本地防止探测到下面的 8443 端口 \"port\": 8443, # 这里的端口对应 nginx 主配置文件内的 upstream 端口 \"protocol\": \"vless\", \"settings\": { \"clients\": [ { \"id\": \"7f46753a-6a4b-4284-94c0-760340f96f1e\", # 填写你的UUID \"flow\": \"xtls-rprx-direct\", \"level\": 0 } ], \"decryption\": \"none\", \"fallbacks\": [ { \"dest\": \"23333\" # 回落站点的端口号，与 Xray Nginx 配置一致 } ] }, \"streamSettings\": { \"network\": \"tcp\", \"security\": \"xtls\", \"xtlsSettings\": { \"alpn\": [ \"http/1.1\" ], \"certificates\": [ { \"certificateFile\": \"/usr/local/etc/ssl/fullchain.pem\", # 你的域名证书 \"keyFile\": \"/usr/local/etc/ssl/privkey.pem\" # 你的证书私钥 } ] } } } ], \"outbounds\": [ { \"protocol\": \"freedom\" } ] } ","date":"2021-04-20","objectID":"/nginx_port_reuse/:5:5","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#xray-配置"},{"categories":["Network"],"content":" 防火墙设置上述操作后，服务器需要打开80,443,xxx（frp 通信端口） ","date":"2021-04-20","objectID":"/nginx_port_reuse/:6:0","series":null,"tags":["Software","Nginx","Bitwarden","Trojan","FreshRSS"],"title":"使用 Nginx 实现多服务复用端口","uri":"/nginx_port_reuse/#防火墙设置"},{"categories":["Network"],"content":" OpenWRT 默认并不支持 DoH 或 DoT，存在 DNS 泄露问题，本文介绍如何 dnscrypt-proxy2 进行加密查询，以及如何与上网插件进行搭配使用 ","date":"2021-01-29","objectID":"/openwrt_doh/:0:0","series":null,"tags":["OpenWRT","Router","DNS"],"title":"OpenWRT 使用 dnscrypt-proxy2 实现 DoH 查询及分流","uri":"/openwrt_doh/#"},{"categories":["Network"],"content":" 安裝 dnscrypt-proxy2如果使用 OpenWrt 19.07+版本，那么直接使用 opkg 即可完成安装，命令如下： opkg update opkg install dnscrypt-proxy2 不过，版本可能不是最新，如果需要最新版本可以自行编译。 ","date":"2021-01-29","objectID":"/openwrt_doh/:1:0","series":null,"tags":["OpenWRT","Router","DNS"],"title":"OpenWRT 使用 dnscrypt-proxy2 实现 DoH 查询及分流","uri":"/openwrt_doh/#安裝-dnscrypt-proxy2"},{"categories":["Network"],"content":" 配置基本使用只需要 vim /etc/dnscrypt-proxy2/dnscrypt-proxy.toml 修改 listen_addresses = ['127.0.0.1:5335'] server_names = ['google', 'cloudflare'] 即可 软件已经内置了常见的 DoH/DoT 服务器了，因此只需要填入名称即可 然后 /etc/init.d/dnscrypt-proxy restart 重启软件，dnscrypt-proxy2 就会监听在 5335 这个端口了。 ","date":"2021-01-29","objectID":"/openwrt_doh/:2:0","series":null,"tags":["OpenWRT","Router","DNS"],"title":"OpenWRT 使用 dnscrypt-proxy2 实现 DoH 查询及分流","uri":"/openwrt_doh/#配置"},{"categories":["Network"],"content":" 分流（搭配 SSR+） SSR+ 使用大陆 IP 白名单 并使用 5335 的 DNS 解析的方式 dnscyrpt-proxy2 配置监听在 5335，仅使用 DoH 协议向 Cloudflare/Google 服务器查询（这些 Https 的查询请求全部会被 SSR+ 代理转发） iptables 劫持所有目标为 53 端口的流量到路由器的 53 端口（默认） 53 端口使用默认的 dnsmasq 作为 DNS 服务，上游设置为 127.0.0.1#5335，配置文件/etc/dnsmasq.conf最后添加 conf-dir=/etc/dnsmasq.d 在/etc/dnsmasq.d/(如无则新建）中放入https://github.com/felixonmars/dnsmasq-china-list/blob/master/accelerated-domains.china.conf 这样实现了凡是大陆的和在大陆有 cdn 的以及返回 AAAA 记录的域名全部直连查询并直连访问，其余的全部走代理查询，且结果在大陆以外的走代理访问（IP+域名的双白名单机制） ","date":"2021-01-29","objectID":"/openwrt_doh/:3:0","series":null,"tags":["OpenWRT","Router","DNS"],"title":"OpenWRT 使用 dnscrypt-proxy2 实现 DoH 查询及分流","uri":"/openwrt_doh/#分流搭配-ssr"},{"categories":["Network"],"content":" 参考 [1] lede [2] Installation on OpenWrt ","date":"2021-01-29","objectID":"/openwrt_doh/:4:0","series":null,"tags":["OpenWRT","Router","DNS"],"title":"OpenWRT 使用 dnscrypt-proxy2 实现 DoH 查询及分流","uri":"/openwrt_doh/#参考"},{"categories":["Software"],"content":" 记录使用 Vim 时遇到实用的小技巧 ","date":"2021-01-19","objectID":"/vim_tips/:0:0","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#"},{"categories":["Software"],"content":" 全局命令 g(lobal)vim 进入文件，命令行模式下执行 :[range]global[!]/{pattern}/{command} 也即： :[range]g/pattern/command [range] 指定文本范围,默认为整个文档 pattern 在范围 range 内的行如果匹配 pattern，则执行 command ! 表示取反，也就是不匹配的行，也可以使用 vglobal command 默认是打印文本 ","date":"2021-01-19","objectID":"/vim_tips/:1:0","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#全局命令-global"},{"categories":["Software"],"content":" Tip.1 范围匹配20 行到 200 行之间，每一行下插入空行 :20,200g/^/pu _ ","date":"2021-01-19","objectID":"/vim_tips/:1:1","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip1-范围匹配"},{"categories":["Software"],"content":" Tip.2 删除包含字符 pattern 的所有行 :g/pattern/d ","date":"2021-01-19","objectID":"/vim_tips/:1:2","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip2-删除包含字符-pattern-的所有行"},{"categories":["Software"],"content":" Tip.3 删除空白行 :g/^$/d ","date":"2021-01-19","objectID":"/vim_tips/:1:3","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip3-删除空白行"},{"categories":["Software"],"content":" Tip.4 删除不匹配的行 :g!/pattern/d :v/pattern/d ","date":"2021-01-19","objectID":"/vim_tips/:1:4","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip4-删除不匹配的行"},{"categories":["Software"],"content":" Tip.5 删除大量匹配行Vim 在删除操作时，会先把要删除的内容放到寄存器中，假如没有指定寄存器，会默认放到一个未命名的寄存器中，对于要删除大量匹配行的行为，可能导致 Vim 花一些时间处理这些拷贝，避免花费不必要的时间可以指定一个 blackhole 寄存器 _ :g/pattern/d_ ","date":"2021-01-19","objectID":"/vim_tips/:1:5","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip5-删除大量匹配行"},{"categories":["Software"],"content":" Tip.6 移动匹配的行将所有匹配的行移动到文件的末尾 :g/pattern/m$ ","date":"2021-01-19","objectID":"/vim_tips/:1:6","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip6-移动匹配的行"},{"categories":["Software"],"content":" Tip.7 复制匹配的行将所有匹配的行复制到文件末尾 :g/pattern/t$ ","date":"2021-01-19","objectID":"/vim_tips/:1:7","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip7-复制匹配的行"},{"categories":["Software"],"content":" Tip.8 复制到 register aVim 每个字母都是一个寄存器，所以使用全局命令也可以将内容复制到某一个寄存器，比如 a qaq:g/pattern/y A qaq 清空寄存器 a，qa 开始记录命令到 a 寄存器，q 停止记录 y A 将匹配的行 A (append) 追加到寄存器 a 中 存放到 a 寄存器之后就可以使用 “ap 来粘贴使用或者其他操作了 ","date":"2021-01-19","objectID":"/vim_tips/:1:8","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip8-复制到-register-a"},{"categories":["Software"],"content":" Tip.9 反转文件中的每一行 :g/^/m0 :g 命令一行行匹配，匹配第一行时将第一行 m0 放到文件顶部，第二行放到文件顶部，当跑完一遍之后整个文件的每一行就反转了 ","date":"2021-01-19","objectID":"/vim_tips/:1:9","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip9-反转文件中的每一行"},{"categories":["Software"],"content":" Tip.10 在匹配行后添加文字使用 s 命令可以实现，同样使用全局 g 命令也可以实现同样的效果 :g/pattern/s/$/mytext To be continued… ","date":"2021-01-19","objectID":"/vim_tips/:1:10","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#tip10-在匹配行后添加文字"},{"categories":["Software"],"content":" 参考 [1] Vim 全局命令 g ","date":"2021-01-19","objectID":"/vim_tips/:2:0","series":null,"tags":["Software","Vim","Trick"],"title":"Vim 小技巧","uri":"/vim_tips/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 功率控制 ","date":"2020-11-02","objectID":"/lte_power_control/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#"},{"categories":["WirelessCommunication"],"content":" 功率控制针对上行和下行信号的发送特点，物理层定义了相应的功率控制的机制。 对于上行信号，终端的功率控制在节能和抑制用户间干扰的方面具有重要意义，所以，相应的采用闭环功率控制的方式，控制终端在上行单载波符号上的发送功率。 对于下行信号，基站合理的功率分配和相互之间的协调能够抑制小区间的干扰，提高组网的系统性能，所以，相应的采用开环功率分配的机制，控制基站在下行各个子载波上的发送功率。 ","date":"2020-11-02","objectID":"/lte_power_control/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#功率控制"},{"categories":["WirelessCommunication"],"content":" 上行功率控制上行功率控制以各个终端为单位，控制终端到达基站的接收功率，使得不同距离的用户都能以适当的功率到达基站，避免远近效应。物理层上行采用部分功率控制（Fractional Power Control）结合闭环功率控制的方案，对无线链路的大尺度衰落和小尺度衰落进行补偿。 在子帧 i，终端 PUSCH 信道的发射功率可以表示为： $P_{PUSCH}(i)=min\\{P_{CMAX},10log_{10}(M_{PUSCH}(i))+P_{O_{PUSCH}} (j)+α(j)·PL+∆TF (i)+f(i)\\}[dBm]$ 其中： $P_{CMAX}$ 表示终端的最大发射功率 $M_{PUSCH}(i)$ 表示 PUSCH 的传输带宽（RB 数目） $PL$ 是终端测量得到的下行大尺度损耗 $∆TF (i)$ 表示由调制编码方式和数据类型（控制信息或者数据信息）所确定的功率偏移量。 $KS＝1.25$ 或者 0，表示是否针对不同的调制方式进行补偿 $f(i)$ 是由终端闭环功率控制所形成的调整值。它的数值根据 PDCCH Format0/3/3A 上的功率控制命令进行调整 物理层有两种闭环功率控制类型： 累计型（accumulation） 绝对值型（absolute） 与上行数据调度相类似 在 FDD 情况下，PDCCH Format 0/3/3A 功率控制命令和相应的 PUSCH 发送之间的时延是 4ms 在 TDD 情况下，该时延的数值根据上下行时间分配比例的不同而有所不同 与功率控制相结合，可以通过小区之间交换干扰情况的信息，进行协调的调度，抑制小区间的同频干扰，小区间 X2 接口上交互的信息有两种： 过载指示（Overload Indicator，OI）：指示本小区每个 PRB 上受到的上行干扰情况。相邻小区通过交换该消息了解对方目前的负载情况，并进行适当的调整 干扰指示（High Interference Indicator，HII）：指示本小区每个 PRB 对于上行干扰的敏感度情况。该消息反映了本小区的调度安排，相邻小区通过交换该信息了解对方将要采用的调度安排，并进行适当的调整以实现协调的调度。 ","date":"2020-11-02","objectID":"/lte_power_control/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#上行功率控制"},{"categories":["WirelessCommunication"],"content":" 下行功率分配下行功率分配以每个 RE 为单位，控制基站在各个时刻各个子载波上的发射功率。 下行功率分配中包括了 提高导频信号的发射功率（即 power boosting） 用户调度相结合实现小区间干扰抑制的相关机制 小区公用导频信号（CRS）在频率上和时间上采用恒定的发射功率，基站通过高层信令指示该发射功率的数值，在接收端，终端通过测量该信号的平均接收功率并与信令指示的发射功率进行比较，获得大尺度衰落的数值。 下行共享信道 PDSCH 的发射功率表示为 PDSCH RE 与 CRS RE 的功率比值，即 $ρA$ 和 $ρB$ 。其中 $ρA$ 表示时隙内不带有 CRS 导频信号的 OFDM 符号上（例如：2 天线、Normal CP 的情况下，时隙内的第 1、2、3、5、6 个 OFDM 符号），PDSCH RE 与 CRS RE 的功率比值 $ρB$ 表示时隙内带有 CRS 导频信号的 OFDM 符号上（例如：2 天线、Normal CP 的情况下，时隙内第 0、4 个 OFDM 符号），PDSCH RE 与 CRS RE 的功率比值 提高 CRS 导频信号的发射功率（即 power boosting）小区通过高层信令指示 $\\frac{ρB}{ρA}$，通过不同的比值可以设置导频信号在基站总功率中不同的开销比例，由此实现了不同程度地提高 CRS 导频信号发射功率的功能。 例：以发射天线数目等于 2 为例，支持 4 种不同的小区配置 $\\frac{ρB}{ρA}=[\\frac{5}{4},1,\\frac{3}{4},\\frac{1}{2}]$，分别对应于导频占总功率开销为$[\\frac{1}{6}，\\frac{1}{3}，\\frac{3}{6}，\\frac{2}{3}]$的情况。 下图表示了 $\\frac{ρB}{ρA} =1$ 和 $\\frac{ρB}{ρA} =\\frac{1}{2}$ 时天线端口 #0 的信号功率情况，分别实现了导频信号以 3dB 和 9dB 高于同一 OFDM 符号中数据元素的发送功率。 两种情况下天线端口 #0 的信号功率 用户功率分配和小区间干扰协调在指示 $\\frac{ρB}{ρA}$ 的基础上，通过高层参数 $P_A$ 可以确定 $ρA$ 的具体数值，得到基站下行针对用户的 PDSCH 发射功率，该信息将用于 16QAM、64QAM 和 MU-MIMO 等需要幅度信息的检测过程。$P_A$ 和 $ρA$ 的数值关系是 $ρ_A =δ_{power-offset} +P_A$ 其中 $δ_{power-offset}$ 用于 MU-MIMO 的场景，例如 $δ_{power-offset} =−3dB$ 可以表示功率平均分配给两个用户的情况。 ","date":"2020-11-02","objectID":"/lte_power_control/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#下行功率分配"},{"categories":["WirelessCommunication"],"content":" 下行功率分配下行功率分配以每个 RE 为单位，控制基站在各个时刻各个子载波上的发射功率。 下行功率分配中包括了 提高导频信号的发射功率（即 power boosting） 用户调度相结合实现小区间干扰抑制的相关机制 小区公用导频信号（CRS）在频率上和时间上采用恒定的发射功率，基站通过高层信令指示该发射功率的数值，在接收端，终端通过测量该信号的平均接收功率并与信令指示的发射功率进行比较，获得大尺度衰落的数值。 下行共享信道 PDSCH 的发射功率表示为 PDSCH RE 与 CRS RE 的功率比值，即 $ρA$ 和 $ρB$ 。其中 $ρA$ 表示时隙内不带有 CRS 导频信号的 OFDM 符号上（例如：2 天线、Normal CP 的情况下，时隙内的第 1、2、3、5、6 个 OFDM 符号），PDSCH RE 与 CRS RE 的功率比值 $ρB$ 表示时隙内带有 CRS 导频信号的 OFDM 符号上（例如：2 天线、Normal CP 的情况下，时隙内第 0、4 个 OFDM 符号），PDSCH RE 与 CRS RE 的功率比值 提高 CRS 导频信号的发射功率（即 power boosting）小区通过高层信令指示 $\\frac{ρB}{ρA}$，通过不同的比值可以设置导频信号在基站总功率中不同的开销比例，由此实现了不同程度地提高 CRS 导频信号发射功率的功能。 例：以发射天线数目等于 2 为例，支持 4 种不同的小区配置 $\\frac{ρB}{ρA}=[\\frac{5}{4},1,\\frac{3}{4},\\frac{1}{2}]$，分别对应于导频占总功率开销为$[\\frac{1}{6}，\\frac{1}{3}，\\frac{3}{6}，\\frac{2}{3}]$的情况。 下图表示了 $\\frac{ρB}{ρA} =1$ 和 $\\frac{ρB}{ρA} =\\frac{1}{2}$ 时天线端口 #0 的信号功率情况，分别实现了导频信号以 3dB 和 9dB 高于同一 OFDM 符号中数据元素的发送功率。 两种情况下天线端口 #0 的信号功率 用户功率分配和小区间干扰协调在指示 $\\frac{ρB}{ρA}$ 的基础上，通过高层参数 $P_A$ 可以确定 $ρA$ 的具体数值，得到基站下行针对用户的 PDSCH 发射功率，该信息将用于 16QAM、64QAM 和 MU-MIMO 等需要幅度信息的检测过程。$P_A$ 和 $ρA$ 的数值关系是 $ρ_A =δ_{power-offset} +P_A$ 其中 $δ_{power-offset}$ 用于 MU-MIMO 的场景，例如 $δ_{power-offset} =−3dB$ 可以表示功率平均分配给两个用户的情况。 ","date":"2020-11-02","objectID":"/lte_power_control/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#提高-crs-导频信号的发射功率即-power-boosting"},{"categories":["WirelessCommunication"],"content":" 下行功率分配下行功率分配以每个 RE 为单位，控制基站在各个时刻各个子载波上的发射功率。 下行功率分配中包括了 提高导频信号的发射功率（即 power boosting） 用户调度相结合实现小区间干扰抑制的相关机制 小区公用导频信号（CRS）在频率上和时间上采用恒定的发射功率，基站通过高层信令指示该发射功率的数值，在接收端，终端通过测量该信号的平均接收功率并与信令指示的发射功率进行比较，获得大尺度衰落的数值。 下行共享信道 PDSCH 的发射功率表示为 PDSCH RE 与 CRS RE 的功率比值，即 $ρA$ 和 $ρB$ 。其中 $ρA$ 表示时隙内不带有 CRS 导频信号的 OFDM 符号上（例如：2 天线、Normal CP 的情况下，时隙内的第 1、2、3、5、6 个 OFDM 符号），PDSCH RE 与 CRS RE 的功率比值 $ρB$ 表示时隙内带有 CRS 导频信号的 OFDM 符号上（例如：2 天线、Normal CP 的情况下，时隙内第 0、4 个 OFDM 符号），PDSCH RE 与 CRS RE 的功率比值 提高 CRS 导频信号的发射功率（即 power boosting）小区通过高层信令指示 $\\frac{ρB}{ρA}$，通过不同的比值可以设置导频信号在基站总功率中不同的开销比例，由此实现了不同程度地提高 CRS 导频信号发射功率的功能。 例：以发射天线数目等于 2 为例，支持 4 种不同的小区配置 $\\frac{ρB}{ρA}=[\\frac{5}{4},1,\\frac{3}{4},\\frac{1}{2}]$，分别对应于导频占总功率开销为$[\\frac{1}{6}，\\frac{1}{3}，\\frac{3}{6}，\\frac{2}{3}]$的情况。 下图表示了 $\\frac{ρB}{ρA} =1$ 和 $\\frac{ρB}{ρA} =\\frac{1}{2}$ 时天线端口 #0 的信号功率情况，分别实现了导频信号以 3dB 和 9dB 高于同一 OFDM 符号中数据元素的发送功率。 两种情况下天线端口 #0 的信号功率 用户功率分配和小区间干扰协调在指示 $\\frac{ρB}{ρA}$ 的基础上，通过高层参数 $P_A$ 可以确定 $ρA$ 的具体数值，得到基站下行针对用户的 PDSCH 发射功率，该信息将用于 16QAM、64QAM 和 MU-MIMO 等需要幅度信息的检测过程。$P_A$ 和 $ρA$ 的数值关系是 $ρ_A =δ_{power-offset} +P_A$ 其中 $δ_{power-offset}$ 用于 MU-MIMO 的场景，例如 $δ_{power-offset} =−3dB$ 可以表示功率平均分配给两个用户的情况。 ","date":"2020-11-02","objectID":"/lte_power_control/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#用户功率分配和小区间干扰协调"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-11-02","objectID":"/lte_power_control/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：功率控制","uri":"/lte_power_control/#参考"},{"categories":["Network"],"content":" UDP 说来简单，但是一些细节你都清楚吗？ 注：本文系全文转载，原文信息如下： 作者：贺嘉 链接：https://zhuanlan.zhihu.com/p/25622691 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:0:0","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#"},{"categories":["Network"],"content":" UDP 疑难杂症","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:0","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-疑难杂症"},{"categories":["Network"],"content":" UDP 的传输方式：面向报文面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么 UDP 的报文大小由哪些影响因素呢？UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？ UDP 报文大小的影响因素，主要有以下 3 个 UDP 协议本身，UDP 协议中有 16 位的 UDP 报文长度，那么 UDP 报文长度不能超过 $2^{16}=65536$. 以太网(Ethernet)数据帧的长度，数据链路层的 MTU(最大传输单元)。 socket 的 UDP 发送缓存区大小 UDP 数据包最大长度根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 $2^{16}$ 的个字节。由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的最大理论长度是 $2^{16} - 1 - 8 - 20 = 65507$ 字节。 如果发送的数据包超过 65507 字节，send 或 sendto 函数会错误码 1(Operation not permitted，Message too long)，当然啦，一个数据包能否发送 65507 字节，还和 UDP 发送缓冲区大小（Linux 下 UDP 发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关，如果发送缓冲区小于 65507 字节，在发送一个数据包为 65507 字节的时候，send 或 sendto 函数会错误码 1(Operation not permitted，No buffer space available)。 UDP 数据包理想长度理论上 UDP 报文最大长度是 65507 字节，实际上发送这么大的数据包效果最好吗？ 我们知道 UDP 是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们最好能控制 UDP 包在下层协议的传输过程中不要被切割。 相信大家都知道 MTU 这个概念。MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet II 帧的结构 DMAC+SMAC+Type+Data+CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小 64 字节，最大不能超过 1518 字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是 1518 字节，除去以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes 那么剩下承载上层协议的地方也就是 Data 域最大就只能有 1500 字节这个值我们就把它称之为 MTU。 在下层数据链路层最大传输单元是 1500 字节的情况下，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是 1500 字节 – IP 头(20 字节) – UDP 头(8 字节) = 1472 字节。不过鉴于 Internet 上的标准 MTU 值为 576 字节，所以建议在进行 Internet 的 UDP 编程时，最好将 UDP 的数据长度控制在 (576-8-20)548 字节以内。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-的传输方式面向报文"},{"categories":["Network"],"content":" UDP 的传输方式：面向报文面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么 UDP 的报文大小由哪些影响因素呢？UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？ UDP 报文大小的影响因素，主要有以下 3 个 UDP 协议本身，UDP 协议中有 16 位的 UDP 报文长度，那么 UDP 报文长度不能超过 $2^{16}=65536$. 以太网(Ethernet)数据帧的长度，数据链路层的 MTU(最大传输单元)。 socket 的 UDP 发送缓存区大小 UDP 数据包最大长度根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 $2^{16}$ 的个字节。由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的最大理论长度是 $2^{16} - 1 - 8 - 20 = 65507$ 字节。 如果发送的数据包超过 65507 字节，send 或 sendto 函数会错误码 1(Operation not permitted，Message too long)，当然啦，一个数据包能否发送 65507 字节，还和 UDP 发送缓冲区大小（Linux 下 UDP 发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关，如果发送缓冲区小于 65507 字节，在发送一个数据包为 65507 字节的时候，send 或 sendto 函数会错误码 1(Operation not permitted，No buffer space available)。 UDP 数据包理想长度理论上 UDP 报文最大长度是 65507 字节，实际上发送这么大的数据包效果最好吗？ 我们知道 UDP 是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们最好能控制 UDP 包在下层协议的传输过程中不要被切割。 相信大家都知道 MTU 这个概念。MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet II 帧的结构 DMAC+SMAC+Type+Data+CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小 64 字节，最大不能超过 1518 字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是 1518 字节，除去以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes 那么剩下承载上层协议的地方也就是 Data 域最大就只能有 1500 字节这个值我们就把它称之为 MTU。 在下层数据链路层最大传输单元是 1500 字节的情况下，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是 1500 字节 – IP 头(20 字节) – UDP 头(8 字节) = 1472 字节。不过鉴于 Internet 上的标准 MTU 值为 576 字节，所以建议在进行 Internet 的 UDP 编程时，最好将 UDP 的数据长度控制在 (576-8-20)548 字节以内。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-报文大小的影响因素主要有以下-3-个"},{"categories":["Network"],"content":" UDP 的传输方式：面向报文面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么 UDP 的报文大小由哪些影响因素呢？UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？ UDP 报文大小的影响因素，主要有以下 3 个 UDP 协议本身，UDP 协议中有 16 位的 UDP 报文长度，那么 UDP 报文长度不能超过 $2^{16}=65536$. 以太网(Ethernet)数据帧的长度，数据链路层的 MTU(最大传输单元)。 socket 的 UDP 发送缓存区大小 UDP 数据包最大长度根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 $2^{16}$ 的个字节。由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的最大理论长度是 $2^{16} - 1 - 8 - 20 = 65507$ 字节。 如果发送的数据包超过 65507 字节，send 或 sendto 函数会错误码 1(Operation not permitted，Message too long)，当然啦，一个数据包能否发送 65507 字节，还和 UDP 发送缓冲区大小（Linux 下 UDP 发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关，如果发送缓冲区小于 65507 字节，在发送一个数据包为 65507 字节的时候，send 或 sendto 函数会错误码 1(Operation not permitted，No buffer space available)。 UDP 数据包理想长度理论上 UDP 报文最大长度是 65507 字节，实际上发送这么大的数据包效果最好吗？ 我们知道 UDP 是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们最好能控制 UDP 包在下层协议的传输过程中不要被切割。 相信大家都知道 MTU 这个概念。MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet II 帧的结构 DMAC+SMAC+Type+Data+CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小 64 字节，最大不能超过 1518 字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是 1518 字节，除去以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes 那么剩下承载上层协议的地方也就是 Data 域最大就只能有 1500 字节这个值我们就把它称之为 MTU。 在下层数据链路层最大传输单元是 1500 字节的情况下，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是 1500 字节 – IP 头(20 字节) – UDP 头(8 字节) = 1472 字节。不过鉴于 Internet 上的标准 MTU 值为 576 字节，所以建议在进行 Internet 的 UDP 编程时，最好将 UDP 的数据长度控制在 (576-8-20)548 字节以内。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-数据包最大长度"},{"categories":["Network"],"content":" UDP 的传输方式：面向报文面向报文的传输方式决定了 UDP 的数据发送方式是一份一份的，也就是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。那么 UDP 的报文大小由哪些影响因素呢？UDP 数据包的理论长度是多少，合适的 UDP 数据包应该是多少呢？ UDP 报文大小的影响因素，主要有以下 3 个 UDP 协议本身，UDP 协议中有 16 位的 UDP 报文长度，那么 UDP 报文长度不能超过 $2^{16}=65536$. 以太网(Ethernet)数据帧的长度，数据链路层的 MTU(最大传输单元)。 socket 的 UDP 发送缓存区大小 UDP 数据包最大长度根据 UDP 协议，从 UDP 数据包的包头可以看出，UDP 的最大包长度是 $2^{16}$ 的个字节。由于 UDP 包头占 8 个字节，而在 IP 层进行封装后的 IP 包头占去 20 字节，所以这个是 UDP 数据包的最大理论长度是 $2^{16} - 1 - 8 - 20 = 65507$ 字节。 如果发送的数据包超过 65507 字节，send 或 sendto 函数会错误码 1(Operation not permitted，Message too long)，当然啦，一个数据包能否发送 65507 字节，还和 UDP 发送缓冲区大小（Linux 下 UDP 发送缓冲区大小为：cat /proc/sys/net/core/wmem_default）相关，如果发送缓冲区小于 65507 字节，在发送一个数据包为 65507 字节的时候，send 或 sendto 函数会错误码 1(Operation not permitted，No buffer space available)。 UDP 数据包理想长度理论上 UDP 报文最大长度是 65507 字节，实际上发送这么大的数据包效果最好吗？ 我们知道 UDP 是不可靠的传输协议，为了减少 UDP 包丢失的风险，我们最好能控制 UDP 包在下层协议的传输过程中不要被切割。 相信大家都知道 MTU 这个概念。MTU 最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，Ethernet II 帧的结构 DMAC+SMAC+Type+Data+CRC 由于以太网传输电气方面的限制，每个以太网帧都有最小的大小 64 字节，最大不能超过 1518 字节，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。由于以太网 EthernetII 最大的数据帧是 1518 字节，除去以太网帧的帧头（DMAC 目的 MAC 地址 48bit=6Bytes+SMAC 源 MAC 地址 48bit=6Bytes+Type 域 2bytes）14Bytes 和帧尾 CRC 校验部分 4Bytes 那么剩下承载上层协议的地方也就是 Data 域最大就只能有 1500 字节这个值我们就把它称之为 MTU。 在下层数据链路层最大传输单元是 1500 字节的情况下，要想 IP 层不分包，那么 UDP 数据包的最大大小应该是 1500 字节 – IP 头(20 字节) – UDP 头(8 字节) = 1472 字节。不过鉴于 Internet 上的标准 MTU 值为 576 字节，所以建议在进行 Internet 的 UDP 编程时，最好将 UDP 的数据长度控制在 (576-8-20)548 字节以内。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-数据包理想长度"},{"categories":["Network"],"content":" UDP 数据包的发送和接收问题 UDP 的通信有界性在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。 UDP 数据包的无序性和非可靠性Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。 UDP 数据包的接收Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？ 由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。 在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？ 由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。 UDP 包分片问题如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？ 根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:2","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-数据包的发送和接收问题"},{"categories":["Network"],"content":" UDP 数据包的发送和接收问题 UDP 的通信有界性在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。 UDP 数据包的无序性和非可靠性Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。 UDP 数据包的接收Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？ 由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。 在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？ 由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。 UDP 包分片问题如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？ 根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:2","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-的通信有界性"},{"categories":["Network"],"content":" UDP 数据包的发送和接收问题 UDP 的通信有界性在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。 UDP 数据包的无序性和非可靠性Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。 UDP 数据包的接收Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？ 由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。 在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？ 由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。 UDP 包分片问题如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？ 根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:2","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-数据包的无序性和非可靠性"},{"categories":["Network"],"content":" UDP 数据包的发送和接收问题 UDP 的通信有界性在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。 UDP 数据包的无序性和非可靠性Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。 UDP 数据包的接收Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？ 由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。 在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？ 由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。 UDP 包分片问题如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？ 根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:2","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-数据包的接收"},{"categories":["Network"],"content":" UDP 数据包的发送和接收问题 UDP 的通信有界性在阻塞模式下，UDP 的通信是以数据包作为界限的，即使 Server 端的缓冲区再大也要按照 Client 发包的次数来多次接收数据包，Server 只能一次一次的接收，Client 发送多少次，Server 就需接收多少次，即客户端分几次发送过来，服务端就必须按几次接收。 UDP 数据包的无序性和非可靠性Client 依次发送 1、2、3 三个 UDP 数据包，Server 端先后调用 3 次接收函数，可能会依次收到 3、2、1 次序的数据包，收包可能是 1、2、3 的任意排列组合，也可能丢失一个或多个数据包。 UDP 数据包的接收Client 发送两次 UDP 数据，第一次 500 字节，第二次 300 字节，Server 端阻塞模式下接包，第一次 recvfrom( 1000 )，收到是 1000，还是 500，还是 300，还是其他？ 由于 UDP 通信的有界性，接收到只能是 500 或 300，又由于 UDP 的无序性和非可靠性，接收到可能是 300，也可能是 500，也可能一直阻塞在 recvfrom 调用上，直到超时返回(也就是什么也收不到)。 在假定数据包是不丢失并且是按照发送顺序按序到达的情况下，Server 端阻塞模式下接包，先后三次调用：recvfrom( 200)，recvfrom( 1000)，recvfrom( 1000)，接收情况如何呢？ 由于 UDP 通信的有界性，第一次 recvfrom( 200)将接收第一个 500 字节的数据包，但是因为用户空间 buf 只有 200 字节，于是只会返回前面 200 字节，剩下 300 字节将丢弃。第二次 recvfrom( 1000)将返回 300 字节，第三次 recvfrom( 1000)将会阻塞。 UDP 包分片问题如果 MTU 是 1500，Client 发送一个 8000 字节大小的 UDP 包，那么 Server 端阻塞模式下接包，在不丢包的情况下，recvfrom(9000)是收到 1500，还是 8000。如果某个 IP 分片丢失了，recvfrom(9000)，又返回什么呢？ 根据 UDP 通信的有界性，在 buf 足够大的情况下，接收到的一定是一个完整的数据包，UDP 数据在下层的分片和组片问题由 IP 层来处理，提交到 UDP 传输层一定是一个完整的 UDP 包，那么 recvfrom(9000)将返回 8000。如果某个 IP 分片丢失，UDP 里有个 CRC 检验，如果包不完整就会丢弃，也不会通知是否接收成功，所以 UDP 是不可靠的传输协议，那么 recvfrom(9000)将阻塞。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:2","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-包分片问题"},{"categories":["Network"],"content":" UDP 丢包问题在不考虑 UDP 下层 IP 层的分片丢失，CRC 检验包不完整的情况下，造成 UDP 丢包的因素有哪些呢？ UDP socket 缓冲区满造成的 UDP 丢包 通过 cat /proc/sys/net/core/rmem_default 和 cat /proc/sys/net/core/rmem_max 可以查看 socket 缓冲区的缺省值和最大值。如果 socket 缓冲区满了，应用程序没来得及处理在缓冲区中的 UDP 包，那么后续来的 UDP 包会被内核丢弃，造成丢包。在 socket 缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解 UDP 丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。 UDP socket 缓冲区过小造成的 UDP 丢包 如果 Client 发送的 UDP 报文很大，而 socket 缓冲区过小无法容下该 UDP 报文，那么该报文就会丢失。 ARP 缓存过期导致 UDP 丢包 ARP 的缓存时间约 10 分钟，APR 缓存列表没有对方的 MAC 地址或缓存过期的时候，会发送 ARP 请求获取 MAC 地址，在没有获取到 MAC 地址之前，用户发送出去的 UDP 数据包会被内核缓存到 arp_queue 这个队列中，默认最多缓存 3 个包，多余的 UDP 包会被丢弃。 被丢弃的 UDP 包可以从 /proc/net/stat/arp_cache 的最后一列的 unresolved_discards 看到。当然我们可以通过 echo 30 \u003e /proc/sys/net/ipv4/neigh/eth1/unres_qlen 来增大可以缓存的 UDP 包。UDP 的丢包信息可以从 cat /proc/net/udp 的最后一列 drops 中得到，而倒数第四列 inode 是丢失 UDP 数据包的 socket 的全局唯一的虚拟 i 节点号，可以通过这个 inode 号结合 lsof(lsof -P -n | grep 25445445)来查到具体的进程。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:3","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-丢包问题"},{"categories":["Network"],"content":" UDP 冗余传输在外网通信链路不稳定的情况下，有什么办法可以降低 UDP 的丢包率呢？ 一个简单的办法来采用冗余传输的方式。一般采用较多的是延时双发，双发指的是将原本单发的前后连续的两个包合并成一个大包发送，这样发送的数据量是原来的两倍。这种方式提高丢包率的原理比较简单，例如本例的冗余发包方式，在偶数包全丢的情况下，依然能够还原出完整的数据，也就是在这种情况下，50% 的丢包率，依然能够达到 100% 的数据接收。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:1:4","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-冗余传输"},{"categories":["Network"],"content":" UDP 真的比 TCP 要高效吗相信很多同学都认为 UDP 无连接，无需重传和处理确认，UDP 比较高效。然而 UDP 在大多情况下并不一定比 TCP 高效，TCP 发展至今天，为了适应各种复杂的网络环境，其算法已经非常丰富，协议本身经过了很多优化，如果能够合理配置 TCP 的各种参数选项，那么在多数的网络环境下 TCP 是要比 UDP 更高效的。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:2:0","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-真的比-tcp-要高效吗"},{"categories":["Network"],"content":" 影响 UDP 高效因素 无法智能利用空闲带宽导致资源利用率低一个简单的事实是 UDP 并不会受到 MTU 的影响，MTU 只会影响下层的 IP 分片，对此 UDP 一无所知。在极端情况下，UDP 每次都是发小包，包是 MTU 的几百分之一，这样就造成 UDP 包的有效数据占比较小(UDP 头的封装成本)；或者，UDP 每次都是发巨大的 UDP 包，包大小 MTU 的几百倍，这样会造成下层 IP 层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个 UDP 包的无效。由于网络情况是动态变化的，UDP 无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而 TCP 有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP 的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。 无法动态调整发包由于 UDP 没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP 并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，UDP 的无秩序性和自私性，一个疯狂的 UDP 程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。 改进 UDP 的成本较高可能有同学想到针对 UDP 的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，UDP 编程可是比 TCP 要难不少的，考虑到改造成本，为什么不直接用 TCP 呢？当然可以拿开源的一些实现来抄一下(例如：libjingle)，或者拥抱一下 Google 的 QUIC 协议，然而，这些都需要不少成本的。 上面说了这么多，难道真的不该用 UDP 了吗？其实也不是的，在某些场景下，我们还是必须 UDP 才行的。那么 UDP 的较为合适的使用场景是哪些呢？ ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:2:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#影响-udp-高效因素"},{"categories":["Network"],"content":" 影响 UDP 高效因素 无法智能利用空闲带宽导致资源利用率低一个简单的事实是 UDP 并不会受到 MTU 的影响，MTU 只会影响下层的 IP 分片，对此 UDP 一无所知。在极端情况下，UDP 每次都是发小包，包是 MTU 的几百分之一，这样就造成 UDP 包的有效数据占比较小(UDP 头的封装成本)；或者，UDP 每次都是发巨大的 UDP 包，包大小 MTU 的几百倍，这样会造成下层 IP 层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个 UDP 包的无效。由于网络情况是动态变化的，UDP 无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而 TCP 有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP 的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。 无法动态调整发包由于 UDP 没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP 并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，UDP 的无秩序性和自私性，一个疯狂的 UDP 程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。 改进 UDP 的成本较高可能有同学想到针对 UDP 的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，UDP 编程可是比 TCP 要难不少的，考虑到改造成本，为什么不直接用 TCP 呢？当然可以拿开源的一些实现来抄一下(例如：libjingle)，或者拥抱一下 Google 的 QUIC 协议，然而，这些都需要不少成本的。 上面说了这么多，难道真的不该用 UDP 了吗？其实也不是的，在某些场景下，我们还是必须 UDP 才行的。那么 UDP 的较为合适的使用场景是哪些呢？ ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:2:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#无法智能利用空闲带宽导致资源利用率低"},{"categories":["Network"],"content":" 影响 UDP 高效因素 无法智能利用空闲带宽导致资源利用率低一个简单的事实是 UDP 并不会受到 MTU 的影响，MTU 只会影响下层的 IP 分片，对此 UDP 一无所知。在极端情况下，UDP 每次都是发小包，包是 MTU 的几百分之一，这样就造成 UDP 包的有效数据占比较小(UDP 头的封装成本)；或者，UDP 每次都是发巨大的 UDP 包，包大小 MTU 的几百倍，这样会造成下层 IP 层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个 UDP 包的无效。由于网络情况是动态变化的，UDP 无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而 TCP 有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP 的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。 无法动态调整发包由于 UDP 没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP 并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，UDP 的无秩序性和自私性，一个疯狂的 UDP 程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。 改进 UDP 的成本较高可能有同学想到针对 UDP 的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，UDP 编程可是比 TCP 要难不少的，考虑到改造成本，为什么不直接用 TCP 呢？当然可以拿开源的一些实现来抄一下(例如：libjingle)，或者拥抱一下 Google 的 QUIC 协议，然而，这些都需要不少成本的。 上面说了这么多，难道真的不该用 UDP 了吗？其实也不是的，在某些场景下，我们还是必须 UDP 才行的。那么 UDP 的较为合适的使用场景是哪些呢？ ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:2:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#无法动态调整发包"},{"categories":["Network"],"content":" 影响 UDP 高效因素 无法智能利用空闲带宽导致资源利用率低一个简单的事实是 UDP 并不会受到 MTU 的影响，MTU 只会影响下层的 IP 分片，对此 UDP 一无所知。在极端情况下，UDP 每次都是发小包，包是 MTU 的几百分之一，这样就造成 UDP 包的有效数据占比较小(UDP 头的封装成本)；或者，UDP 每次都是发巨大的 UDP 包，包大小 MTU 的几百倍，这样会造成下层 IP 层的大量分片，大量分片的情况下，其中某个分片丢失了，就会导致整个 UDP 包的无效。由于网络情况是动态变化的，UDP 无法根据变化进行调整，发包过大或过小，从而导致带宽利用率低下，有效吞吐量较低。而 TCP 有一套智能算法，当发现数据必须积攒的时候，就说明此时不积攒也不行，TCP 的复杂算法会在延迟和吞吐量之间达到一个很好的平衡。 无法动态调整发包由于 UDP 没有确认机制，没有流量控制和拥塞控制，这样在网络出现拥塞或通信两端处理能力不匹配的时候，UDP 并不会进行调整发送速率，从而导致大量丢包。在丢包的时候，不合理的简单重传策略会导致重传风暴，进一步加剧网络的拥塞，从而导致丢包率雪上加霜。更加严重的是，UDP 的无秩序性和自私性，一个疯狂的 UDP 程序可能会导致这个网络的拥塞，挤压其他程序的流量带宽，导致所有业务质量都下降。 改进 UDP 的成本较高可能有同学想到针对 UDP 的一些缺点，在用户态做些调整改进，添加上简单的重传和动态发包大小优化。然而，这样的改进并比简单的，UDP 编程可是比 TCP 要难不少的，考虑到改造成本，为什么不直接用 TCP 呢？当然可以拿开源的一些实现来抄一下(例如：libjingle)，或者拥抱一下 Google 的 QUIC 协议，然而，这些都需要不少成本的。 上面说了这么多，难道真的不该用 UDP 了吗？其实也不是的，在某些场景下，我们还是必须 UDP 才行的。那么 UDP 的较为合适的使用场景是哪些呢？ ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:2:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#改进-udp-的成本较高"},{"categories":["Network"],"content":" UDP 的使用场合","date":"2020-10-26","objectID":"/udp_intractable_diseases/:3:0","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-的使用场合"},{"categories":["Network"],"content":" 通信实时性和持续性在分组交换通信当中，协议栈的成本主要表现在以下两方面： 封装带来的空间复杂度 缓存带来的时间复杂度 以上两者是对立影响的，如果想减少封装消耗，那么就必须缓存用户数据到一定量在一次性封装发送出去，这样每个协议包的有效载荷将达到最大化，这无疑是节省了带宽空间，带宽利用率较高，但是延时增大了。如果想降低延时，那么就需要将用户数据立马封装发出去，这样显然会造成消耗更多的协议头等消耗，浪费带宽空间。 因此，我们进行协议选择的时候，需要重点考虑一下空间复杂度和时间复杂度间的平衡。 通信的持续性对两者的影响比较大，根据通信的持续性有两种通信类型： 短连接通信 长连接通信 对于短连接通信，一方面如果业务只需要发一两个包并且对丢包有一定的容忍度，同时业务自己有简单的轮询或重复机制，那么采用 UDP 会较为好些。在这样的场景下，如果用 TCP，仅仅握手就需要 3 个包，这样显然有点不划算，一个典型的例子是 DNS 查询。另一方面，如果业务实时性要求非常高，并且不能忍受重传，那么首先就是 UDP 了或者只能用 UDP 了，例如 NTP 协议，重传 NTP 消息纯属添乱(为什么呢？重传一个过期的时间包过来，还不如发一个新的 UDP 包同步新的时间过来)。如果 NTP 协议采用 TCP，撇开握手消耗较多数据包交互的问题，由于 TCP 受 Nagel 算法等影响，用户数据会在一定情况下会被内核缓存延后发送出去，这样时间同步就会出现比较大的偏差，协议将不可用。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:3:1","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#通信实时性和持续性"},{"categories":["Network"],"content":" 多点通信对于一些多点通信的场景，如果采用有连接的 TCP，那么就需要和多个通信节点建立其双向连接，然后有时在 NAT 环境下，两个通信节点建立其直接的 TCP 连接不是一个容易的事情，在涉及 NAT 穿越的时候，UDP 协议的无连接性使得穿透成功率更高(原因详见：由于 UDP 的无连接性，那么其完全可以向一个组播地址发送数据或者轮转地向多个目的地持续发送相同的数据，从而更为容易实现多点通信。) 一个典型的场景是多人实时音视频通信，这种场景下实时性要求比较高，可以容忍一定的丢包率。比如：对于音频，对端连续发送 p1、p2、p3 三个包，另一端收到了 p1 和 p3，在没收到 p2 的保持 p1 的最后一个音（也是为什么有时候网络丢包就会听到嗞嗞嗞嗞嗞嗞…或者卟卟卟卟卟卟卟卟…重音的原因），等到到 p3 就接着播 p3 了，不需要也不能补帧，一补就越来越大的延时。对于这样的场景就比较合适用 UDP 了，如果采用 TCP，那么在出现丢包的时候，就可能会出现比较大的延时。 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:3:2","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#多点通信"},{"categories":["Network"],"content":" UDP 使用原则通常情况下，UDP 的使用范围是较小的，在以下的场景下，使用 UDP 才是明智的： 实时性要求很高，并且几乎不能容忍重传。例子：NTP 协议，实时音视频通信，多人动作类游戏中人物动作、位置 TCP 实在不方便实现多点传输的情况 需要进行 NAT 穿越 对网络状态很熟悉，确保 UDP 网络中没有氓流行为，例如疯狂抢带宽 熟悉 UDP 编程 ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:3:3","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#udp-使用原则"},{"categories":["Network"],"content":" 参考 [1] Netfilter,iptables/OpenVPN/TCP guard ","date":"2020-10-26","objectID":"/udp_intractable_diseases/:4:0","series":null,"tags":["UDP"],"title":"告知你不为人知的 UDP —— 疑难杂症和使用","uri":"/udp_intractable_diseases/#参考"},{"categories":["Network"],"content":" 本文主要讲解 DNS 的报文结构 ","date":"2020-10-20","objectID":"/dns/:0:0","series":null,"tags":["DNS"],"title":"DNS 报文详解","uri":"/dns/#"},{"categories":["Network"],"content":" DNS 简介简单来说 DNS 负责将我们熟知的域名翻译成 IP 地址，其相关定义由 RFC 1034 和 RFC 1035 给出。 为了更加的扩展性，DNS 由大量的服务器分层次进行组织的，大致来说分为：根 DNS 服务器、顶域名（TLD）DNS 服务器和权威 DNS 服务器。他们的层次结构如下图所示： DNS 的层次结构 关于 DNS 的工作过程及相关信息参见深入浅出 DNS 解析，本文负责补充 DNS 报文结构。 ","date":"2020-10-20","objectID":"/dns/:1:0","series":null,"tags":["DNS"],"title":"DNS 报文详解","uri":"/dns/#dns-简介"},{"categories":["Network"],"content":" DNS 报文结构 DNS 的报文结构 前 12 个字节为首部，包含： 标识符（2 字节），用于标识请求及其响应报文，区分不同的查询 标志（2 字节），其中： QR（1bit）：查询/响应标志，0 为查询，1 为响应 opcode（4bit）：0 表示标准查询，1 表示反向查询，2 表示服务器状态请求，[3,15]为保留值 AA（1bit）：表示授权回答，这个比特位在应答的时候才有意义，指出给出应答的服务器是查询域名的授权解析服务器 TC（1bit）：表示可截断的，用来指出报文比允许的长度还要长，导致被截断; RD（1bit）：表示期望递归，这个比特位被请求设置，应答的时候使用的相同的值返回。如果设置了 RD，就建议域名服务器进行递归解析，递归查询的支持是可选的; RA（1bit）：表示可用递归，这个比特位在应答中设置或取消，用来代表服务器是否支持递归查询; rcode（4bit）：表示返回码 0 : 没有错误 1 : 报文格式错误(Format error) - 服务器不能理解请求的报文 2 : 服务器失败(Server failure) - 因为服务器的原因导致没办法处理这个请求 3 : 名字错误(Name Error) - 只有对授权域名解析服务器有意义，指出解析的域名不存在 4 : 没有实现(Not Implemented) - 域名服务器不支持查询类型 5 : 拒绝(Refused) - 服务器由于设置的策略拒绝给出应答.比如，服务器不希望对某些请求者给出应答，或者服务器不希望进行某些操作（比如区域传送 zone transfer） [6,15] : 保留值，暂未使用。 数量字段（8 字节）：每个区域 2 字节 Questions 表示查询问题区域节的数量 Answers 表示回答区域的数量 Authoritative namesversers 表示授权区域的数量 Additional recoreds 表示附加区域的数量 问题（Questions）部分包括： 查询的域名 8bit 为单位，长度不受限 查询的协议类型 16bit 查询的类 16bit 回答（Answers）/权威（Authoritys）/附加（Additionals）部分格式相同： NAME 资源记录包含的域名. TYPE 表示 DNS 协议的类型. CLASS 表示 RDATA 的类. TTL 4 字节无符号整数表示资源记录可以缓存的时间。0 代表只能被传输，但是不能被缓存。 RDLENGTH 2 个字节无符号整数表示 RDATA 的长度 RDATA 不定长字符串来表示记录，格式根 TYPE 和 CLASS 有关。比如，TYPE 是 A，CLASS 是 IN，那么 RDATA 就是一个 4 个字节的 ARPA 网络地址。 ","date":"2020-10-20","objectID":"/dns/:1:1","series":null,"tags":["DNS"],"title":"DNS 报文详解","uri":"/dns/#dns-报文结构"},{"categories":["Network"],"content":" RRs 说明每个 DNS 响应报文包含一条或者多条资源记录（resource records ，RRs），资源记录包含下列字段的 4 元组： （Name，Value，Type，TTL） 其中 TTL 表示生存时间，决定了资源记录应该从缓存中删除的时间。 如果是 Type=A，Name 为主机名，Value 是对应的 IP 地址（如 bar.foo.com，xxx.xxx.xxx.xxx，A） 如果是 Type=NS，Name 为一个域（如 foo.com），Value 是知道如何获取该域中的主机 IP 地址的权威 DNS 服务器的主机名（如 foo.com，dns.foo.com，NS） 如果是 Type=CNAME，Value 是别名为 Name 的主机对应的规范主机名。（如 foo.com，relay1.bar.foo.com，CNAME） 如果是 Type=MX，Value 是别名为 Name 的邮件服务器对应的规范主机名。（如 foo.com，mail.bar.foo.com，MX） ","date":"2020-10-20","objectID":"/dns/:2:0","series":null,"tags":["DNS"],"title":"DNS 报文详解","uri":"/dns/#rrs-说明"},{"categories":["Network"],"content":" 实例这里我们使用 WireShark 抓包实际看看，启动 WireShark 时可以设置捕获过滤器为： udp port 53 这样我们只抓取通过 UDP 53 端口的 DNS 请求，此外如果需要仅仅显示特定的 DNS 查询，还可以进一步应用显示过滤器，例如这里我们仅查看www.techkoala.top的查询记录，则显示过滤器设置为： dns.qry.name==www.techkoala.top 16 进制表示 WireShark 中 DNS 请求报文及其结构 可以看出 标识为：0x0000cd13 这是一个请求报文，仅在 Questions 部分有值 标志部分各个字段的值 查询部分各个字段的值 同时 WireShark 还贴心的告诉我们，响应报文的在总抓取包的编号为 10，方便我们快速找到请求报文对应的响应报文。 16进制表示 WireShark 中 DNS 响应报文及其结构 标志部分各个字段的值 查询部分各个字段的值 ","date":"2020-10-20","objectID":"/dns/:3:0","series":null,"tags":["DNS"],"title":"DNS 报文详解","uri":"/dns/#实例"},{"categories":["Network"],"content":" 参考 [1] Computer Networking A Top-Down Approach [2] DNS 请求报文详解 ","date":"2020-10-20","objectID":"/dns/:4:0","series":null,"tags":["DNS"],"title":"DNS 报文详解","uri":"/dns/#参考"},{"categories":["Network"],"content":" ARP 以及 RARP 如何工作？ ","date":"2020-10-16","objectID":"/arp_rarp/:0:0","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#"},{"categories":["Network"],"content":" 为什么要有 MAC 地址？在说明 ARP 以及 RARP 之前，有必要首先说一下 MAC 地址的必要性。 引用《Computer Networking A Top-Down Approach》中的描述： KEEPING THE LAYERS INDEPENDENT There are several reasons why hosts and router interfaces have MAC addresses in addition to network-layer addresses. First, LANs are designed for arbitrary network-layer protocols, not just for IP and the Internet. If adapters were assigned IP addresses rather than “neutral” MAC addresses, then adapters would not easily be able to support other network-layer protocols (for example, IPX or DECnet). Second, if adapters were to use network-layer addresses instead of MAC addresses, the network-layer address would have to be stored in the adapter RAM and reconfigured every time the adapter was moved (or powered up). Another option is to not use any addresses in the adapters and have each adapter pass the data (typically, an IP datagram) of each frame it receives up the protocol stack. The network layer could then check for a matching network-layer address. One problem with this option is that the host would be interrupted by every frame sent on the LAN, including by frames that were destined for other hosts on the same broadcast LAN. In summary, in order for the layers to be largely independent building blocks in a network architecture, different layers need to have their own addressing scheme. We have now seen three types of addresses: host names for the application layer, IP addresses for the network layer, and MAC addresses for the link layer. 简单来说： 局域网不仅仅为 IP 和因特网设计，MAC 地址的“中立性”为各种网络层协议（比如 IPX 或者 DECnet)提供了灵活的施展空间 网络层地址往往是动态的，每次更换网络或者重启都需要对适配器进行重新配置 如果取消 MAC 地址，让适配器把收到的每帧都往上层传递，就会带来一个问题：主机会去处理局域网中的每个帧，即使这个帧不属于自己，这就带来了不必要的消耗。 ","date":"2020-10-16","objectID":"/arp_rarp/:1:0","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#为什么要有-mac-地址"},{"categories":["Network"],"content":" ARP一句话概括 ARP（Address Resolution Protocol，地址解析协议）的目的就是：负责将网络层地址（最常见的就是 IP 地址）解析为/映射到链路层地址（MAC 地址）。 ","date":"2020-10-16","objectID":"/arp_rarp/:2:0","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#arp"},{"categories":["Network"],"content":" 报文结构 ARP 包结构 一般我们讨论以太网中的 ARP 报文时候，ARP 数据会被封装在以太网报文中，其中： 以太网报文： 目标以太网地址：目标 MAC 地址，FF:FF:FF:FF:FF:FF （二进制全 1）为广播地址 源以太网地址：发送方 MAC 地址 帧类型：以太类型，ARP 为 0x0806 ARP 报文数据： 硬件类型：如以太网（0x0001）、分组无线网 协议类型：如网际协议(IP)（0x0800）、IPv6（0x86DD） 硬件地址长度：每种硬件地址的字节长度，一般为 6（以太网） 协议地址长度：每种协议地址的字节长度，一般为 4（IPv4） 操作码 OP：1 为 ARP 请求，2 为 ARP 应答，3 为 RARP 请求，4 为 RARP 应答 源硬件地址：n 个字节，n 由硬件地址长度得到，一般为发送方 MAC 地址 源协议地址：m 个字节，m 由协议地址长度得到，一般为发送方 IP 地址 目标硬件地址：n 个字节，n 由硬件地址长度得到，一般为目标 MAC 地址 目标协议地址：m 个字节，m 由协议地址长度得到，一般为目标 IP 地址 ","date":"2020-10-16","objectID":"/arp_rarp/:2:1","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#报文结构"},{"categories":["Network"],"content":" 工作原理 每台主机都会在自己的 ARP 缓冲区 (ARP Cache)中建立一个 ARP 列表，表示 IP 地址和 MAC 地址的对应关系。 当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址，如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包（即将目的硬件地址设置为全 1），查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。 网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 单播响应数据包，告诉对方自己是它需要查找的 MAC 地址； 源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。 ","date":"2020-10-16","objectID":"/arp_rarp/:2:2","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#工作原理"},{"categories":["Network"],"content":" 代理 ARP代理 ARP 是指当 ARP 目标不在同一网段时，网关会拦截该 ARP 请求，然后把自己的 MAC 地址回复给请求者： 代理 ARP 但是需要网关需要满足： 开启代理 ARP 功能 有目标的路由信息 假如不存在网关但使用代理 ARP，则情况如下： 代理 ARP 存在网关的情况下，使用正常 ARP，则情况如下： 代理 ARP 总结而言： 没有网关（采用代理 ARP）时：跨网段访问谁，就问谁的 MAC 有网关（采用正常 ARP）时：跨网段访问谁，都问网关的 MAC 无论使用哪种 ARP，跨网段通信时，发送方请求得到的目标 MAC 地址都是网关 MAC ","date":"2020-10-16","objectID":"/arp_rarp/:2:3","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#代理-arp"},{"categories":["Network"],"content":" RARPRARP（Reverse Address Resolution Protocol，逆地址解析协议），顾名思义，用于将 MAC 地址映射为网络层地址（例如 IP 地址），用于给 MAC 地址分配 IP 地址（通常在需要远程启动(类似无盘工作站)的系统中使用）。其因为较限于 IP 地址的运用以及其他的一些缺点，因此渐为更新的 BOOTP 或 DHCP 所取代。 RARP 使用与 ARP 相同的报头结构，只是其中的操作码有所区别，见上文。 ","date":"2020-10-16","objectID":"/arp_rarp/:3:0","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#rarp"},{"categories":["Network"],"content":" 工作原理 发送主机发送一个本地的 RARP 广播，在此广播包中，声明自己的 MAC 地址并且请求任何收到此请求的 RARP 服务器分配一个 IP 地址； 本地网段上的 RARP 服务器收到此请求后，检查其 RARP 列表，查找该 MAC 地址对应的 IP 地址； 如果存在，RARP 服务器就给源主机发送一个响应数据包并将此 IP 地址提供给对方主机使用； 如果不存在，RARP 服务器对此不做任何的响应； 源主机收到从 RARP 服务器的响应信息，就利用得到的 IP 地址进行通讯；如果一直没有收到 RARP 服务器的响应信息，表示初始化失败。 ","date":"2020-10-16","objectID":"/arp_rarp/:3:1","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#工作原理-1"},{"categories":["Network"],"content":" 安全问题","date":"2020-10-16","objectID":"/arp_rarp/:4:0","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#安全问题"},{"categories":["Network"],"content":" ARP 欺骗源主机通过 ARP 协议在局域网内发送广播请求包，按照 ARP 协议的设想应该是对应主机回复，但如果攻击者进行回复，源主机依然会选择相信。这是由 ARP 协议的不验证引起的，它不验证对方是否是所声称 IP 地址的主机。同时，由于 ARP 协议是一种无状态协议，既不验证应答者的身份，也不判断是否发送过 ARP 请求，当收到一条 ARP 应答报文时，它就会更新 ARP 应答缓存表。因此，攻击者甚至可以主动向源主机发送 ARP 响应包，迫使源主机更新其 ARP 缓存表。 对此，一个简单的方法是使用静态绑定地址，但是此方法维护起来较为麻烦。 ","date":"2020-10-16","objectID":"/arp_rarp/:4:1","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#arp-欺骗"},{"categories":["Network"],"content":" 参考 [1] Computer Networking A Top-Down Approach [2] 地址解析协议 [3] 逆地址解析协议 [4] 网络协议补完计划–ARP 协议和 RARP 协议 ","date":"2020-10-16","objectID":"/arp_rarp/:5:0","series":null,"tags":["ARP","RARP"],"title":"ARP \u0026 RARP 详解","uri":"/arp_rarp/#参考"},{"categories":["Network"],"content":" 安装 AdguardHome 运行几天后，可怜的剩余空间被日志耗尽，不得不对 OpenWRT overlay 进行扩容，本文对此进行了记录 ","date":"2020-10-09","objectID":"/openwrt_resize/:0:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#"},{"categories":["Network"],"content":" 什么是 overlayOpenWRT 一般使用的文件系统是 SquashFS ，这个文件系统的特点就是：只读。 一个只读的文件系统要怎么做到保存设置和安装软件的呢？这里就是使用 /overlay 的分区，overlay 顾名思义就是覆盖在上面一层的意思。虽然原来的文件不能修改，但把修改的部分放在 overlay 分区上，然后映射到原来的位置，读取的时候就可以读到修改过的文件了。 为什么要用这么复杂的方法呢？ OpenWRT 当然也可以使用 EXT4 文件系统，但使用 SquashFS + overlay 的方式有一定的优点。 SquashFS 是经过压缩的，在路由器这种小型 ROM 的设备可以放下更多的东西。 OpenWRT 的恢复出厂设置也要依赖于这个方式。在你重置的时候，它只需要把 overlay 分区清空就可以了，一切都回到了刚刷进去的样子。 如果是 EXT4 文件系统，就只能够备份每个修改的文件，在恢复出厂设置的时候复制回来，十分复杂。 当然，SquashFS + overlay 也有它的缺点： 修改文件的时候会占用更多的空间。首先你不能够删除文件，因为删除文件实际上是在 overlay 分区中写入一个删除的标识，反而占用更多的空间。 另外在修改文件的时候相当于增加了一份文件的副本，占用了双份的空间。 overlay 示意图 ","date":"2020-10-09","objectID":"/openwrt_resize/:1:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#什么是-overlay"},{"categories":["Network"],"content":" 创建新分区首先，需要创建一个新的分区，这里使用的是 cfdisk 如果此前没有安装，首先使用下列命令进行安装： opkg update opkg install cfdisk 然后输入 cfdisk 打开磁盘管理界面： 磁盘界面 这里可以看到，目前一共有两个已有分区，现在新建一个分区： 选中 Free Space，再选中 New，输入需要的大小，比如 5G。 接着选择 primary 选择主分区 选择 Write 写入更改 输入 yes，完成新分区的创建 确认 ","date":"2020-10-09","objectID":"/openwrt_resize/:2:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#创建新分区"},{"categories":["Network"],"content":" 格式化分区使用命令： mkfs.ext4 /dev/sda3 格式化分区 格式化分区 ","date":"2020-10-09","objectID":"/openwrt_resize/:3:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#格式化分区"},{"categories":["Network"],"content":" 挂载新分区使用命令： mount /dev/sda3 /mnt/sda3 挂载分区 ","date":"2020-10-09","objectID":"/openwrt_resize/:4:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#挂载新分区"},{"categories":["Network"],"content":" 转移到新分区然后将原来 upper 层中的数据复制到新的分区中： cp -r /overlay/* /mnt/sda3 ","date":"2020-10-09","objectID":"/openwrt_resize/:5:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#转移到新分区"},{"categories":["Network"],"content":" Web 界面配置修改进入 OpenWRT Web 界面的挂载点对配置进行修改： Web 界面 在挂载点下方点击添加，然后如下配置： 挂载点配置 ","date":"2020-10-09","objectID":"/openwrt_resize/:6:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#web-界面配置修改"},{"categories":["Network"],"content":" 完成到这一步，只需要重启 OpenWRT 即可成功扩容。 重启后到 系统 -\u003e 软件包 可以看到变大后的空间容量。 ","date":"2020-10-09","objectID":"/openwrt_resize/:7:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#完成"},{"categories":["Network"],"content":" 自动挂载分区默认会在 OpenWRT 重启后会自动挂载，如果遇到没有挂载的情况，需要编辑 /etc/rc.local vim /etc/rc.local 在 exit 0 之前加入一行 mount /dev/sda3 /overlay 即可。 ","date":"2020-10-09","objectID":"/openwrt_resize/:8:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#自动挂载"},{"categories":["Network"],"content":" 参考 [1] OpenWrt 下把 SD 卡挂载到 /overlay ，扩大软件空间 [2] 软路由 LEDE 折腾 overlay 分区扩容之路 [3] ESXI 下 OpenWrt 扩容 Overlay,增加安装插件空间 ","date":"2020-10-09","objectID":"/openwrt_resize/:9:0","series":null,"tags":["OpenWRT","Router"],"title":"OpenWRT overlay 空间扩容","uri":"/openwrt_resize/#参考"},{"categories":["Network"],"content":" 本文介绍如何单独编译 OpenWRT 的 ipk 插件 说明 必须首先完整编译一次固件才能单独编译 ipk 当需要单独更新 OpenWRT 某个插件或者需要增加安装某个插件的时候，可以单独编译对应的 ipk 插件进行安装，而不必编译整个系统。 ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:0","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#"},{"categories":["Network"],"content":" 下载源码使用 git clone 对应的源码插件到下面的文件夹中 ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:1","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#下载源码"},{"categories":["Network"],"content":" 存放路径 ~/lede/package ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:2","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#存放路径"},{"categories":["Network"],"content":" 配置 make menuconfig 然后进入对应的子菜单中找到对应插件按 表示选中插件，但不编译进固件。 ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:3","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#配置"},{"categories":["Network"],"content":" 编译 make package/xxxxx/compile V=99 xxxxx 就是你需要单独编译的程序。 ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:4","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#编译"},{"categories":["Network"],"content":" ipk 生成路径 ~/lede/bin/packages/x86_64/xxxx ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:5","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#ipk-生成路径"},{"categories":["Network"],"content":" 上传 ipk 至路由器 scp xxxxxxx.ipk root@192.168.1.1:/tmp ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:6","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#上传-ipk-至路由器"},{"categories":["Network"],"content":" 安装 opkg install /tmp/xxxxx.ipk ","date":"2020-10-09","objectID":"/openwrt_compile_single_ipk/:0:7","series":null,"tags":["OpenWRT","Router"],"title":"单独编译 OpenWRT ipk 插件","uri":"/openwrt_compile_single_ipk/#安装"},{"categories":["WirelessCommunication"],"content":" 为什么说 5G 将是一个彻底的失败？ 注：本文系全文转载，原文信息如下： 作者：杨学志 链接：https://www.txrjy.com/thread-1061715-1-1.html 来源：通信人家园 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:0:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#"},{"categories":["WirelessCommunication"],"content":" 无线通信产业发展史无线通信产业已经发展了四代，目前正处于 5G 产业化前夕，是当下到一个最热的话题，5G 如何发展，前景如何，是各个方面包括学术界、产业界、投资界以及政府都非常关心的。另外，中国已经启动 6G 研究的消息也见诸报端，未来无线通信产业如何发展，是不是会继续有 6、7、8、9G，也引起了大家的关切。为了回答这些问题，我们首先简单地回顾一下无线通信产业发展的历史。 无线通信产业是由需求和技术两个轮子驱动前进的。 早在 1947 年，贝尔实验室的科学家就提出了蜂窝通信的概念，其中的核心技术是频率复用和切换。基于这一概念，贝尔实验室于 1978 年研制出先进移动电话系统（Advanced Mobile Phone Service，AMPS），这就是第一代移动通信系统。AMPS 是一个模拟通信系统，采用频分多址（FDMA）的复用技术，主要技术手段是滤波器，容易受噪声的干扰，语音质量较差。 随着集成电路技术的发展，第二代移动通信系统采用了数字技术，并采用 TDMA 和信道编码技术，使得通信系统向宽带化发展，语音质量得到了较大的改善。其中欧洲制定的 GSM 系统非常成功，至今仍在广泛使用。 20 世纪 90 年代互联网蓬勃发展，顺应这一时代要求，产业界制订了 3G 标准用以实现移动互联网。3G 采用了高通公司开发的 CDMA 技术。CDMA 一度被认为是一个神奇的技术，高通公司宣称 CDMA 的频谱效率可以达到 AMPS 的 18 倍，但是实践表明这个观点太过于浮夸了，CDMA 存在自干扰问题，其频谱效率只比 GSM 高 10%左右，并且 3G 的主流标准 WCDMA 的系统设计过于复杂，导致部署成本比较高，所以一直无法替代 GSM 系统。 第四代移动通信采用了 OFDM 技术，从根本上克服了 CDMA 的技术缺陷，并且简化了系统设计，成就了一代成功的移动通信系统。OFDM 如何克服 CDMA 的缺陷，具体可以参考我的《通信之道-从微积分到 5G》。 如果我们稍微总结一下，可以发现，1G 发掘出了移动通信的巨大需求，但是采用了比较落后的技术体制，因此长不大。2G 进行了数字化革命，从而获得巨大成功。3G 是为了新出现的移动互联网需求而诞生，但是在技术上走了弯路，全球的 3G 业务都不是太成功；而 4G 回归了正确的技术路线，目前 4G 业务蓬勃发展。 随着 4G 的成功商用，按照无线通信十年一代的发展规律，产业界开始了 5G 的研发。按照业界目前的一般口径，5G 在 2020 年左右开始规模商用。中国政府已经为 5G 分配了 500MHz 的频谱，三大运营商也已经在多个城市开展了商用实验，商用前的准备工作正在紧锣密鼓地进行。 很多人认为 5G 牌照会在年内（2019）发放。 对于 5G 的讨论，也要从技术和需求两条线来讨论。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:1:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#无线通信产业发展史"},{"categories":["WirelessCommunication"],"content":" 无线通信技术体制无线通信产业基本上可以用“端管云”三个字进行概括。 端就是终端，包括电脑， PAD，手机等。云就是存储在网络上的内容，如新浪、百度、淘宝的数据中心，而管就是连接终端和云之间的这条通道。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:2:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#无线通信技术体制"},{"categories":["WirelessCommunication"],"content":" 端管云这条管道可以分为两段。一段是终端到基站（或者路由器），这段是无线通信，也叫空中接口；另一段是基站到云，是有线通信。云都是挂在因特网上的，因此因特网是这条管道当中必经之路。移动通信有核心网，基站首先挂在核心网上，再连接到因特网。核心网主要是起运营支撑作用，比如身份的识别，计费等等。而另一个体系是大家都熟悉的 WiFi，没有核心网，路由器是直接戳到因特网的。这就构成了两大生态体系，也就是传说中的 CT 和 IT，它们之间的合作与竞争将贯穿无线通信产业的走向。 在无线通信产业当中，空中接口这一段的产值，包括终端和基站，占绝大部分。如果做一个类比，通信网络可以类比人体的循环系统或这神经系统。骨干网的部分可以类比中枢神经或者主动脉，虽然容量很大，但是只有几条。骨干网络的销售额不大，但是占据战略制高点；而空中接口部分相当于神经末梢或者毛细血管，数量庞大，占据无线通信产业的主要市场份额。 有线网络现在都光纤化了。光纤的发明是基于高锟的理论，他因此获得诺贝尔奖。光纤的容量大，成本低，彻底改变了人类通信的面貌。最早的光纤线路的速率只有 45Mbps，后来以令人乍舌的速度发展，目前一根光纤已经可以达到 1Tbps。而光纤要比同等长度面条便宜，这是真正的高科技。早期光纤只用于骨干线路（比如北京和上海之间），随着成本的降低，目前光纤已经入户了。 由于光纤的存在，有线网络的主要工作在于怎么组织和利用光纤的容量，如 IPV6，SDN 等等，基本上是逻辑性的工作，总体来说是比较简单的。 空中接口部分就比有线网困难多了。在有线通信当中，信号在一个精心制造的介质里面传播，无论是铜线还是光纤，信号质量非常好，随便搞搞就能达到很高的速率。而无线信号的传播环境就恶劣得多得多。无线电波在传播过程中衰减很快，还受到建筑物、山体、树木的阻挡，很多时候需要经过反射或者穿透障碍物才能达到接收机。并且，无线电波不是规规矩矩地沿着规定的路线走，会走到不希望的地方，造成对他人的干扰。但是无线通信有一个好处，就是摆脱了线的束缚，可以拿着手机随便走，这种便利性是有线通信所无法比拟的。所以尽管挑战很大，无数的研究者前仆后继，攻克无线通信当中的道道难关。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:2:1","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#端管云"},{"categories":["WirelessCommunication"],"content":" 网络分层协议刚才说的这些事，背后是网络的分层结构。最底下的一层叫物理层，其他的可以和合并起来叫高层。物理层是处理物理信号的，比如电或者是光，就是如何把信息转换成可以用来传输的电信号或者光信号。物理层解决的是通信能力的问题，或者是带宽的问题。有了这么多的带宽之后，怎么组织和利用是高层要做的事。 这个和邮政系统非常类似。物理层相当于运送信件或者包裹的方式，可以是马车，汽车、轮船、飞机，这提供了运送的能力。但是寄信的时候，我们要在信封上写通信地址，要跑到邮局交给柜台，后然分拣打包装车，到了目的地后要有邮递员送到收信地址，这些都是高层做的事情。 所以大家能看出来，通信网络的核心技术在物理层。当然高层也必不可少，但相对来说可以变化的空间不大。 如果说我们的邮政系统比以前先进，主要不是体现在邮局的布置上，而是运输方式的改进，以前是马车，现在改飞机了。虽说邮局也进步了，比如装了玻璃柜台，或者信件实现了机器分拣，但不是主要的因素。 光纤是现代通信网络的最重要的基石，就是物理层技术。高层技术当中大家最熟悉的是 IP 协议。IPV4 获得广泛应用后，虽说存在一些问题，试图通过 IPV6 去解决。但是 IPV6 经过二三十年也没有取代 IPV4，就是因为高层技术相对简单，改进的空间不大。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:2:2","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#网络分层协议"},{"categories":["WirelessCommunication"],"content":" 无线通信技术演进同样，空中接口的核心技术也在物理层，每一代移动通信是由这些核心技术所定义的。这些核心技术，也就是《通信原理》课程里面的知识。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:3:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#无线通信技术演进"},{"categories":["WirelessCommunication"],"content":" 3G 核心技术空中接口的核心技术可以分为 5 个大类，分别是调制、编码、多址、组网和多天线。比核心技术更基础的是基础理论，包括电磁理论和信息论。 大家都知道，高通公司开发了 CDMA 技术，并且成为 3G 三大标准（ WCDMA，CDMA2000 和 TD-SCDMA）的核心技术，从而一跃成为芯片业巨头。 上图所示的是 WCDMA 的核心技术。高通的贡献主要在多址和组网两个领域。 虽然普遍认为高通开发了 CDMA 技术，但是 CDMA 并不是高通发明的，发明人是好莱坞艳星海蒂.拉玛。CDMA 技术的标准接收机叫 Rake 接收机，也于 1950 年代由贝尔实验室发明。实际上由于当时普遍认为 CDMA 的保密性好，一直应用于军事通信。而高通解决的是 CDMA 的民用问题，这在当时是普遍不被看好的。 高通解决 CDMA 民用有三招，分别是功率控制（Power Ctrl）、同频复用（UFR）和软切换。功率控制解决远近效应，同频复用提升频谱效率，软切换解决切换连续性。这构成了高通 CDMA 的技术体系。 这里只简要介绍一下，技术人员可以参考我的书《通信之道》。因为 UFR 并不是专利，所以高通其实在 CDMA 上就两个核心专利，其中软切换专利获得美国专利局的授权还载入了高通发展史。 3G 在编码领域的主要进展是采用了 Turbo 码，这是法国电信所资助的教授发明的，是通信发展史上的里程碑，因为它首次充分逼近了香农在 1948 年所提出的信道容量。 在多天线领域，Alamouti 编码应用到了广播信道多编码。因为广播信道在整个业务当中的比重并不大，所以这个编码的作用相对重要性低一些。但是这个编码是多天线技术领域的里程碑，有非常大的影响力。 调制是最基础的通信技术，没有之一。因为基础，所以稳定，一直到现在的 5G 都没有太大的变化。 可以看出，高通在 3G 的多址和组网两个方面拥有核心技术。当然，在把核心技术工程化的过程当中也建立起由几千个专利组成的专利组合。凭着这些专利和芯片的联合运作，收取了大量的高通税。 其实从现在的眼光看，Turbo 码和 Alamouti 码是更重要的核心技术。但这两个核心技术在法国电信和 ATT 这样的大公司里面，没有进行商业化运作的机制，只是收了一些专利费，没有形成象高通这么大的商业。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:3:1","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#3g-核心技术"},{"categories":["WirelessCommunication"],"content":" 4G 核心技术到了 4G 之后，CDMA 技术被 OFDM 技术所取代。主要的原因是 CDMA 存在自干扰的问题。高通的功率控制和软切换试图去解决这个问题，但采取的方法是在 CDMA 缺陷的基础上进行补救，但是怎么补也补不彻底。 而 OFDM 从根本上克服了 CDMA 自干扰的缺陷，使得频谱效率得到了很大的提高，那这些补救措施也就没必要了。 所以在 4G 时代，高通的技术体系被摧毁了。 采用 OFDM 技术带来了新的问题，解决这些问题导致了三个创新的出现，这就是我在华为提出的 sOFDM 和软频率复用（SFR）以及爱立信提出的 SC-FDMA 技术。 我在华为还提出了随机波束赋形（random beam forming）技术，解决了非常火热的循环延时分集（Cyclic Delay Diversity）的严重缺陷。 在调制和编码领域仍然采用了 3G 的方案。 可以看出，华为在 4G 的核心技术上已经取代了高通。但是很可惜，由于华为公司的跟随基因，无法发挥手上的专利核武的威力，还要向高通交钱，也只是向苹果收了点小钱。但是华为因此避免了专利核武打击，加上华为在产品上的优势，所以华为日子过得很好，在 4G 时代成为第一大设备制造商。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:3:2","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#4g-核心技术"},{"categories":["WirelessCommunication"],"content":" 5G 核心技术5G 标准已经制定完成了，盖棺定论后已经可以看得很清楚了。 首先调制这块还是没有变，太基础了，想变也变不动。 因为联想投票门的事情，编码这块的故事很多人都知道。相比于 3G/4G 采用的 Turbo 码，5G 采用了 LDPC 和 Polar 码。 这两个码都是鼎鼎大名，是 Turbo 码之后通信技术发展的里程碑性的技术。 但是由于 Turbo 码已经比较接近香农限，虽然这两个码更接近，但是对系统容量的提升已经不大，大概是 1 ～ 2%左右。 多址这块，对于 5G 三大场景之一的 eMBB 这块没有变，还是采用了 OFDM。其中爱立信提出的 SC-FDMA 从 4G 的必选项变成了可选项，这是因为它相对于 OFDMA 并没有什么技术优势。 多址这块 NOMA 有很大的热度，一度被公认为 5G 的必选技术。5G 标准的早期，几乎所有的厂家都支持这个方向。 但是经过我的论证，NOMA 比 OFDM 的增益严格为零，这是用信息论严格证明的。 所以 NOMA 既复杂又没增益，属于技术退步。 另外华为还推了 F-OFDM，与 sOFDM 正好相反。sOFDM 的思想是所有的带宽所有的环境都用统一的参数，从而获得规模经济效应。F-OFDM 强调对不同的环境采用不同参数从而更好的适应环境。 这种做法并没有什么增益，反而丢失了规模效应这个大西瓜，也属于技术退步。 组网方面没有听到什么消息，工作假设应该还是同频复用。SFR 和 CoMP 都是组网方案。SFR 非常简单，不需要标准化。CoMP 虽然一度被认为是更先进的技术，但经历了轰轰烈烈的标准工作和产品开发之后，已经是失败了。 多天线这块最响亮的就是 massive MIMO，号称可以成百倍地提升系统容量，从媒体上看几乎可以是 5G 的代名词。 MIMO 这个理论 1995 年提出，已经 23 年了。它所揭示的对容量的巨大提升致使它一直是学界和工业界的热点。但是这个技术一直到 4G 都不是很成功。这个技术有个特点，一演示就成功，一实用就趴窝。记得 20 年前我还是小白的时候，在电信展上就看到厂家演示空分复用，用相同的时频资源实现两个用户的同时通信，还互不干扰。在一个选择的场景下 MIMO 技术是很容易演示成功的，但是在复杂的实际环境中所涉及的问题的难度，是两个数量级的差别。当然 MIMO 是一个有潜力的领域，但是其实用化问题仍然没有解决。 MIMO 的问题还在于，虽然能够提高容量，但是要增加设备，有成本的。其实 MIMO 最朴素的应用就是古老的三扇区天线，一个全向小区分割成三个扇区，容量在理论上增加了三倍，这就是 MIMO 的原理，虽然说是古板了一点。所以粗暴一点，搞个 9 扇区，12 扇区，也就是 mMIMO 了，这个华为已经有产品了。这和是不是 5G 没关系。 综合来看，5G 相对于 4G 来说，几乎没有技术进步，在一些地方还退步了。比如说 NOMA，F-OFDM，还有为了保证短时延而采用的自包含结构。 还有，5G 采用了更高的频谱。在中国是 3.5GHz，还好一点。美国用了 28GHz。频率越高覆盖越小，这是无线通信的基本知识。所以同样的网络覆盖，比起 4G 的 2.6GHz，3.5GHz 的投资要高出 50%（我也是看来的，看起来合理），而 28GHz 实现覆盖就是开玩笑了，花 5 倍的银子也是正常的。 所以从技术角度看，5G 比 4G 没有进步，成本会更高。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:3:3","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#5g-核心技术"},{"categories":["WirelessCommunication"],"content":" 5G 需求5G 的需求，大概可以用高速率、低延迟、大连接来概括。 大家知道，4G 设计当初的速率目标是 100Mbps，随着技术的演进，4G Cat 11 的速率已经达到 600Mbps。5G 进一步把速率目标提高到 1Gbps 以上。为了满足一些低延迟业务的需求，5G 要求空中接口的延迟时间为 1ms，而 4G 的这一指标为 30ms 左右。4G 主要是为移动互联网设计的，强调的是人与网络之间的高速连接，而同时连接到网络的终端的数量并不是一个需要特别考虑的问题。而在蓬勃发展的物联网时代，每一件物体都有可能有联网要求，因此连接数量会有数量级的增加，5G 需要具有支持海量连接的能力。 5G 最抓眼球的就是它的速率。看新闻经常是比光纤还快，一秒下一个大片，快到把人脸吹成骷髅，等等。 但是有什么样的业务需要这样的速率呢？ 虽然暂时想不出，但是有一个非常流行的观点是，先修好路，自然会有车。3G、4G 都是这样，微博、微信、抖音什么的，以前根本就想不到。等 4G 来了之后，这些应用也就有了。 很显然，这个观点首先在逻辑上就有很大的问题。修好了路没有车也很正常啊，你就没见过没人走的路吗？ 按照 3G、4G 的情况去推断 5G，这个也不靠谱。就像你已经活了 80 岁，不能按此推断你还能再活 80 岁。2G 和 3G 都处于带宽短缺的时代，所以形成了修好路必有车的错觉。然而到了 4G 之后，带宽已经不再短缺了。 还有一个流行的观点是，科技发展往往超出人的想象力，所以保守的预测往往是错误的。比如比尔盖茨当年说，计算机 640k 内存应该是够了。而现在已经是 640G 了，6 个数量级的增长。 必须认识到，通信和计算机有很大的不同。 计算机所涉及的所有零部件，CPU，内存，硬盘，都有一个共同的源泉就是半导体工艺。半导体集成度在近十年提高了 1000 倍，大家共同水涨船高。但是通信不一样。通信需要一个受体，以目前最广泛的 eMBB 为例，这个受体就是人。人是肉长的而不是沙子做的，它能够处理的最大信息速率，也就是带宽，是固定的，超过了人的带宽是没有意义的。 通俗一点说，我在 PAD 上看片，我一般看缺省的高清格式，尽管有超清格式，我一般不会主动选择。为啥？ 因为我的老花眼看不出二者的区别。当然眼睛好的人还是应该能分出来的。高清视频也就是 1 ～ 2Mbps 的速率，目前的 WiFi，4G 都远远地超出了我的需求。 当然，有人会反对。比如目前 4K/8K 视频很火热，有朋友跟我说，看了 4K 视频之后，其他的都没法看了。我天天看高清格式视频，倒是没这种感觉了。当然对于 60 寸的大电视，提高分辨率还是有必要的。但是电影院的屏幕，目前还只是 2K，我认为 4K/8K 更多的是心理上的。用户挑电视的时候会靠在跟前看屏幕上的一小块区域，一个像素一个像素地检查，4K/8K 当然要好。如果在正常观看距离上，比如 2 米，4K 和 2K 会有明显区别吗？我没试验过啊，有兴趣的朋友可以做一下双盲实验。 即使是 4K 视频，速率也只有 30Mbps，4G 支持也不费力啊，怎么会有 1Gbps 的需求呢？这就要说到虚拟现实 VR 了。 VR 要求有沉浸式的体验。啥叫沉浸式？在真实的场景当中，如果我们慢慢地转头，看到的景物也就连续地变化，这就是沉浸的意思。VR 要实现这种效果，不光要传给你正在看的东西，没看的东西也要传给你，转头的时候要现传新视角上的数据来不及，会出现卡顿，就不是沉浸式体验了。这样一来，数据量再增加 30 倍，差不多就到 1G 了。5G 的 1G 速率的需求就是这么来的。 VR 作为一种创新的视频形式，相信能够获得一定的应用。VR 的麻烦在于需要一个专门的头盔，哪怕是手机盒做的简易型的，都是不方便携带的。这么一来 VR 一般发生在室内，而且一般是专门用途的场景，比如房地产或者旅游景点的体验店什么的。这些业务一般不会走移动通信，更多的是 WiFi 或者专线。 总是有很多朋友寄希望于未来可能出现的未知业务。虽然具体的业务会层出不穷，我们确实无法预测，但是只要最终的受体是人，人感受信息的通道就是眼睛和耳朵，鼻子舌头皮肤还都用不上，人类进化出新的感觉器官最少也得是 100 万年以后的事情。人眼的带宽就确定了通信的最大速率，这是一个物理瓶颈，不管什么应用出现都是无法突破的。 从现实的情况看，WiFi 的速率总是领先移动网的，即使 WiFi 已经提供给我们 100M 的带宽了，但是我门最多应用的速率还是 1～2M，超出 10M 以上的应用非常少，也只有下载软件的时候有时会达到。所以其实 4G 的速率已经超出需求了，5G 的高速率完全是没必要的。 人的感官能力对时延同样是一个决定因素。 时延当然越短越好，没有人会不喜欢短时延，但是信息论的基本原理决定了短时延会造成高成本。信道编码依靠的是大数定律实现可靠通信，要达到信道容量，理论上需要无穷的时延。因此这个固有原理因素就决定了时延不能非常短。这里就不说其他的处理时延、排队时延和反馈时延了。非要实现低时延也有方法，就是把效率降低，用很高的信噪比去实现很低的速率。这个成本就太高了。任总一直在说，大速率、低时延的通信技术还没有实现。其实根本就不存在这样的技术。 要知道人的感官时延大概是 100 毫秒左右，所以 4G 几十毫秒的时延是比较合适的，1ms 的时延对人没有意义。所以，只要有人参与的应用，就不需要低时延。比如常用的微博微信，甚至是很多人认为需要低时延的手机游戏，在 WiFi 上不都玩得挺好吗。 自动驾驶是被广泛误解为需要低时延的应用。你可以经常看到有文章说，低时延使得刹车距离更短，从而更安全。但是这要基于一个假设，就是刹车指令是通过 5G 网络从远程控制中心传送给汽车的。 显然实际的解决方案不是这样。象刹车这种对时延和可靠性要求都非常高的指令，只能由车在本地产生，采用尽量短的回路。依靠网络传输的，是路线规划和路况信息这样的对可靠性和时延没有特殊要求的信息。Google 汽车已经跑了几百万公里了，并不需要一个低时延的网络。甚至没有网络的时候，汽车也应该能跑，这是起码的要求。 基于同样的原因，象无人工厂这些工业应用也无法通过 5G 网络实现。5G 是一个公共网络，对经济性的要求决定了它无法达到工业级的可靠性。不是说技术上做不到工业级的可靠性，而是能做到也不做，太贵了公众用不起。所有的工业应用必须用专线。远程手术也是同样的道理。 对于这个话题，你经常会看到一个很高大上的技术叫网络切片，意思是在 5G 网络上切出一个高可靠性的通道出来，用来满足工业应用。但是这实际是不可能做到的。一个系统的可靠性取决于最薄弱的一环。如果 5G 网络采用统一的硬件设施，如果不想多花钱，就已经决定了这是一个民用级别的可靠性，是不可能在软件上做点工作使之达到工业级的可靠性。就像特朗普车队，要清道、设岗，要有探路车、开道车、救护车、通信车、陆军一号这些硬东西，要花大把的银子。单靠在大街上挂几个标志是无法保证总统安全的。 虽然低时延高可靠性（uRLLC）是 5G 定义的三大场景之一，但是这与 5G 作为一个公共网络的基本特征相矛盾，是绝无可能实现的。 刚才所说的自动驾驶和无人工厂，属于物联网的例子。接下来我们聊聊普遍意义的物联网。 有句非常有名的话，叫做4G 改变生活，5G 改变社会，说的就是物联网。5G 使我们的社会从互联网发展到万物互联的社会。 虽然普遍认为目前处于物联网爆发的前夕，但是有个问题，物联网未必是移动通信的菜。 移动通信是怎么来的呢？起初就是人要打电话，要到处跑，不光在本地跑，还要出差，还要出国。这个特点要求移动需要统一标准，全球统一。所以要有个叫 3GPP 的组织，几百个公司的人一起制定这个标准，扯来扯去效率是很低的。还要搞个核心网去支持运营，运营商还要养着一大票的运维人员，这些特点就决定了移动通信会比较贵。 所以说，除非移动，不然没有必要用移动通信。 这样移动通信的客户群就很明确，一是人，二是车，另外还有野生动物。所以 eMBB，车联网，野外科学考察等等，是移动通信的正经业务。 但是大多数东西是不动的。 在 WiFi 已经普及的情况下，很大的一块业务会被 WiFi 分流，比如智能家居。并且 eMBB 是 2C 的，而物联网多数是 2B 的，象油田，电力公司这些大企业更倾向于自建网络，就不用向运营商交月租了。以 NB-IoT 为例，一个链接每年 20 块的资费对很多应用是很大的一个负担。这就有了象 Lora 这样的系统的生存空间，成本比 5G 低得多。 所以，从 5G 的三大需求看，高速率和低时延的需求都是不存在的，物联网只有小部分落入 5G 的范围。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:4:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#5g-需求"},{"categories":["WirelessCommunication"],"content":" 移动通信与 WiFi5G 与 WiFi 的关系是无法回避的问题，这其实是本文开始就提到了 CT 与 IT 两大生态体系的关系问题。 首先有一个每个人都能感觉到的事实，WiFi 承载了 80%的流量，我们却不会为它付一分钱，而会为只承载 20% 流量的 4G 付月租。这是为什么？ 在信息社会，手机是我们与社会连接的通道。当我们习惯了这种连接之后，丢失连接后就会感到恐慌。 很多人一有机会就查一下微信，微博，电邮，股票，彩票，生怕遗漏了重大机会，或者没能及时回复。 也就是说，随时随地与社会连接，是我们的刚需。 要满足这种刚需，需要一个广覆盖的网络，这正是移动通信的目标和功能。 在 WiFi 火热的时候，有些城市试图建设 WiFi 城市，用 WiFi 来实现覆盖，但是最终都失败了。 因为 WiFi 是由 IT 界设计的，生来就缺乏实现广覆盖的能力。这表现在技术方案上，就不在这里细说了。 后来 IT 界把 WiFi 升级到 WiMax，试图与 CT 竞争，但是 IT 界的基因还是导致了 WiMax 的失败，并且导致北电破产。 由于 WiFi 无法实现广覆盖，它被定义为固网的延伸，已经成功渗透到了多数的家庭、酒店和办公室， 目前 WiFi 的实测速率已经达到 300～400Mbps。 WiFi 提供的是特定地点的高速率通信。路由器很便宜，二百块钱一个，用户自己买一个回来自己就能搞定，想把这些路由器集中控制起来收月租显然是不可行的。 IT 与 CT 都试图入侵对方领地。早几年的 WiMax 就是 IT 入侵 CT 的一次失败的尝试。 这几年，也经常听到各种消息，一会儿是小扎，一会儿是马斯克，都要建全球免费 WiFi，周鸿祎说他掌管中国移动，就全免费。当然都没能成功。移动通信所要求的统一标准、广域覆盖，网归网优，客户管理，都决定了运营商是一个分层的官僚体系，与互联网基因格格不入。中国移动每年营收 8000 亿，够买 6 个 360 了，说免就免了，从哪能捞回来这么些钱？用户愿意交这个钱，非不收，那叫啥呢？ 反过来，移动通信能取代 WiFi 吗。WiFi 覆盖小，高速率，成本低，使用非许可频段，决定了其免费的必然性。移动通信要取代 WiFi，也必须达到如此低的成本，并且实现免费。这是否能做到呢？如果 4G 能够利用已有的规模优势，做低成本的 Femto 基站，理论上有可能。但是市场规模太小，菊花大厂看不上眼，现有的管理体制也不能适应。而小厂很难有这个技术能力。所以说也是比较难的。 所以说，移动通信和 WiFi 有各自的应用场景。移动通信能够实现 anytime，anywhere 的连接，能够满足用户的刚需，而 WiFi 便宜，无月租，满足用户高速率的应用需求，将长期共存。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:5:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#移动通信与-wifi"},{"categories":["WirelessCommunication"],"content":" 5G 之局移动通信经过四代的发展之后，人们得到一个似乎的规律，就是单数代不太成功，而偶数代很成功。经过我们的分析后发现，1G 和 3G，都是新的需求促成的，但是技术不太好，而 2G 和 4G 在原有的需求基础上，改进了技术，从而很成功。1G 和 3G 虽然不太成功，但也不能说是失败，毕竟他们是满足新需求的唯一技术。 但是到了 5G，需求是虚构的，技术上并没有进步，所以必然是要失败的。 5G 是目前最火热的话题。特别是孟晚舟事件之后，美帝组团打压华为，国人已经把 5G 看成是中美对决的战场。 对于 5G 的立场，任总曾经发表过一个讲话，说 5G 的需求并没有出现。我心里赞叹任总真是到了从心所欲不逾矩的境界，也不为利益所左右。后来徐直军也发表了对 5G 相对保守的观点。但是后来口风变了，任总为自己的讲话向产品线道了歉。后来华为发文表示要坚决打胜 5G 这一仗。 我们已经知道，移动通信的根本的价值在于实现任何时间，任何地点的连接能力，在此基础上提高网络容量。如果没有覆盖这个前提，只是在局部实现高速率是没有商业价值的。比如说大家一直谈论的可见光通信，因为覆盖小只能服务两三个人，速率太高超过了人的带宽，就没有意义了。 这个问题对毫米波、太赫兹都是如此。 虽然过高的速率没够意义，但是随着用户渗透率的提高，资费的下降，数据量每年增长 30%的情况还会持续很多年。因此移动网络还需要扩容。 移动通信正确对发展方向是，保证连续覆盖的情况下以低成本提高网络容量。当然，并不是我一个人才知道这是正确的方向，实际上这是通信界的常识，2G 和 4G 的成功就是这种模式。 5G 偏离了这种模式，走向了错误的方向。这背后的原因有三个： 通信原理的创新遇到瓶颈 半导体工艺获得了爆炸性的发展 无线产业决策链条太长 通信技术已经发展百年，因为其战略地位和创造财富的能力，全球最强智力投入其中，但凡简单一点的创新早就发掘完了。用于 Turbo 码解码的 BCJR 算法是 1970 年代发明的，在我历经艰辛终于看懂之后，感叹道，这只能与魔鬼做交易才能搞得出来。 到 2009 年的时候，随着 Turbo，LDPC，Polar，OFDM，MIMO 等领域的进展并且逼近理论极限，学术界普遍感觉到物理层已经死了，再也无法创新了。象 David Tse 这样的被公认为传承香农衣钵的大咖，也感觉无处可走，转行做生物信息去了。 在此同时，半导体技术得到了爆炸性的发展。大家手上的 U 盘，从 10 年前 128M 变成了现在的 128G。在通信原理无法获得突破的情况下，自然地走上利用强大的算力实现高速率的方向。 高算力使得采用更宽的频带，更多的天线成为可能，在通信原理不变的情况下，通过算力使得速率暴力提升 1000 倍是很简单的事情。华为早就整出来 115Gbps 的样机了。看报道我国启动了 6G 研究，速度比 5G 高 10 倍，看得我真是很无奈。 移动通信产业有着与其他产业不同的特点。一般的产业都是研发产品上市，获得反馈并逐步改进，是一个快速迭代的过程。 而移动通信要求在什么还没有之前，大家共同商定一个标准，然后按照这个标准做产品。 何时启动一代通信标准是战略决策，是由政治领导人和商业领导人来做出的。他们当然会咨询技术专家，但是专家们也未必懂，其中还有巨大的利益博弈，显然并不靠谱。行业认同的宏观规律是十年一代。时间一到，各方力量合力推动，就动手干了。大炮一响，黄金万两。即使实际上不能干，也得创造条件干。所以我们看到 5G 出现了很多奇葩的技术，如全双工，毫米波，现在可见光，太赫兹也要上场了。NOMA 和 F-OFDM 比较起来都算是好的。 一代移动通信标准一旦启动，到产品上市之前，所有的玩家都投入了巨大的成本。鉴于通信产业的战略地位，政府意志也为之背书。大家都绑在这个战车上，即使有问题，在碰到南墙之前是不会停下来的。 所以 5G 的问题，不光是华为的问题，或者是中国的问题，美国、欧洲也都是如此。很多网友看到美帝在 5G 上整华为，就觉得美帝反对的东西肯定很重要。中国长期以来落后，都以美国为灯塔。但是经过改开 40 年，中国国力日渐强盛。而通信产业整体上已经获得了领先地位。在这种竞争格局下，即使美帝也会犯错。什么铱星啊，Wimax 啊，不都是美帝整的吗？ 所以我们要有独立的判断，而不是被对方的判断左右。 随着商用的日益迫近，5G 的问题会逐渐暴露出来。比如最近 ATT 的 5G 造假，韩国 5G 被指无用，澳洲未能按计划推出 5G 服务，等等。希望本文能为各方提个醒，尽量减少损失吧。 因为任总的讲话，我认为华为对 5G 是有清醒的认识的，任总最新的讲话又谈到了 5G 的需求没有出现。5G 成功当然好，又能成为华为的产粮田，况且在舆论上华为 5G 已经领先友商 12 个月。但 5G 失败对华为也是有利的。因为华为有着最齐全的产品线，是行业老大，没有技术创新也就意味着现有格局的固化，华为也就能笑到最后了。当然裁员是避免不了的，这对于通信狗们来说不是个好消息。 对于二线的设备商，却是灾难性的，对 5G 的投入无法回收，现有市场份额也会被华为逐渐蚕食。 对于高通更是灭顶之灾，3G 专利过期，4G 没专利，然后 5G 没有了，怎么收专利费？早些年嫌设备和手机不赚钱甩给别人了，现在有点傻眼。趁手上还有点银子，想收个恩智浦，也被贸易战给搅黄了。这日子怕是过不下去了。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:6:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#5g-之局"},{"categories":["WirelessCommunication"],"content":" 未来之路前面已经讲到，移动通信的发展方向是在保证覆盖的情况下，用低成本的技术提高系统容量。这背后的使能器是核心技术的突破。这也是我近二十年的通信技术研究生涯所始终追求的目标。 尽管学界对通信原理的发展前景很悲观，但是情况正在起变化。 我在 2014 年发布了多级软频率复用技术（multilevel soft frequency reuse，MLSFR），是 SFR 技术的增强版。理论表明，SFR 可以提升频谱效率 10%左右，MLSFR 可以提高 30%。 值得注意的，这是在不增加任何硬件成本的前提下。 这种幅度技术进步，在最近 30 年的通信史上，只有 Turbo 码可以媲美，远远超过高通在 CDMA 领域的技术创新。MLSFR` 将成为未来移动通信组网技术的基石。 影响更加深远的，我已经在信息论上获得了重大突破。大家知道，香农在 1948 年创立了信息论，其中最重要的成果是这个信道容量公式：C=log（1+S/N），是指引着通信技术研究和工业发展的灯塔。 但是香农只给出了最简单的 AWGN 信道的容量。无线通信的信道都是衰落信道，而衰落信道的容量香农只开了个头，后来的学者发展出了一套衰落信道容量的理论，这些可以在经典的通信原理教科书里面找到。 但是，目前的衰落信道容量理论是错误的。 这个问题我思考了 14 年，终于提出了新的衰落信道容量理论并在 2018 年 3 月份完成了论文初稿。大家可以体会一下基础研究的周期。 审稿的过程也非常艰苦。开始投稿了 Nature，但是 Nature 认为满篇都是公式的稿件不符合它们的风格，还是投到应属期刊 IEEE Transactions on Information Theory。经过 5 个月的评审被拒，原因是两个评委认为论文对信息论存在误解。想想当年 Turbo 码论文，评委认为存在 3dB 的误差。重大突破被误解恐怕是一个规律，创新者需要有这样的心里准备。 但是另外一位评委给予了全面的肯定。当然，所有的评审意见都很容易回答，稿件修改之后再次投稿后，评审又进行了三个月，还没有出结果。在中美贸易战的背景下，美国在整华为，也难保政治不会侵蚀学术道德。不管怎么样，大家很快就能看到了。 基础理论的突破预示着无线通信产业的又一次技术革命，而中国就是这次革命的源头。 成功的道路并不拥挤，我们砥砺前行。 致敬改革开放 40 周年。 ","date":"2020-10-03","objectID":"/5g_will_be_a_complete_failure/:7:0","series":null,"tags":["5G"],"title":"5G 将是一个彻底的失败","uri":"/5g_will_be_a_complete_failure/#未来之路"},{"categories":["Linux"],"content":" 记录一些常用的 Linux 系统信息查询命令 日常使用 Linux 过程中，偶尔会需要查询一下系统信息，特别是在对于使用云端主机时，了解必要的信息十分重要。本文总结了一些常用的信息以及相应的查询命令。 技巧 善用 grep 类命令作为配合，高效筛选想要的信息内容。 ","date":"2020-09-13","objectID":"/system_info/:0:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#"},{"categories":["Linux"],"content":" 系统信息 $ uname -a # 查看内核/操作系统/CPU 信息 $ head -n 1 /etc/issue # 查看操作系统版本 $ hostname # 查看计算机名 $ lspci -tv # 列出所有 PCI 设备 $ lsusb -tv # 列出所有 USB 设备 $ lsmod # 列出加载的内核模块 $ env # 查看环境变量 ","date":"2020-09-13","objectID":"/system_info/:1:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#系统信息"},{"categories":["Linux"],"content":" 系统资源 $ cat /proc/cpuinfo # 查看 CPU 信息 $ lscpu # 查看 CPU 信息 $ lshw -short # 当前服务器 CPU、内存、磁盘等详细信息 $ free -m # 查看内存使用量和交换区使用量 $ df -h # 查看各分区使用情况 $ du -sh # 查看指定目录的大小 $ grep MemTotal /proc/meminfo # 查看内存总量 $ grep MemFree /proc/meminfo # 查看空闲内存量 $ uptime # 查看系统运行时间、用户数、负载 $ cat /proc/loadavg # 查看系统负载 ","date":"2020-09-13","objectID":"/system_info/:2:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#系统资源"},{"categories":["Linux"],"content":" 磁盘和分区 $ mount | column -t # 查看挂接的分区状态 $ fdisk -l # 查看所有分区 ","date":"2020-09-13","objectID":"/system_info/:3:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#磁盘和分区"},{"categories":["Linux"],"content":" 网络信息 $ ip # 查看网络相关信息，具体用法参见 man 手册 $ iptables -L # 查看防火墙设置 $ route -n # 查看路由表 $ netstat -lntp # 查看所有监听端口 $ netstat -antp # 查看所有已经建立的连接 $ netstat -s # 查看网络统计信息 ","date":"2020-09-13","objectID":"/system_info/:4:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#网络信息"},{"categories":["Linux"],"content":" 进程查询 $ ps -ef # 查看所有进程 $ top # 实时显示进程状态 $ htop # 实时显示进程状态，加强版 top ","date":"2020-09-13","objectID":"/system_info/:5:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#进程查询"},{"categories":["Linux"],"content":" 用户信息 $ w # 查看活动用户 $ id \u003c用户名\u003e # 查看指定用户信息 $ last # 查看用户登录日志 $ cut -d: -f1 /etc/passwd # 查看系统所有用户 $ cut -d: -f1 /etc/group # 查看系统所有组 ","date":"2020-09-13","objectID":"/system_info/:6:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#用户信息"},{"categories":["Linux"],"content":" 服务 $ crontab -l # 查看当前用户的计划任务 $ chkconfig –list # 列出所有系统服务 $ chkconfig –list | grep on # 列出所有启动的系统服务 ","date":"2020-09-13","objectID":"/system_info/:7:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#服务"},{"categories":["Linux"],"content":" 软件信息 $ apt list --installed # 显示 apt 安装的软件 $ pacman -Qmeq # 显示 aur 软件 $ pacman -Qneq # 显示 pacman 安装的软件 $ pactree package_name # 显示软件的依赖树 ","date":"2020-09-13","objectID":"/system_info/:8:0","series":null,"tags":["Commands"],"title":"Linux 系统信息查询","uri":"/system_info/#软件信息"},{"categories":["WirelessCommunication"],"content":" 什么是波束赋形？波束赋形的基本原理是什么？5G 怎样实现波束赋形？ 注：本文系全文转载，原文信息如下： 作者：无线深海 链接：https://zhuanlan.zhihu.com/p/144971077 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2020-09-09","objectID":"/beamforming/:0:0","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#"},{"categories":["WirelessCommunication"],"content":" 什么是波束赋形？波束赋形这个概念可以拆分成波束和赋形这两个词来理解。 波束里的波字可以认为是电磁波，束字的本意是“捆绑”，因此波束的含义是捆绑在一起集中传播的电磁波 赋形可以简单地理解为“赋予一定的形状” 合起来，波束赋形的意思就是赋予一定形状集中传播的电磁波。 分散与集中的光线 其实，我们常见的光也是一种电磁波，灯泡作为一个点光源，发出的光没有方向性，只能不断向四周耗散；而手电筒则可以把光集中到一个方向发射，能量更为聚焦，从而照地更远。 无线基站也是同理，如下图所示，如果天线的信号全向发射的话，这几个手机只能收到有限的信号，大部分能量都浪费掉了。 分散与集中的电磁波 而如果能通过波束赋形把信号聚焦成几个波束，专门指向各个手机发射的话，承载信号的电磁能量就能传播地更远，而且手机收到的信号也就会更强。 因此，波束赋形在无线通信中大有可为。 ","date":"2020-09-09","objectID":"/beamforming/:1:0","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#什么是波束赋形"},{"categories":["WirelessCommunication"],"content":" 波束赋形的基本原理是什么？波束赋形的物理学原理，其实就是波的干涉现象。 频率相同的两列波叠加，使某些区域的振动加强，某些区域的振动减弱，而且振动加强的区域和振动减弱的区域相互隔开。 想象一下，在湖边漫步时，你和女朋友在相距很近的两点激起水波，两朵涟漪不断散开，然后交叠起来，形成了下面的图样。 波的干涉现象 可以看出，有的地方水波增强，有的地方则减弱，并且增强和减弱的地方间隔分布，在最中间的狭窄区域最为明显。 如果波峰和波峰，或者波谷和波谷相遇，则能量相加，波峰更高，波谷更深。这种情况叫做相长干涉。 反之，如果波峰和波谷相遇，两者则相互抵消，震动归于静寂。这种情况叫做相消干涉。 如果把这个现象抽象一下，可以得到下图： 波的干涉 在两个馈源正中间的地方由于相长干涉，能量最强，可以认为形成了一个定向的波束，也叫做主瓣；两边则由于相消干涉能量抵消，形成了零陷，再往两边又是相长干涉，但弱于最中间，因此称作旁瓣。 如果我们能继续增强正中央主瓣的能量，使其宽度更窄，并抑制两边的旁瓣，就可以得到干净利落的波束了。 其实，普通天线一直在做这样的事情。 天线内部排布着一系列的电磁波源，称作振子，或者天线单元。这些天线单元也利用干涉原理来形成定向的波束。 单列天线 由上图可以看出，纵向排列的天线单元越多，最中间的可集中的能量也就越多，波束也就越窄。 但这只是一个垂直截面而已，其实完整的波束在空间是三维的，水平和垂直的宽度可能截然不同。 下图是一个天线的振子排列，以及辐射能量三维分布图。 纵向双列天线 可以看出，上述天线内振源的排布方式为纵向，横向的数量很少，因此其波束在垂直方向的能量集中，而水平方向的角度还是比较宽的，像一个薄薄的大饼。 这种传统的天线水平方向的辐射角度多为 60 度，进行大面积的地面信号覆盖是一把好手，但要垂直覆盖高楼就有些力不从心了，称作“波束赋形”还是不够格。 如果我们把这些天线单元的排布改成矩形，电磁波辐射能量将在最中央形成一个很粗的主瓣，周边是一圈的旁瓣，这就有点波束赋形的意思了。 矩形天线 为了让波束更窄能量更集中，天线单元还需要更多更密，水平和垂直两个维度也都要兼顾，原本的天线就变成了大规模天线阵列。 大规模矩形天线 这下，生成的波束就犀利多了，用大规模天线阵列来支持波束赋形，稳了！ 但是这样还有问题，那就是这个最大波束位于正中央，且其传播方向和天线阵列垂直，而手机是一直随着用户移动的，所在的位置完全不确定，主波束虽然犀利，但照射不到手机上也是白搭。 那么，能不能让波束偏移一定的角度，对准手机来发射呢？ 首先我们看看中央的主波束的形成过程：多列波的相位相同，也就是波峰和波谷在同一时间是对齐的，则它们到达手机时，就可以相长干涉，信号通过叠加得以增强。 到达同相，相长干涉 如果手机和天线阵列有一定的夹角，则各列波到达手机时，相位难以对齐，可能是波峰和波谷相遇，也可能是在其他相位进行叠加，难以达到相长干涉，信号叠加的效果。 到达异相，无法相长 这可咋办？总不能通过旋转天线来让波束跟随手机吧？ 其实，周期性是波最大的特点，不同的相位总是周期性的出现，错过了这个波峰，还有下一个波峰要来，因此相位是可以调整的。 通过调整不同天线单元发射信号的振幅和相位（权值），即使它们的传播路径各不相同，只要在到达手机的时候相位相同，就可以达到信号叠加增强的结果，相当于天线阵列把信号对准了手机。 相位控制 下图是一个示例，可以看出天线阵列通过调整发射信号的相位，让波束偏移了 θ 度，从而可以精确对准手机发射信号。 相位控制 ","date":"2020-09-09","objectID":"/beamforming/:2:0","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#波束赋形的基本原理是什么"},{"categories":["WirelessCommunication"],"content":" 5G 怎样实现波束赋形？由此可见，波束赋形的关键在于天线单元相位的管控，也就是天线权值的处理。 根据波束赋形处理位置和方式的不同，可分为 数字波束赋形 模拟波束赋形 混合波束赋形 ","date":"2020-09-09","objectID":"/beamforming/:3:0","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#5g-怎样实现波束赋形"},{"categories":["WirelessCommunication"],"content":" 模拟波束赋形所谓模拟波束赋形，就是通过处理射频信号权值，通过移相器来完成天线相位的调整，处理的位置相对靠后。 模拟波束赋形 模拟波束赋形的特点是基带处理的通道数量远小于天线单元的数量，因此容量上受到限制，并且天线的赋形完全是靠硬件搭建的，还会受到器件精度的影响，使性能受到一定的制约。 模拟波束赋形框图 ","date":"2020-09-09","objectID":"/beamforming/:3:1","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#模拟波束赋形"},{"categories":["WirelessCommunication"],"content":" 数字波束赋形数字波束赋形则在基带模块的时候就进行了天线权值的处理，基带处理的通道数和天线单元的数量相等，因此需要为每路数据配置一套射频链路。 数字波束赋形 数字波束赋形的优点是 赋形精度高 实现灵活 天线权值变换响应及时 缺点是 基带处理能力要求高 系统复杂 设备体积大 成本较高 Sub6G 频段，作为当前 5G 容量的主力军，载波带宽可达 100MHz，一般采用采用数字波束赋形，通过 64 通道发射来实现小区内时频资源的多用户复用，下行最大可同时发射 24 路独立信号，上行独立接收 12 路数据，扛起了 5G 超高速率的大旗。 数字波束赋形框图 在毫米波 mmWave 频段，由于频谱资源非常充沛，一个 5G 载波的带宽可达 400MHz，如果单个 AAU 支持两个载波的话，带宽就达到了惊人的 800MHz！ 如果还要像 Sub6G 频段的设备一样支持数字波束赋形的话，对基带处理能力要求太高，并且射频部分功放的数量也要数倍增加，实现成本过高，功耗更是大得吓人。 ","date":"2020-09-09","objectID":"/beamforming/:3:2","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#数字波束赋形"},{"categories":["WirelessCommunication"],"content":" 混合波束赋形因此，业界将数字波束赋形和模拟波束赋形结合起来，使在模拟端可调幅调相的波束赋形，结合基带的数字波束赋形，称之为混合波束赋形。 混合波束赋形数字和模拟融合了两者的优点： 基带处理的通道数目明显小于模拟天线单元的数量 复杂度大幅下降 成本降低 系统性能接近全数字波束赋形 非常适用于高频系统 混合波束赋形框图 这样一来，毫米波频段的设备基带处理的通道数较少，一般为 4T4R，但天线单元众多，可达 512 个，其容量的主要来源是超大带宽和波束赋形。 在波束赋形和 Massive MIMO 的加成之下，5G 在 Sub6G 频谱下单载波最多可达 7Gbps 的小区峰值速率，在毫米波频谱下单载波也最多达到了约 4.8Gbps 的小区峰值速率。 ","date":"2020-09-09","objectID":"/beamforming/:3:3","series":null,"tags":["5G"],"title":"5G NR 系列：波束赋形","uri":"/beamforming/#混合波束赋形"},{"categories":["WirelessCommunication"],"content":" Meanings of 3GPP releases ","date":"2020-09-03","objectID":"/3gpp_releases/:0:0","series":null,"tags":["3GPP"],"title":"3GPP Releases","uri":"/3gpp_releases/#"},{"categories":["WirelessCommunication"],"content":" 3GPP Release schedule and summary 3GPP RELEASE RELEASE DATE DETAILS Phase 1 1992 Basic GSM Phase 2 1995 GSM features including EFR Codec Release 96 Q1 1997 GSM Updates, 14.4 kbps user data Release 97 Q1 1998 GSM additional features, GPRS Release 98 Q1 1999 GSM additional features, GPRS for PCS 1900, AMR, EDGE Release 99 Q1 2000 3G UMTS incorporating WCDMA radio access Release 4 Q2 2001 UMTS all-IP Core Network Release 5 Q1 2002 IMS and HSDPA Release 6 Q4 2004 HSUPA, MBMS, IMS enhancements, Push to Talk over Cellular, operation with WLAN Release 7 Q4 2007 Improvements in QoS \u0026 latency, VoIP, HSPA+, NFC integration, EDGE Evolution Release 8 Q4 2008 Introduction of LTE, SAE, OFDMA, MIMO, Dual Cell HSDPA Release 9 Q4 2009 WiMAX / LTE / UMTS interoperability, Dual Cell HSDPA with MIMO, Dual Cell HSUPA, LTE HeNB Release 10 Q1 2011 LTE-Advanced, Backwards compatibility with Release 8 (LTE), Multi-Cell HSDPA Release 11 Q3 2012 Heterogeneous networks (HetNet), Coordinated Multipoint (CoMP), In device Coexistence (IDC), Advanced IP interconnection of Services, Release 12 March 2015 Enhanced Small Cells operation, Carrier Aggregation (2 uplink carriers, 3 downlink carriers, FDD/TDD carrier Release 13 Q1 2016 LTE-U / LTE-LAA, LTE-M, Elevation beamforming / Full Dimension MIMO, Indoor positioning, LTE-M Cat 1.4MHz \u0026 Cat 200kHz introduced Release 14 Mid 2017 Elements on road to 5G Release 15 End 2018 5G Phase 1 specification Release 16 2020 5G Phase 2 specification Release 17 ~Sept 2021 ","date":"2020-09-03","objectID":"/3gpp_releases/:1:0","series":null,"tags":["3GPP"],"title":"3GPP Releases","uri":"/3gpp_releases/#3gpp-release-schedule-and-summary"},{"categories":["WirelessCommunication"],"content":" 参考 [1] 3GPP Specification Release Numbers ","date":"2020-09-03","objectID":"/3gpp_releases/:2:0","series":null,"tags":["3GPP"],"title":"3GPP Releases","uri":"/3gpp_releases/#参考"},{"categories":["Web"],"content":" 加速访问！ ","date":"2020-08-26","objectID":"/migrated_to_vercel/:0:0","series":null,"tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/#"},{"categories":["Web"],"content":" When网站已于 2020-8-26 迁移至 Vercel ","date":"2020-08-26","objectID":"/migrated_to_vercel/:1:0","series":null,"tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/#when"},{"categories":["Web"],"content":" Why鉴于目前 Github 以及 Cloudflare 在国内的访问速度一日不如一日，所以开始寻找了替代服务。刚好有 V2er 发帖求助相同的需求，于是顺着帖子的推荐选择了 Vercel。 ","date":"2020-08-26","objectID":"/migrated_to_vercel/:2:0","series":null,"tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/#why"},{"categories":["Web"],"content":" What下面是 Vercel 官网的介绍： 引用 Vercel is a cloud platform for static sites and Serverless Functions that fits perfectly with your workflow. It enables developers to host Jamstack websites and web services that deploy instantly, scale automatically, and requires no supervision, all with no configuration. 相比于 Github Pages、Netlify 等，Vercel 拥有台湾和香港节点，对国内用户更加友好，并且免费套餐足够应付小流量情况了。 Vercel ","date":"2020-08-26","objectID":"/migrated_to_vercel/:3:0","series":null,"tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/#what"},{"categories":["Web"],"content":" How此前，本网站是托管在 Github Pages,然后通过 Clouflare 进行代理访问，因此只需要在 Cloudfalre 原配置上就行修改即可。 首先，直接使用 Github 账号（或 Gitlab 等）登录 Vercel 即可（注： 不可以使用 QQ 邮箱为主邮箱的 Github 账号，Vercel 不识别部分邮箱域名，如果你是，请到 Github 修改主邮箱） 导入 Github 项目 选择需要导入的文件夹，默认为根文件夹 完成导入后，配置你的预编译设置（由于本站是在本地使用 Hugo 编译好后 push 到 Github 上的所以这里选择 Other，然后勾选 OVERRIDE，不填写编译内容，表示不需要进行编译）如果你想要 Vercel 代替你编译，可以在这里选择相应的配置。 编译选项 待你完成编译配置后，等待 Vercel 完成编译和部署，你就可以得到一个可以访问的网站了，当然域名是一个二级域名。接下来我们配置自定义域名，首先点击你的项目，进入 设置 \u003e 域名。然后添加你的域名，一开始你添加好的域名不会和图片上一样，会显示为正确配置，这是因为我们还需要到 Cloudflare 进行调整。 域名设置 来到 Cloudflare 的 DNS 配置页面，首先删除此前指向 Github Pages 的两个解析，然后添加一个CNAME类型的解析，设置名字设置为www,内容填入cname.vercel-dns.com； 注： 关键一步是，这里一定要设置Proxy Status为DNS only，否则，你的网站依然会经过 Cloudflare 的代理来访问。 Cloudflare DNS 配置 信息 这里我还添加一个 A 记录指向76.76.21.21，因为我默认将根域名跳转到www。这个根据实际情况决定，但同样记得设置设置Proxy Status为DNS only。 ","date":"2020-08-26","objectID":"/migrated_to_vercel/:4:0","series":null,"tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/#how"},{"categories":["Web"],"content":" 参考 [1] Introduction to Vercel ","date":"2020-08-26","objectID":"/migrated_to_vercel/:5:0","series":null,"tags":["Vercel"],"title":"全站迁移到 Vercel","uri":"/migrated_to_vercel/#参考"},{"categories":["Network"],"content":" 列举国内外常见的 DNS，方便替换使用 ","date":"2020-08-21","objectID":"/dns_list/:0:0","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#"},{"categories":["Network"],"content":" IPv4","date":"2020-08-21","objectID":"/dns_list/:1:0","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#ipv4"},{"categories":["Network"],"content":" 国内 知名 DNS 服务 名称 IP 地址（首选） IP 地址（备选） 114 常规 DNS 114.114.114.114 114.114.115.115 114 拦截钓鱼病毒木马网站 114.114.114.119 114.114.115.119 114 拦截色情网站 114.114.114.110 114.114.115.110 阿里 AliDNS 223.5.5.5 223.6.6.6 百度 BaiduDNS 180.76.76.76 DNSPod DNS+ 119.29.29.29 182.254.116.116 CNNIC SDNS 1.2.4.8 210.2.4.8 oneDNS 117.50.11.11 52.80.66.66 DNS 派电信/移动/铁通 101.226.4.6 218.30.118.6 DNS 派联通 123.125.81.6 140.207.198.6 全国各地电信 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 安徽电信 DNS 61.132.163.68 202.102.213.68 北京电信 DNS 219.141.136.10 219.141.140.10 重庆电信 DNS 61.128.192.68 61.128.128.68 福建电信 DNS 218.85.152.99 218.85.157.99 甘肃电信 DNS 202.100.64.68 61.178.0.93 广东电信 DNS 202.96.128.86 202.96.128.166 202.96.134.33 202.96.128.68 广西电信 DNS 202.103.225.68 202.103.224.68 贵州电信 DNS 202.98.192.67 202.98.198.167 河南电信 DNS 222.88.88.88 222.85.85.85 黑龙江电信 219.147.198.230 219.147.198.242 湖北电信 DNS 202.103.24.68 202.103.0.68 湖南电信 DNS 222.246.129.80 59.51.78.211 江苏电信 DNS 218.2.2.2 218.4.4.4 61.147.37.1 218.2.135.1 江西电信 DNS 202.101.224.69 202.101.226.68 内蒙古电信 219.148.162.31 222.74.39.50 山东电信 DNS 219.146.1.66 219.147.1.66 陕西电信 DNS 218.30.19.40 61.134.1.4 上海电信 DNS 202.96.209.133 116.228.111.118 202.96.209.5 180.168.255.118 四川电信 DNS 61.139.2.69 218.6.200.139 天津电信 DNS 219.150.32.132 219.146.0.132 云南电信 DNS 222.172.200.68 61.166.150.123 浙江电信 DNS 202.101.172.35 61.153.177.196 61.153.81.75 60.191.244.5 全国各地联通 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 北京联通 DNS 123.123.123.123 123.123.123.124 202.106.0.20 202.106.195.68 重庆联通 DNS 221.5.203.98 221.7.92.98 广东联通 DNS 210.21.196.6 221.5.88.88 河北联通 DNS 202.99.160.68 202.99.166.4 河南联通 DNS 202.102.224.68 202.102.227.68 黑龙江联通 202.97.224.69 202.97.224.68 吉林联通 DNS 202.98.0.68 202.98.5.68 江苏联通 DNS 221.6.4.66 221.6.4.67 内蒙古联通 202.99.224.68 202.99.224.8 山东联通 DNS 202.102.128.68 202.102.152.3 202.102.134.68 202.102.154.3 山西联通 DNS 202.99.192.66 202.99.192.68 陕西联通 DNS 221.11.1.67 221.11.1.68 上海联通 DNS 210.22.70.3 210.22.84.3 四川联通 DNS 119.6.6.6 124.161.87.155 天津联通 DNS 202.99.104.68 202.99.96.68 浙江联通 DNS 221.12.1.227 221.12.33.227 辽宁联通 DNS 202.96.69.38 202.96.64.68 全国各地移动 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 江苏移动 DNS 221.131.143.69 112.4.0.55 安徽移动 DNS 211.138.180.2 211.138.180.3 山东移动 DNS 218.201.96.130 211.137.191.26 ","date":"2020-08-21","objectID":"/dns_list/:1:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#国内"},{"categories":["Network"],"content":" 国内 知名 DNS 服务 名称 IP 地址（首选） IP 地址（备选） 114 常规 DNS 114.114.114.114 114.114.115.115 114 拦截钓鱼病毒木马网站 114.114.114.119 114.114.115.119 114 拦截色情网站 114.114.114.110 114.114.115.110 阿里 AliDNS 223.5.5.5 223.6.6.6 百度 BaiduDNS 180.76.76.76 DNSPod DNS+ 119.29.29.29 182.254.116.116 CNNIC SDNS 1.2.4.8 210.2.4.8 oneDNS 117.50.11.11 52.80.66.66 DNS 派电信/移动/铁通 101.226.4.6 218.30.118.6 DNS 派联通 123.125.81.6 140.207.198.6 全国各地电信 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 安徽电信 DNS 61.132.163.68 202.102.213.68 北京电信 DNS 219.141.136.10 219.141.140.10 重庆电信 DNS 61.128.192.68 61.128.128.68 福建电信 DNS 218.85.152.99 218.85.157.99 甘肃电信 DNS 202.100.64.68 61.178.0.93 广东电信 DNS 202.96.128.86 202.96.128.166 202.96.134.33 202.96.128.68 广西电信 DNS 202.103.225.68 202.103.224.68 贵州电信 DNS 202.98.192.67 202.98.198.167 河南电信 DNS 222.88.88.88 222.85.85.85 黑龙江电信 219.147.198.230 219.147.198.242 湖北电信 DNS 202.103.24.68 202.103.0.68 湖南电信 DNS 222.246.129.80 59.51.78.211 江苏电信 DNS 218.2.2.2 218.4.4.4 61.147.37.1 218.2.135.1 江西电信 DNS 202.101.224.69 202.101.226.68 内蒙古电信 219.148.162.31 222.74.39.50 山东电信 DNS 219.146.1.66 219.147.1.66 陕西电信 DNS 218.30.19.40 61.134.1.4 上海电信 DNS 202.96.209.133 116.228.111.118 202.96.209.5 180.168.255.118 四川电信 DNS 61.139.2.69 218.6.200.139 天津电信 DNS 219.150.32.132 219.146.0.132 云南电信 DNS 222.172.200.68 61.166.150.123 浙江电信 DNS 202.101.172.35 61.153.177.196 61.153.81.75 60.191.244.5 全国各地联通 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 北京联通 DNS 123.123.123.123 123.123.123.124 202.106.0.20 202.106.195.68 重庆联通 DNS 221.5.203.98 221.7.92.98 广东联通 DNS 210.21.196.6 221.5.88.88 河北联通 DNS 202.99.160.68 202.99.166.4 河南联通 DNS 202.102.224.68 202.102.227.68 黑龙江联通 202.97.224.69 202.97.224.68 吉林联通 DNS 202.98.0.68 202.98.5.68 江苏联通 DNS 221.6.4.66 221.6.4.67 内蒙古联通 202.99.224.68 202.99.224.8 山东联通 DNS 202.102.128.68 202.102.152.3 202.102.134.68 202.102.154.3 山西联通 DNS 202.99.192.66 202.99.192.68 陕西联通 DNS 221.11.1.67 221.11.1.68 上海联通 DNS 210.22.70.3 210.22.84.3 四川联通 DNS 119.6.6.6 124.161.87.155 天津联通 DNS 202.99.104.68 202.99.96.68 浙江联通 DNS 221.12.1.227 221.12.33.227 辽宁联通 DNS 202.96.69.38 202.96.64.68 全国各地移动 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 江苏移动 DNS 221.131.143.69 112.4.0.55 安徽移动 DNS 211.138.180.2 211.138.180.3 山东移动 DNS 218.201.96.130 211.137.191.26 ","date":"2020-08-21","objectID":"/dns_list/:1:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#知名-dns-服务"},{"categories":["Network"],"content":" 国内 知名 DNS 服务 名称 IP 地址（首选） IP 地址（备选） 114 常规 DNS 114.114.114.114 114.114.115.115 114 拦截钓鱼病毒木马网站 114.114.114.119 114.114.115.119 114 拦截色情网站 114.114.114.110 114.114.115.110 阿里 AliDNS 223.5.5.5 223.6.6.6 百度 BaiduDNS 180.76.76.76 DNSPod DNS+ 119.29.29.29 182.254.116.116 CNNIC SDNS 1.2.4.8 210.2.4.8 oneDNS 117.50.11.11 52.80.66.66 DNS 派电信/移动/铁通 101.226.4.6 218.30.118.6 DNS 派联通 123.125.81.6 140.207.198.6 全国各地电信 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 安徽电信 DNS 61.132.163.68 202.102.213.68 北京电信 DNS 219.141.136.10 219.141.140.10 重庆电信 DNS 61.128.192.68 61.128.128.68 福建电信 DNS 218.85.152.99 218.85.157.99 甘肃电信 DNS 202.100.64.68 61.178.0.93 广东电信 DNS 202.96.128.86 202.96.128.166 202.96.134.33 202.96.128.68 广西电信 DNS 202.103.225.68 202.103.224.68 贵州电信 DNS 202.98.192.67 202.98.198.167 河南电信 DNS 222.88.88.88 222.85.85.85 黑龙江电信 219.147.198.230 219.147.198.242 湖北电信 DNS 202.103.24.68 202.103.0.68 湖南电信 DNS 222.246.129.80 59.51.78.211 江苏电信 DNS 218.2.2.2 218.4.4.4 61.147.37.1 218.2.135.1 江西电信 DNS 202.101.224.69 202.101.226.68 内蒙古电信 219.148.162.31 222.74.39.50 山东电信 DNS 219.146.1.66 219.147.1.66 陕西电信 DNS 218.30.19.40 61.134.1.4 上海电信 DNS 202.96.209.133 116.228.111.118 202.96.209.5 180.168.255.118 四川电信 DNS 61.139.2.69 218.6.200.139 天津电信 DNS 219.150.32.132 219.146.0.132 云南电信 DNS 222.172.200.68 61.166.150.123 浙江电信 DNS 202.101.172.35 61.153.177.196 61.153.81.75 60.191.244.5 全国各地联通 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 北京联通 DNS 123.123.123.123 123.123.123.124 202.106.0.20 202.106.195.68 重庆联通 DNS 221.5.203.98 221.7.92.98 广东联通 DNS 210.21.196.6 221.5.88.88 河北联通 DNS 202.99.160.68 202.99.166.4 河南联通 DNS 202.102.224.68 202.102.227.68 黑龙江联通 202.97.224.69 202.97.224.68 吉林联通 DNS 202.98.0.68 202.98.5.68 江苏联通 DNS 221.6.4.66 221.6.4.67 内蒙古联通 202.99.224.68 202.99.224.8 山东联通 DNS 202.102.128.68 202.102.152.3 202.102.134.68 202.102.154.3 山西联通 DNS 202.99.192.66 202.99.192.68 陕西联通 DNS 221.11.1.67 221.11.1.68 上海联通 DNS 210.22.70.3 210.22.84.3 四川联通 DNS 119.6.6.6 124.161.87.155 天津联通 DNS 202.99.104.68 202.99.96.68 浙江联通 DNS 221.12.1.227 221.12.33.227 辽宁联通 DNS 202.96.69.38 202.96.64.68 全国各地移动 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 江苏移动 DNS 221.131.143.69 112.4.0.55 安徽移动 DNS 211.138.180.2 211.138.180.3 山东移动 DNS 218.201.96.130 211.137.191.26 ","date":"2020-08-21","objectID":"/dns_list/:1:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#全国各地电信-dns-服务器-ip-地址"},{"categories":["Network"],"content":" 国内 知名 DNS 服务 名称 IP 地址（首选） IP 地址（备选） 114 常规 DNS 114.114.114.114 114.114.115.115 114 拦截钓鱼病毒木马网站 114.114.114.119 114.114.115.119 114 拦截色情网站 114.114.114.110 114.114.115.110 阿里 AliDNS 223.5.5.5 223.6.6.6 百度 BaiduDNS 180.76.76.76 DNSPod DNS+ 119.29.29.29 182.254.116.116 CNNIC SDNS 1.2.4.8 210.2.4.8 oneDNS 117.50.11.11 52.80.66.66 DNS 派电信/移动/铁通 101.226.4.6 218.30.118.6 DNS 派联通 123.125.81.6 140.207.198.6 全国各地电信 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 安徽电信 DNS 61.132.163.68 202.102.213.68 北京电信 DNS 219.141.136.10 219.141.140.10 重庆电信 DNS 61.128.192.68 61.128.128.68 福建电信 DNS 218.85.152.99 218.85.157.99 甘肃电信 DNS 202.100.64.68 61.178.0.93 广东电信 DNS 202.96.128.86 202.96.128.166 202.96.134.33 202.96.128.68 广西电信 DNS 202.103.225.68 202.103.224.68 贵州电信 DNS 202.98.192.67 202.98.198.167 河南电信 DNS 222.88.88.88 222.85.85.85 黑龙江电信 219.147.198.230 219.147.198.242 湖北电信 DNS 202.103.24.68 202.103.0.68 湖南电信 DNS 222.246.129.80 59.51.78.211 江苏电信 DNS 218.2.2.2 218.4.4.4 61.147.37.1 218.2.135.1 江西电信 DNS 202.101.224.69 202.101.226.68 内蒙古电信 219.148.162.31 222.74.39.50 山东电信 DNS 219.146.1.66 219.147.1.66 陕西电信 DNS 218.30.19.40 61.134.1.4 上海电信 DNS 202.96.209.133 116.228.111.118 202.96.209.5 180.168.255.118 四川电信 DNS 61.139.2.69 218.6.200.139 天津电信 DNS 219.150.32.132 219.146.0.132 云南电信 DNS 222.172.200.68 61.166.150.123 浙江电信 DNS 202.101.172.35 61.153.177.196 61.153.81.75 60.191.244.5 全国各地联通 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 北京联通 DNS 123.123.123.123 123.123.123.124 202.106.0.20 202.106.195.68 重庆联通 DNS 221.5.203.98 221.7.92.98 广东联通 DNS 210.21.196.6 221.5.88.88 河北联通 DNS 202.99.160.68 202.99.166.4 河南联通 DNS 202.102.224.68 202.102.227.68 黑龙江联通 202.97.224.69 202.97.224.68 吉林联通 DNS 202.98.0.68 202.98.5.68 江苏联通 DNS 221.6.4.66 221.6.4.67 内蒙古联通 202.99.224.68 202.99.224.8 山东联通 DNS 202.102.128.68 202.102.152.3 202.102.134.68 202.102.154.3 山西联通 DNS 202.99.192.66 202.99.192.68 陕西联通 DNS 221.11.1.67 221.11.1.68 上海联通 DNS 210.22.70.3 210.22.84.3 四川联通 DNS 119.6.6.6 124.161.87.155 天津联通 DNS 202.99.104.68 202.99.96.68 浙江联通 DNS 221.12.1.227 221.12.33.227 辽宁联通 DNS 202.96.69.38 202.96.64.68 全国各地移动 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 江苏移动 DNS 221.131.143.69 112.4.0.55 安徽移动 DNS 211.138.180.2 211.138.180.3 山东移动 DNS 218.201.96.130 211.137.191.26 ","date":"2020-08-21","objectID":"/dns_list/:1:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#全国各地联通-dns-服务器-ip-地址"},{"categories":["Network"],"content":" 国内 知名 DNS 服务 名称 IP 地址（首选） IP 地址（备选） 114 常规 DNS 114.114.114.114 114.114.115.115 114 拦截钓鱼病毒木马网站 114.114.114.119 114.114.115.119 114 拦截色情网站 114.114.114.110 114.114.115.110 阿里 AliDNS 223.5.5.5 223.6.6.6 百度 BaiduDNS 180.76.76.76 DNSPod DNS+ 119.29.29.29 182.254.116.116 CNNIC SDNS 1.2.4.8 210.2.4.8 oneDNS 117.50.11.11 52.80.66.66 DNS 派电信/移动/铁通 101.226.4.6 218.30.118.6 DNS 派联通 123.125.81.6 140.207.198.6 全国各地电信 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 安徽电信 DNS 61.132.163.68 202.102.213.68 北京电信 DNS 219.141.136.10 219.141.140.10 重庆电信 DNS 61.128.192.68 61.128.128.68 福建电信 DNS 218.85.152.99 218.85.157.99 甘肃电信 DNS 202.100.64.68 61.178.0.93 广东电信 DNS 202.96.128.86 202.96.128.166 202.96.134.33 202.96.128.68 广西电信 DNS 202.103.225.68 202.103.224.68 贵州电信 DNS 202.98.192.67 202.98.198.167 河南电信 DNS 222.88.88.88 222.85.85.85 黑龙江电信 219.147.198.230 219.147.198.242 湖北电信 DNS 202.103.24.68 202.103.0.68 湖南电信 DNS 222.246.129.80 59.51.78.211 江苏电信 DNS 218.2.2.2 218.4.4.4 61.147.37.1 218.2.135.1 江西电信 DNS 202.101.224.69 202.101.226.68 内蒙古电信 219.148.162.31 222.74.39.50 山东电信 DNS 219.146.1.66 219.147.1.66 陕西电信 DNS 218.30.19.40 61.134.1.4 上海电信 DNS 202.96.209.133 116.228.111.118 202.96.209.5 180.168.255.118 四川电信 DNS 61.139.2.69 218.6.200.139 天津电信 DNS 219.150.32.132 219.146.0.132 云南电信 DNS 222.172.200.68 61.166.150.123 浙江电信 DNS 202.101.172.35 61.153.177.196 61.153.81.75 60.191.244.5 全国各地联通 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 北京联通 DNS 123.123.123.123 123.123.123.124 202.106.0.20 202.106.195.68 重庆联通 DNS 221.5.203.98 221.7.92.98 广东联通 DNS 210.21.196.6 221.5.88.88 河北联通 DNS 202.99.160.68 202.99.166.4 河南联通 DNS 202.102.224.68 202.102.227.68 黑龙江联通 202.97.224.69 202.97.224.68 吉林联通 DNS 202.98.0.68 202.98.5.68 江苏联通 DNS 221.6.4.66 221.6.4.67 内蒙古联通 202.99.224.68 202.99.224.8 山东联通 DNS 202.102.128.68 202.102.152.3 202.102.134.68 202.102.154.3 山西联通 DNS 202.99.192.66 202.99.192.68 陕西联通 DNS 221.11.1.67 221.11.1.68 上海联通 DNS 210.22.70.3 210.22.84.3 四川联通 DNS 119.6.6.6 124.161.87.155 天津联通 DNS 202.99.104.68 202.99.96.68 浙江联通 DNS 221.12.1.227 221.12.33.227 辽宁联通 DNS 202.96.69.38 202.96.64.68 全国各地移动 DNS 服务器 IP 地址 名称 IP 地址（首选） IP 地址（备选） 江苏移动 DNS 221.131.143.69 112.4.0.55 安徽移动 DNS 211.138.180.2 211.138.180.3 山东移动 DNS 218.201.96.130 211.137.191.26 ","date":"2020-08-21","objectID":"/dns_list/:1:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#全国各地移动-dns-服务器-ip-地址"},{"categories":["Network"],"content":" 香港地区 名称 IP 地址（首选） IP 地址（备选） 香港宽频 DNS 203.80.96.10 和记环球电讯 DNS 202.45.84.58 202.45.84.59 Pacific SuperNet DNS 202.14.67.4 202.14.67.14 ","date":"2020-08-21","objectID":"/dns_list/:1:2","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#香港地区"},{"categories":["Network"],"content":" 台湾地区 名称 IP 地址（首选） IP 地址（备选） 中华电信 DNS 168.95.1.1 168.95.192.1 数位联合电信 DNS 139.175.252.16 139.175.55.244 台湾网路资讯 101.101.101.101 101.102.103.104 ","date":"2020-08-21","objectID":"/dns_list/:1:3","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#台湾地区"},{"categories":["Network"],"content":" 韩国 名称 IP 地址（首选） IP 地址（备选） KT olleh DNS 168.126.63.1 168.126.63.2 SK Broadband DNS 210.220.163.82 219.250.36.130 LG U+ DNS 164.124.101.2 203.248.252.2 164.124.107.9 203.248.242.2 ","date":"2020-08-21","objectID":"/dns_list/:1:4","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#韩国"},{"categories":["Network"],"content":" 美国 名称 IP 地址（首选） IP 地址（备选） Cloudflare DNS 1.1.1.1 1.0.0.1 Google DNS 8.8.8.8 8.8.4.4 IBM Quad9 9.9.9.9 149.112.112.112 DNS.SB 185.222.222.222 185.184.222.222 OpenDNS 208.67.222.222 208.67.220.220 V2EX DNS 199.91.73.222 178.79.131.110 HE Public DNS 74.82.42.42 66.220.18.42 ","date":"2020-08-21","objectID":"/dns_list/:1:5","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#美国"},{"categories":["Network"],"content":" 其他地区 名称 IP 地址（首选） IP 地址（备选） 俄罗斯 Yandex Public DNS 77.88.8.8 77.88.8.1 俄罗斯 SafeDNS 195.46.39.39 195.46.39.40 德国 DNS.WATCH Public DNS 84.200.69.80 84.200.70.40 瑞士 xiala.net Public DNS 77.109.148.136 77.109.148.137 丹麦 UncensoredDNS 91.239.100.100 89.233.43.71 荷兰 Freenom World Public DNS 80.80.80.80 80.80.81.81 ","date":"2020-08-21","objectID":"/dns_list/:1:6","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#其他地区"},{"categories":["Network"],"content":" IPv6","date":"2020-08-21","objectID":"/dns_list/:2:0","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#ipv6"},{"categories":["Network"],"content":" 国内 名称 IP 地址（首选） IP 地址（备选） 百度 2400:da00::6666 阿里 2400:3200::1 2400:3200:baba::1 CNNIC 2001:dc7:1000::1 下一代互联网北京研究中心 240C::6666 240C::6644 高校 名称 IP 地址（首选） IP 地址（备选） 北京邮电大学 2001:da8:202:10::36 2001:da8:202:10::37 上海交通大学 2001:da8:8000:1:202:120:2:100 2001:da8:8000:1:202:120:2:101 中科院网络信息中心 2001:cc0:2fff:1::6666 北京交通大学 2001:da8:205:2060::188 清华大学 2001:da8:ff:305:20c:29ff:fe1f:a92a 清华大学 TUNA 协会 2001:da8::666 北京科技大学 2001:da8:208:10::6 ","date":"2020-08-21","objectID":"/dns_list/:2:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#国内-1"},{"categories":["Network"],"content":" 国内 名称 IP 地址（首选） IP 地址（备选） 百度 2400:da00::6666 阿里 2400:3200::1 2400:3200:baba::1 CNNIC 2001:dc7:1000::1 下一代互联网北京研究中心 240C::6666 240C::6644 高校 名称 IP 地址（首选） IP 地址（备选） 北京邮电大学 2001:da8:202:10::36 2001:da8:202:10::37 上海交通大学 2001:da8:8000:1:202:120:2:100 2001:da8:8000:1:202:120:2:101 中科院网络信息中心 2001:cc0:2fff:1::6666 北京交通大学 2001:da8:205:2060::188 清华大学 2001:da8:ff:305:20c:29ff:fe1f:a92a 清华大学 TUNA 协会 2001:da8::666 北京科技大学 2001:da8:208:10::6 ","date":"2020-08-21","objectID":"/dns_list/:2:1","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#高校"},{"categories":["Network"],"content":" 台湾地区 名称 IP 地址（首选） IP 地址（备选） 中华电信 2001:b000:168::1 2001:b000:168::2 台湾网路资讯 2001:de4::101 2001:de4::102 ","date":"2020-08-21","objectID":"/dns_list/:2:2","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#台湾地区-1"},{"categories":["Network"],"content":" 美国 名称 IP 地址（首选） IP 地址（备选） GOOGLE 2001:4860:4860::8888 2001:4860:4860::8844 CloudFlare DNS 2606:4700:4700::1111 2606:4700:4700::1001 IBM 2620:fe::fe 2620:fe::9 Cisco OpenDNS 2620:0:ccc::2 2620:0:ccd::2 HE Public DNS 2001:470:20::2 2001:470:0:9d::2 Verisign Public DNS 2620:74:1b::1:1 2620:74:1c::2:2 Neustar Recursive DNS 2610:a1:1018::1 2610:a1:1019::1 ","date":"2020-08-21","objectID":"/dns_list/:2:3","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#美国-1"},{"categories":["Network"],"content":" 其他地区 名称 IP 地址（首选） IP 地址（备选） 俄罗斯 Yandex Public DNS 2a02:6b8::feed:0ff 2a02:6b8:0:1::feed:0ff 德国 DNS.WATCH Public DNS 2001:1608:10:25::1c04:b12f 2001:1608:10:25::9249:d69b 瑞士 xiala.net Public DNS 2001:1620:2078:136:: 2001:1620:2078:137:: 丹麦 UncensoredDNS 2001:67c:28a4:: 2a01:3a0:53:53:: ","date":"2020-08-21","objectID":"/dns_list/:2:4","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#其他地区-1"},{"categories":["Network"],"content":" 参考 [1] 全球免费公共 dns 解析服务器 ip 地址列表推荐 (解决无法上网/加速/防劫持) [2] 公共 dns 服务器 ip 地址 ","date":"2020-08-21","objectID":"/dns_list/:3:0","series":null,"tags":["DNS"],"title":"常用 DNS 服务器","uri":"/dns_list/#参考"},{"categories":["Network"],"content":" 网络瑞士军刀 —— NetCat ","date":"2020-08-19","objectID":"/netcat/:0:0","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#"},{"categories":["Network"],"content":" 什么是 NetCat简单来说，NetCat (nc) 是一个命令行工具，能够让你很方便、很灵活地操纵 传输层协议（TCP ＆ UDP） nc 可以在两台设备上面相互交互，即侦听模式/传输模式 nc 包含以下主要功能： Telnet 功能 获取 banner 信息 传输文本信息 传输文件 / 目录 加密传输文件，默认不加密 远程控制 加密所有流量 流媒体服务器 远程克隆硬盘 ","date":"2020-08-19","objectID":"/netcat/:1:0","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#什么是-netcat"},{"categories":["Network"],"content":" 使用 NetCat一般来说，nc 的命令行包括如下几个部分： nc 命令选项 主机 端口 ","date":"2020-08-19","objectID":"/netcat/:2:0","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#使用-netcat"},{"categories":["Network"],"content":" 命令选项 本文内容基于 OpenBSD 社区的变种（也叫 OpenBSD netcat，部分命令与原版有差异。 ） 下面列举了一些常用选项，更多选项参见 OpenBSD manual page 选项 是否有 “选项值” 说明 -h NO 输出 nc 的帮助 -v NO 在网络通讯时，显示详细的输出信息 -n NO 对命令行中的主机，不进行域名解析，如果主机是 IP 地址，需要用该选项 -p YES 指定端口号 -l NO 开启监听模式，nc 作为服务端，如不加，nc 默认作为客户端 -u NO 使用 UDP 协，如不加该选项，默认是 TCP 协议 -w YES 设置连接的超时间隔（N 秒） -q YES 让 nc 延时（N 秒）再退出 -z NO 开启 zero-I/O 模式，该选项仅用于端口扫描 -k NO 配合 -l 选项使用，可以重复接受客户端连接 -X YES 指定代理的类型 -x YES 以 IP:port 的格式指定代理 -d NO 后台模式 ","date":"2020-08-19","objectID":"/netcat/:2:1","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#命令选项"},{"categories":["Network"],"content":" 主机这部分可以没有，可以以 IP 地址 形式表示，也可以以 域名 形式表示。 ","date":"2020-08-19","objectID":"/netcat/:2:2","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#主机"},{"categories":["Network"],"content":" 端口这部分可以没有，可以是单个端口，可以是端口范围。 ","date":"2020-08-19","objectID":"/netcat/:2:3","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#端口"},{"categories":["Network"],"content":" 常用使用场景示例","date":"2020-08-19","objectID":"/netcat/:3:0","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#常用使用场景示例"},{"categories":["Network"],"content":" 测试某个远程主机的监听端口是否可达经常有这种需求，要判断某个主机的监听端口是否能连上。导致监听端口无法连接，通常有两种原因： 监听端口没开启 监听端口虽然开启，但是被防火墙阻拦了 对第 1 个原因，（如果你能在该主机上运行命令）可以直接用 netstat 这个命令查看监听端口是否开启；但对于第 2 个原因，netstat 就用不上了，这时候就可以用 nc 来帮你搞定。 用如下命令可以测试某个 IP 地址上的某个监听端口是否开启: nc -nv ip port 注：　默认情况下 nc 会等待很久，然后才告诉你连接失败。如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加 -w 选项，设置一个比较小的超时值。在下面的例子中，超时值设为 3 秒。 nc -nv -w 3 ip port ","date":"2020-08-19","objectID":"/netcat/:3:1","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#测试某个远程主机的监听端口是否可达"},{"categories":["Network"],"content":" 判断防火墙是否允许 or 禁止某个端口假设你正在配置防火墙规则，禁止 TCP 的 8080 端口对外监听。那么，你如何验证自己的配置生效？ 为了叙述方便，设想如下场景： 有两台主机 ——主机 C 充当客户端，主机 S 充当服务端。 然后要判断主机 S 上的防火墙是否会拦截其它主机对 8080 TCP 端口的连接。 在主机 S 上运行 nc，让它在 8080 端口，命令如下： nc -lv -p 8080 然后在 “主机 C” 上运行 nc，测试 “主机 S” 上的 8080 端口是否可达 注：　在默认情况下，nc 开启 listen 模式充当服务端，在接受第一次客户端连接之后，就会把监听端口关闭。如果你想要让 nc 始终监听模式，使之能重复接受客户端发起的连接，可以追加 -k 选项。 ","date":"2020-08-19","objectID":"/netcat/:3:2","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#判断防火墙是否允许-or-禁止某个端口"},{"categories":["Network"],"content":" 端口扫描下面这个命令，用来扫描的端口范围从 1 到 1024 nc -znv ip 1-1024 选项 -z 是指开启 zero-I/O 模式。该模式 nc 只判断某个监听端口是否能连上，连上后不与对端进行数据通讯。 **注：**端口扫描的时候，-v 选项会把成功/失败的结果统统打印出来。通常关注的都是 “扫描成功” 的那些端口。因此，可以用可以配合使用 grep 过滤一下，只打印扫出来的端口 nc -znv ip 1-1024 2\u003e\u00261 | grep succeeded 此外，由于 -v 选项产生的输出位于 stderr，上述命令中的 2\u003e\u00261 用来把 stderr 合并到 stdout。 另： nc 默认超时较大，导致扫描速度较慢。建议根据网络情况合理设置超时值，加快扫描速度。 ","date":"2020-08-19","objectID":"/netcat/:3:3","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#端口扫描"},{"categories":["Network"],"content":" 探测服务器类型和软件版本如果某个服务器运行了 SSH 服务端，那么用如下命令可以看出：该服务器的操作系统类型，以及 SSH server 的版本。 echo \"EXIT\" | nc -vq 5 -n ip 22 OR echo \"EXIT\" | nc -vq 5 domain 22 ","date":"2020-08-19","objectID":"/netcat/:3:4","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#探测服务器类型和软件版本"},{"categories":["Network"],"content":" 端口转发用 nc 进行端口转发，需要运行两个 nc 进程，一个充当服务端，另一个是客户端，然后用管道让把两个进程的标准输入输出``交叉配对。所谓的交叉配对就是——每一个 nc 进程的标准输出都对接到另一个 nc 进程的标准输入。如此一来，就可以完美地建立双向通讯。 步骤 1：创建命名管道 用下面这个简单的命令创建一个 “命名管道”，其名称叫做 nc_pipe mkfifo nc_pipe 步骤 2：同时启动两个 nc nc -l -p 1234 \u003c nc_pipe | nc 127.0.0.1 5678 \u003e nc_pipe 运行上述命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。 ","date":"2020-08-19","objectID":"/netcat/:3:5","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#端口转发"},{"categories":["Network"],"content":" 传输文件为了叙述方便，假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2 先在接收端 B 主机运行如下命令 nc -l -p port \u003e file2 然后在发送端 A 主机运行如下命令 nc ip port \u003c file1 两者端口号要相同 ","date":"2020-08-19","objectID":"/netcat/:3:6","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#传输文件"},{"categories":["Network"],"content":" 远程备份整个磁盘假设你要把 A 主机 /dev/sda 磁盘的原始数据整个复制到 B 主机的 /dev/sdb 磁盘。 先在接收端（B 主机）运行如下命令 nc -lp port | dd of=/dev/sdb 然后在发送端 A 主机运行如下命令 dd if=/dev/sda | nc ip port ","date":"2020-08-19","objectID":"/netcat/:3:7","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#远程备份整个磁盘"},{"categories":["Network"],"content":" 远程控制将 A 主机的 bash 发给 B 主机 A: nc -lp port -c bash B: nc ip port ","date":"2020-08-19","objectID":"/netcat/:3:8","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#远程控制"},{"categories":["Network"],"content":" 流媒体服务 A: cat test.mp4 | nc -lp port B: nc -nv ip port | mplayer -vo x11 -cache 4000 A 让 test.MP4 这个文件成为流的形式发送到 B，B 用 mplayer 播放，接收多少播放多少，指定缓存 4000bytes。 ","date":"2020-08-19","objectID":"/netcat/:3:9","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#流媒体服务"},{"categories":["Network"],"content":" 信息收集收集目标机上的进程信息 nc -l -p port \u003e ps.txt 将远程发送过来的内容保存在本地 Ps aux |nc -nv ip port -q 1 标准输入完成后 delay 一秒钟，会发送到侦听端 ","date":"2020-08-19","objectID":"/netcat/:3:10","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#信息收集"},{"categories":["Network"],"content":" 参考 [1] netcat manual page [2] 扫盲 netcat（网猫）的 N 种用法 —— 从 “网络诊断” 到 “系统入侵” [3] NetCat 使用指南 ","date":"2020-08-19","objectID":"/netcat/:4:0","series":null,"tags":["Software"],"title":"网络分析工具：NetCat","uri":"/netcat/#参考"},{"categories":["Network"],"content":" 理解 HTTP 协议，对称和非对称加密，了解 HTTPS 协议的工作原理 注：本文系全文转载，原文信息如下： 作者：猫尾博客 链接：https://cattail.me/tech/2015/11/30/how-https-works.html 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 读完本文，你能明白 什么是 HTTPS，TLS (SSL)，TLS 和 HTTPS 是什么关系 什么是证书和数字签名，它们是如何传递信任的 HTTPS 有什么样的功能，它是如何实现这样的功能的 ","date":"2020-08-16","objectID":"/how_https_works/:0:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#"},{"categories":["Network"],"content":" 简介HTTPS，也称作 HTTP over TLS。TLS 的前身是 SSL，TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。本文着重描述 TLS 协议的 1.2 版本 下图描述了在 TCP/IP 协议栈中 TLS (各子协议）和 HTTP 的关系 Credit: Kaushal Kumar Panday From: SSL Handshake and HTTPS Bindings on IIS 其中 Handshake protocol，Change Ciper Spec protocol 和 Alert protocol 组成了 SSL Handshaking Protocols。 HTTPS 和 HTTP 协议相比提供了: 数据完整性：内容传输经过完整性校验 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥 身份认证：第三方无法伪造服务端（客户端）身份 其中，数据完整性和隐私性由 TLS Record Protocol 保证，身份认证由 TLS Handshaking Protocols 实现。 ","date":"2020-08-16","objectID":"/how_https_works/:1:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#简介"},{"categories":["Network"],"content":" 总览使用 RSA 算法的 SSL 握手过程是这样的: Source: Keyless SSL: The Nitty Gritty Technical Details [明文] 客户端发送随机数 client_random 和支持的加密方式列表 [明文] 服务器返回随机数 server_random ，选择的加密方式和服务器证书链 [RSA] 客户端验证服务器证书，使用证书中的公钥加密 premaster secret 发送给服务端 服务端使用私钥解密 premaster secret 两端分别通过 client_random，server_random 和 premaster secret 生成 master secret，用于对称加密后续通信内容 ","date":"2020-08-16","objectID":"/how_https_works/:2:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#总览"},{"categories":["Network"],"content":" 证书（Digital certificate）那么什么是证书呢？ 证书信息 ","date":"2020-08-16","objectID":"/how_https_works/:2:1","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#证书digital-certificate"},{"categories":["Network"],"content":" 证书中包含了以下信息 证书信息：过期时间和序列号 所有者信息：姓名等 所有者公钥 为什么服务端要发送证书给客户端? 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。 ","date":"2020-08-16","objectID":"/how_https_works/:2:2","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#证书中包含了以下信息"},{"categories":["Network"],"content":" 客户端为什么要验证接收到的证书中间人攻击 客户端 \u003c------------ 攻击者 \u003c------------ 服务端 伪造证书 拦截请求 ","date":"2020-08-16","objectID":"/how_https_works/:2:3","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#客户端为什么要验证接收到的证书"},{"categories":["Network"],"content":" 客户端如何验证接收到的证书为了回答这个问题，需要引入数字签名 (Digital Signature)。 +---------------------+ | A digital signature | |(not to be confused | |with a digital | |certificate) | +---------+ +--------+ | is a mathematical |---- 哈希 ---\u003e| 消息摘要 |--- 私钥加密 ---\u003e| 数字签名 | |technique used | +---------+ +--------+ |to validate the | |authenticity and | |integrity of a | |message, software | |or digital document. | +---------------------+ 将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。 假设消息传递在 Bob，Susan 和 Pat 三人之间发生。Susan 将消息连同数字签名一起发送给 Bob，Bob 接收到消息后，可以这样验证接收到的消息就是 Susan 发送的 +---------------------+ | A digital signature | |(not to be confused | |with a digital | |certificate) | +---------+ | is a mathematical |---- 哈希 ---\u003e| 消息摘要 | |technique used | +---------+ |to validate the | | |authenticity and | | |integrity of a | | |message, software | 对 |or digital document. | 比 +---------------------+ | | | +---------+ +----------+ | 数字签名 |--- 公钥解密 ---\u003e| 消息摘要 | +---------+ +----------+ 当然，这个前提是 Bob 知道 Susan 的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给 Bob。 此时就引入了证书颁发机构（Certificate Authority，简称 CA），CA 数量并不多，Bob 客户端内置了所有受信任 CA 的证书。CA 对 Susan 的公钥（和其他信息）数字签名后生成证书。 Susan 将证书发送给 Bob 后，Bob 通过 CA 证书的公钥验证证书签名。 Bob 信任 CA，CA 信任 Susan 使得 Bob 信任 Susan，信任链（Chain Of Trust）就是这样形成的。 事实上，Bob 客户端内置的是 CA 的根证书 (Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。 ","date":"2020-08-16","objectID":"/how_https_works/:2:4","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#客户端如何验证接收到的证书"},{"categories":["Network"],"content":" TLS 协议TLS 协议包括 TLS Record Protocol 和 TLS Handshake Protocol。总览中的流程图仅涉及到 TLS Handshake Protocol。 ","date":"2020-08-16","objectID":"/how_https_works/:3:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#tls-协议"},{"categories":["Network"],"content":" TLS Record Protocol在 TLS 协议中，有四种子协议运行于 Record protocol 之上 Handshake protocol Alert protocol Change cipher spec protocol Application data protocol Record protocol 起到了这样的作用 在发送端：将数据（Record）分段，压缩，增加 MAC (Message Authentication Code) 和加密 在接收端：将数据（Record）解密，验证 MAC，解压并重组 值得一提的是，Record protocol 提供了数据完整性和隐私性保证，但 Record 类型（type）和长度（length）是公开传输的 Record Protocol 有三个连接状态 (Connection State)，连接状态定义了压缩，加密和 MAC 算法。所有的 Record 都是被当前状态（Current State）确定的算法处理的。 TLS Handshake Protocol 和 Change Ciper Spec Protocol 会导致 Record Protocol 状态切换。 empty state -------------------\u003e pending state ------------------\u003e current state Handshake Protocol Change Cipher Spec 初始当前状态（Current State）没有指定加密，压缩和 MAC 算法，因而在完成 TLS Handshaking Protocols 一系列动作之前，客户端和服务端的数据都是明文传输的；当 TLS 完成握手过程后，客户端和服务端确定了加密，压缩和 MAC 算法及其参数，数据（Record）会通过指定算法处理。 其中，Record 首先被加密，然后添加 MAC（message authentication code）以保证数据完整性。 ","date":"2020-08-16","objectID":"/how_https_works/:3:1","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#tls-record-protocol"},{"categories":["Network"],"content":" TLS Handshaking ProtocolsHandshakeing protocols 包括 Alert Protocol，Change Ciper Spec Protocol 和 Handshake protocol。本文不会详细介绍 Alert Protocol 和 Change Ciper Spec Protocol。 使用 RSA 算法的握手过程是这样的（已在总览中提到） Source: Keyless SSL: The Nitty Gritty Technical Details 客户端和服务端在握手 hello 消息中明文交换了 client_random 和 server_random ，使用 RSA 公钥加密传输 premaster secret ，最后通过算法，客户端和服务端分别计算 master secret。其中，不直接使用 premaster secret 的原因是：保证 secret 的随机性不受任意一方的影响。 除了使用 RSA 算法在公共信道交换密钥，还可以通过 Diffie–Hellman 算法。Diffie–Hellman 算法的原理是这样的 By Original schema: A.J. Han Vinck, University of Duisburg-Essen SVG version: Flugaal [Public domain], via Wikimedia Commons 使用 Diffie–Hellman 算法交换 premaster secret 的流程 Source: Keyless SSL: The Nitty Gritty Technical Details ","date":"2020-08-16","objectID":"/how_https_works/:3:2","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#tls-handshaking-protocols"},{"categories":["Network"],"content":" 小结TLS Handshaking Protocols 协商了 TLS Record Protocol 使用的算法和所需参数，并验证了服务端身份； TLS Record Protocol 在协商后保证应用层数据的完整性和隐私性。 TLS Handshaking Protocol 的核心是在公开信道上传递 premaster secret。 ","date":"2020-08-16","objectID":"/how_https_works/:4:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#小结"},{"categories":["Network"],"content":" Q\u0026A","date":"2020-08-16","objectID":"/how_https_works/:5:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#qa"},{"categories":["Network"],"content":" 为什么传输内容不直接使用非对称加密？因为性能限制。 ","date":"2020-08-16","objectID":"/how_https_works/:5:1","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#为什么传输内容不直接使用非对称加密"},{"categories":["Network"],"content":" HTTPS 能保证正常连接？不能。 引用 There are a number of ways in which a man-in-the-middle attacker can attempt to make two entities drop down to the least secure method they support. 攻击者甚至可以直接丢弃双方的数据包 ","date":"2020-08-16","objectID":"/how_https_works/:5:2","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#https-能保证正常连接"},{"categories":["Network"],"content":" 服务端如何验证客户端身份？通过 Client Certificate 引用 This message conveys the client’s certificate chain to the server; the server will use it when verifying the CertificateVerify message (when the client authentication is based on signing) or calculating the premaster secret (for non-ephemeral Diffie- Hellman). The certificate MUST be appropriate for the negotiated cipher suite’s key exchange algorithm, and any negotiated extensions. ","date":"2020-08-16","objectID":"/how_https_works/:5:3","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#服务端如何验证客户端身份"},{"categories":["Network"],"content":" Alert protocol 有什么作用？Closure Alerts：防止 Truncation Attack 引用 In a truncation attack, an attacker inserts into a message a TCP code indicating the message has finished, thus preventing the recipient picking up the rest of the message. To prevent this, SSL from version v3 onward has a closing handshake, so the recipient knows the message has not ended until this has been performed. Error Alerts：错误处理 ","date":"2020-08-16","objectID":"/how_https_works/:5:4","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#alert-protocol-有什么作用"},{"categories":["Network"],"content":" master secret 是如何计算的 master_secret = PRF (pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47]; ","date":"2020-08-16","objectID":"/how_https_works/:5:5","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#master-secret-是如何计算的"},{"categories":["Network"],"content":" 加密，压缩和 MAC 算法参数是如何计算的Handshaking Protocols 使得客户端和服务端交换了三个参数：client_random，server_random 和 master_secret，通过以下算法生成算法所需要的参数 To generate the key material, compute key_block = PRF (SecurityParameters.master_secret, \"key expansion\", SecurityParameters.`server_random` + SecurityParameters.`client_random`); until enough output has been generated. Then, the key_block is partitioned as follows: client_write_MAC_key [SecurityParameters.mac_key_length] server_write_MAC_key [SecurityParameters.mac_key_length] client_write_key [SecurityParameters.enc_key_length] server_write_key [SecurityParameters.enc_key_length] client_write_IV [SecurityParameters.fixed_iv_length] server_write_IV [SecurityParameters.fixed_iv_length] 引用 The master secret is expanded into a sequence of secure bytes, which is then split to a client write MAC key, a server write MAC key, a client write encryption key, and a server write encryption key 使用 Diffie-Hellman 算法的 TLS 握手细节 Source: https://cipherstuff.wordpress.com/ ","date":"2020-08-16","objectID":"/how_https_works/:5:6","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#加密压缩和-mac-算法参数是如何计算的"},{"categories":["Network"],"content":" 拓展阅读 Keyless Let’s Encrypt Session resume 证书 Revoke ","date":"2020-08-16","objectID":"/how_https_works/:6:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#拓展阅读"},{"categories":["Network"],"content":" 参考 [1] TLS1.2 规范 [2] PKI 规范 [3] 证书和数字签名 [4] TLS Handshake ","date":"2020-08-16","objectID":"/how_https_works/:7:0","series":null,"tags":["HTTPS"],"title":"HTTPS 工作原理","uri":"/how_https_works/#参考"},{"categories":["Web"],"content":" 如何在互联网上高效地找到自己想要的东西？ 搜索引擎方便了我们搜索资料，但是由于各种垃圾内容、网站地出现，实际上，搜索过程往往是十分低效的（特别是使用中文搜索）。因此，值得学习一些提升搜索效率必要的小技巧。 废话不多说，直接分类讲解： ","date":"2020-08-14","objectID":"/how_to_search/:0:0","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#"},{"categories":["Web"],"content":" 搜索语法首先总结一下常用的语法表达式： operator description “phrase” 结果必须包含 “phrase” - phrase 结果排除 phrase A AND B A 和 B 必须同时包含 A OR B 必须包括 A 和 B 之一（或两者） site:example.com 在网站中搜索 filetype:jpg 结果必须包含类型 .jpg ","date":"2020-08-14","objectID":"/how_to_search/:1:0","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#搜索语法"},{"categories":["Web"],"content":" 实例展示","date":"2020-08-14","objectID":"/how_to_search/:2:0","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#实例展示"},{"categories":["Web"],"content":" 网页查找网站内的特定页面（例如：本网站上的 Trick 标签） site:www.techkoala.top Trick 查找必须在标题文本中包含短语的特定页面 allintitle:\"Github\" site:techkoala.com 查找类似网站（仅谷歌搜索） related:techkoala.com 您可以将运算符链接在一起 （例如：在 Url 中查找具有安全性或错误赏金） inurl:security OR inurl:bug-bounty OR site:hackerone.com) + \"techkoala\" 您可以限制为某些顶级域（例如：教师列表） site:.edu filetype:xls inurl:\"email.xls\" ","date":"2020-08-14","objectID":"/how_to_search/:2:1","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#网页"},{"categories":["Web"],"content":" Email查找 Gmail 帐户 username \"@gmail.com\" 查找工作帐户（您需要先找到他们的域） username \"@techkoala.top\" 模糊搜索的情况下，可以尝试猜测电子邮件的格式 \"username\" \"@\" \".com\" 在网站上查找电子邮件 site:gumroad.com intext:\"@gumroad.com\" 在网页上查找您访问的每封电子邮件，适用于每个网站，将其注入 Chrome 开发工具 var elems = document.body.getElementsByTagName (\"*\"); var re = new RegExp (\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\"); for (var i = 0; i \u003c elems.length; i++) { if (re.test (elems [i].innerHTML)) { console.log (elems [i].innerHTML); } } 这将记录找到的每封电子邮件，而无需扫描整个页面。 ","date":"2020-08-14","objectID":"/how_to_search/:2:2","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#email"},{"categories":["Web"],"content":" 文件查找电子表格 filetype:csv OR filetype:xlsx OR filetype:xls OR filetype:xltx OR filetype:xlt OR inurl:airtable.com/universe/ 查找谷歌文档和谷歌表格 site:docs.google.com \"techkoala\" ","date":"2020-08-14","objectID":"/how_to_search/:2:3","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#文件"},{"categories":["Web"],"content":" SEO在锚文本中查找具有特定关键字的网站 inanchor:\"cyber security\" 研究标题中包含特定关键字的博客帖子 inposttitle:\"diy slime\" 查找反向链接 (例如：链接到特定博客帖子的其他网站)。注意：链接运算符 link 现在已弃用 intext:intercom.com/intercom-api-reference/reference 使用通配符运算符查找关键字排列 * design tools 使用给定的 widget 查找公司 intext:\"Powered by Intercom\" -site:intercom.com ","date":"2020-08-14","objectID":"/how_to_search/:2:4","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#seo"},{"categories":["Web"],"content":" 待更新…","date":"2020-08-14","objectID":"/how_to_search/:0:0","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#待更新"},{"categories":["Web"],"content":" 参考 [1] dorking (how to find anything on the Internet) [2] Google Search Operators: The Complete List (42 Advanced Operators) ","date":"2020-08-14","objectID":"/how_to_search/:1:0","series":null,"tags":["Trick"],"title":"如何高效搜索？","uri":"/how_to_search/#参考"},{"categories":["Web"],"content":" 搭建自己的在线 EPUB 阅读器 ","date":"2020-08-12","objectID":"/reader/:0:0","series":null,"tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/#"},{"categories":["Web"],"content":" 什么是 Netlify引用 Netlify 官网的介绍： 引用 Netlify is a unified platform that automates your code to create high-performant, easily maintainable sites and web apps. 也就是说，Netlify 是一个提供静态网站托管的服务。它提供 CI 服务，能够将托管在 GitHub，GitLab 等网站上代码生成静态网站进行展示。类似于 Github Pages，不过功能更加丰富。 ","date":"2020-08-12","objectID":"/reader/:1:0","series":null,"tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/#什么是-netlify"},{"categories":["Web"],"content":" Koodo ReaderKoodo Reader 是一个基于 React 和 Electron 开发的 Epub 阅读器。 Koodo Reader 首页 提供以下功能： 📝 强大笔记和翻译功能，学习事半功倍 🚩 使用书架来为你的图书分类 🌎 支持 Windows ， MacOS 和 网页版 🖥 绑定 OneDrive， Google Drive， Dropbox 等网盘，实现数据的多端同步 💻 您所有的数据都支持导入导出 更多详情请点击 Koodo Reader 官网 查看。 ","date":"2020-08-12","objectID":"/reader/:2:0","series":null,"tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/#koodo-reader"},{"categories":["Web"],"content":" 搭建 首先进入 Netlify 官网，点击注册，这里我选择直接使用 Github 登录，当然，你也可以选择其他方式。 Netlify 注册 注册登陆后，进入首页，点击右上角的 New Site from Git ，创建一个新的站点。 创建新站点 接下来，点击下方的 Github 进行授权，这里会弹出一个新的窗口，让你授权 Netlify 访问你的 Github 账户，完成授权后进去下一步。 使用Github 创建新站点 这一步会让你选择你将用于生成站点的库，这里我已经提前 Fork troyeguo 的 Koodo Reader 库，所以直接选择即可。 选择相应的 Repo 接着，配置 Build 选项。在该项目的部署中，需要修改 Build name \u003e yarn build，Publish directory \u003e build/ ，其他保持默认即可。（如果配置其他项目，这里的参数可能不同，请参考具体项目的指导说明） 配置 到这里，已经完成了整个部署工作，等待 Netlify 构建完成即刻。 配置 Netlify 会给你默认分配一个二级域名用于访问，当然也支持自定义域名，这里我绑定了自己域名。除了在此处绑定外，还需要配置 DNS 等等，这个请自行完成。（由于搭建博客时，已经完成了相应设置，因此，我直接在 Cloudfalre 新建了一个 CNAME 指向 Netlify 给我的域名就好了） 配置 大功告成，来这里看看书吧。 ","date":"2020-08-12","objectID":"/reader/:3:0","series":null,"tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/#搭建"},{"categories":["Web"],"content":" 后续如果需要对网站进行更新，只需要关注你的 Github Repo 即可。每次 commit 之后，Netlify 都会自动拉取更新并生成。 ","date":"2020-08-12","objectID":"/reader/:4:0","series":null,"tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/#后续"},{"categories":["Web"],"content":" 参考 [1] koodo-reader ","date":"2020-08-12","objectID":"/reader/:5:0","series":null,"tags":["EPUB","Software"],"title":"利用 Netlify 搭建 Koodo Reader","uri":"/reader/#参考"},{"categories":["Network"],"content":" TCP、UDP 和 SCTP 的终极速度测试工具 ","date":"2020-08-07","objectID":"/iperf/:0:0","series":null,"tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/#"},{"categories":["Network"],"content":" 什么是 iPerfiPerf 是一个用于测量网络最大带宽的小工具。iPerf 可以测试最大 TCP 和 UDP 带宽性能，具有多种参数和 UDP 特性，可以根据需要调整，可以报告带宽、延迟抖动和数据包丢失。对于每个测试，它都会报告带宽，丢包和其他参数。 现在的版本也称 iPerf3，这是对 NLANR/DAST 开发的原始版本的重新设计。 注意：iPerf3 与此前版本的 iPerf 不兼容。 ","date":"2020-08-07","objectID":"/iperf/:1:0","series":null,"tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/#什么是-iperf"},{"categories":["Network"],"content":" 安装 iPerfiPerf3 官方仅支持 CentOS Linux，FreeBSD 和 macOS，但实际上，官网提供了主流系统的预编译文件。（包括 Windows、Android、iOS、Ubuntu、Arch Linux 等） 类 UNIX 系统直接使用包管理进行安装即可，例如： $ sudo apt install iperf3 ","date":"2020-08-07","objectID":"/iperf/:2:0","series":null,"tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/#安装-iperf"},{"categories":["Network"],"content":" 使用 iPerf首先，介绍服务端和客户端共有的参数： -p, --port n 服务器用于侦听和客户端连接的服务器端口，两者应该相同，默认值为 5201 --cport n 指定客户端端口 -f, --format 用于指定单位显示格式，支持 'k' = Kbits/sec 'K' = KBytes/sec 'm' = Mbits/sec 'M' = MBytes/sec，默认为自适应格式 -i, --interval n 设置测试信息报告之间的间隔时间（以秒为单位）。如果为零，则不打印任何定期报告。默认值为零。 -F, --file name 客户端：从文件读取并写入网络，而不是使用随机数据；服务器端：从网络读取并写入文件，而不是丢弃数据。 -A, --affinity 如果可以，设置 CPU 关联（仅限 Linux 和 FreeBSD）。 -B, --bind host 绑定到主机。对于客户端，这将设置出站接口。对于服务器，这将设置传入接口。这只适用于具有多个网络接口的多宿主主机。 -V, --verbose 提供更详细的输出 -J, --json 以 JSON 格式输出 --logfile file 输出到日志文件 --d, --debug 发出调试输出 -v, --version 输出版本信息 -h, --help 输出帮助信息 服务端特有参数： -s, --server 在服务器模式下运行 iPerf（一次只允许一个 iPerf 连接） -D, --daemon 将服务器作为守护进程在后台运行 -I, --pidfilefile 使用进程ID编写文件，这在作为守护进程运行时非常有用 客户端特有参数: -c, --client host 在客户端模式下运行 iPerf --sctp 使用 SCTP 而不是 TCP -u, --udp 使用 UDP 而不是 TCP -b, --bandwidth 将目标带宽设置为 nbits/sec（对于 UDP 默认为 1 Mbit/sec，对于 TCP 为无限制）。如果有多个流（-P 标志），则带宽限制将分别应用于每个流。您还可以在带宽说明符中添加一个 “/” 和一个数字。这称为 “突发模式”。 它会发送给定数量的数据包而不会暂停，即使该数据包暂时超过了指定的带宽限制 -t, --time 传输的时间（以秒为单位）。iPerf 通常通过在 t 时间内重复发送 len 长度的字节数组来工作。默认值为 10 秒 -n, --num 要传输的缓冲区数量。通常，iPerf 只会发送 10 秒。-n 选项覆盖此设置，并发送 len 长度字节数组 n 次，无论需要多长时间 -k, --blockcount 要传输的块（数据包）数 -l, --length 读取或写入的缓冲区的长度，iPerf 通过多次写入 len 个字节的数组来工作。TCP 的默认值为 128 KB，UDP 的默认值为 8 KB。 -P, --parallel 与服务器同时建立的连接数，默认值为 1 -R, --reverse 以反向模式运行（服务器发送，客户端接收） -w, --window 将套接字缓冲区大小设置为指定值。对于 TCP，这将设置 TCP 窗口大小（这将发送到服务器并在该侧使用） -M, --set-mss 尝试设置 TCP 最大段大小（MSS）。MSS 通常是 MTU-TCP/IP 标头的 40 个字节。对于以太网，MSS 为 1460 字节（1500 字节 MTU） -N, --no-delay 设置 “TCP no delay” 选项，禁用 Nagle 的算法。通常，仅对交互式应用程序（如 telnet）禁用此功能 -4, --version4 仅使用 IPv4. -6, --version4 仅使用 IPv6. -S, --tos 传出数据包的服务类型。(许多路由器会忽略TOS字段。）可以使用十六进制值（0x）作为前缀，使用八进制数（0）作为前缀，或者使用十进制来指定值。 例如，'0x10'十六进制='020'八进制='16'十进制。RFC 1349中指定的TOS编号为： IPTOS_LOWDELAY minimize delay 0x10 IPTOS_THROUGHPUT maximize throughput 0x08 IPTOS_RELIABILITY maximize reliability 0x04 IPTOS_LOWCOST minimize cost 0x02 -L, --flowlabel 设置 IPv6 流标签（当前仅在 Linux 上受支持） -Z, --zerocopy 使用 “零拷贝” 方法发送数据，如 sendfile（2），而不是通常的 write（2）。这样可以占用更少的 CPU -O, --omit 省略测试的前 n 秒，以跳过 TCP TCP 慢启动周期 -T, --title 为每个输出行添加此字符串前缀 -C, --linux-congestion 设置拥塞控制算法 (仅适用于 iPerf 3.1 的 Linux 和 FreeBSD)。 注意 从客户端专有选项可以看出，iPerf 默认测试的是从客户端发送到服务端，相对于客户端来说，测试就是上行链路的带宽，对于一般参考意义更大的下行链路需要加上 -R 选项。 常用启用参数： 服务端 $ iperf3 -s -p 12345 -i 1 客户端 $ iperf3 -c 192.168.1.43 -p 12345 -i 1 -t 20 -w 100k iPerf 使用实例 ","date":"2020-08-07","objectID":"/iperf/:3:0","series":null,"tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/#使用-iperf"},{"categories":["Network"],"content":" 参考 [1] iPerf user docs [2] iPerf Github ","date":"2020-08-07","objectID":"/iperf/:4:0","series":null,"tags":["Software"],"title":"网络测试工具：iPerf","uri":"/iperf/#参考"},{"categories":["Software"],"content":" SCP 的继承者 ","date":"2020-08-06","objectID":"/sftp/:0:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/#"},{"categories":["Software"],"content":" 什么是 SFTP首先需要明确的是，SFTP（SSH File Transfer Protocol）不是运行在 SSH 上的 FTP，而是由 IETF（Internet Engineering Task Force）工作组设计的新协议，将其作为 SSH 2.0 版的扩展，提供安全的文件传输功能。因此，没有单独的 SFTP 端口，而是使用普通的 SSH 端口。协议本身不提供身份验证和安全性，而是期望底层协议提供。 与仅允许文件传输的 SCP 协议相比，SFTP 协议允许对远程文件进行一系列操作，这使其更像远程文件系统协议。SFTP 客户端还支持包括恢复中断的传输，目录列表和远程文件删除等功能。此外，上传的文件可以与它们的基本属性相关联，例如时间戳。相比普通 FTP 协议，这是一项优势。 尽管 SFTP 最常在 Unix 平台上实现，但 SFTP 在主流平台都可用。 引用 有关 SFTP 详细草案参见 draft-ietf-secsh-filexfer-02 ","date":"2020-08-06","objectID":"/sftp/:1:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/#什么是-sftp"},{"categories":["Software"],"content":" 使用 SFTP sftp 选项 参数 ","date":"2020-08-06","objectID":"/sftp/:2:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/#使用-sftp"},{"categories":["Software"],"content":" 选项 -B：指定传输文件时缓冲区的大小； -l：使用 ssh 协议版本 1； -b：指定批处理文件； -C：使用压缩； -o：指定 ssh 选项； -F：指定 ssh 配置文件； -R：指定一次可以容忍多少请求数； -v：升高日志等级。 ","date":"2020-08-06","objectID":"/sftp/:2:1","series":null,"tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/#选项"},{"categories":["Software"],"content":" 参数目标主机：指定 SFTP 服务器 IP 地址或者主机名。 ","date":"2020-08-06","objectID":"/sftp/:2:2","series":null,"tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/#参数"},{"categories":["Software"],"content":" 参考 [1] SSH File Transfer Protocol [2] SFTP Command ","date":"2020-08-06","objectID":"/sftp/:3:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：SFTP","uri":"/sftp/#参考"},{"categories":["Software"],"content":" SCP 的另一个绝佳替选 ","date":"2020-08-05","objectID":"/rsync/:0:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#"},{"categories":["Software"],"content":" 什么是 rsyncrsync (remote synchronize) 是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。 rsync 是类 Unix 系统下的数据镜像备份工具。它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。 rsync 中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync 可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。 rsync 默认监听 TCP 端口 873，以原生 rsync 传输协议或者透过远程 shell 如 RSH 或者 SSH 提供文件。SSH 模式下，rsync 客户端运行程序必须同时在本地和远程机器上安装。 ","date":"2020-08-05","objectID":"/rsync/:1:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#什么是-rsync"},{"categories":["Software"],"content":" rsync 算法 信息 此部分内容转载 RSYNC 的核心算法 rsync 的算法如下：（假设源文件名为 fileSrc，目的文件叫 fileDst） ","date":"2020-08-05","objectID":"/rsync/:2:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#rsync-算法"},{"categories":["Software"],"content":" 分块 Checksum 算法首先，我们会把 fileDst 的文件平均切分成若干个小块，比如每块 512 个字节，然后对每块计算两个 checksum，一个叫 rolling checksum，是弱 checksum，32 位的 checksum，其使用的是 Mark Adler 发明的 adler-32 算法，另一个是强 checksum，128 位的，以前用 md4，现在用 md5。为什么要这样？因为若干年前的硬件上跑 md4 的算法太慢了，所以，需要一个快算法来鉴别文件块的不同，但是弱的 adler-32 算法碰撞概率太高了，所以我们还要引入强的 checksum 算法以保证两文件块是相同的。也就是说，弱的 checksum 是用来区别不同，而强的是用来确认相同。 ","date":"2020-08-05","objectID":"/rsync/:2:1","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#分块-checksum-算法"},{"categories":["Software"],"content":" 传输算法同步目标端会把 fileDst 的一个 checksum 列表传给同步源，这个列表里包括了三个东西，rolling checksum (32bits)，md5 checksume (128bits)，文件块编号。同步源机器拿到了这个列表后，会对 fileSrc 做同样的 checksum，然后和 fileDst 的 checksum 做对比，这样就知道哪些文件块改变了。 但是 如果我 fileSrc 这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和 fileDst 这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？ 如果这个 checksum 列表特别长，而两边相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？ ","date":"2020-08-05","objectID":"/rsync/:2:2","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#传输算法"},{"categories":["Software"],"content":" Checksum 查找算法同步源端拿到 fileDst 的 checksum 数组后，会把这个数据存到一个 hash table 中，用 rolling checksum 做 hash，以便获得 O(1) 时间复杂度的查找性能。这个 hash table 是 16 bits 的，所以，hash table 的尺寸是 2 的 16 次方，对 rolling checksum 的 hash 会被散列到 0 到 $ 2^{16} – 1 $ 中的某个整数值。 ","date":"2020-08-05","objectID":"/rsync/:2:3","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#checksum-查找算法"},{"categories":["Software"],"content":" 比对算法 取 fileSrc 的第一个文件块（我们假设的是 512 个长度），也就是从 fileSrc 的第 1 个字节到第 512 个字节，取出来后做 rolling checksum 计算。计算好的值到 hash 表中查询。 如果查到了，说明发现在 fileDst 中有潜在相同的文件块，于是就再比较 · 的 checksum，因为 rolling checksume 太弱了，可能发生碰撞。于是还要算 md5 的 128 bits 的 checksum，这样一来，我们就有 $2^{-(32+128)} = 2^{-160} $ 的概率发生碰撞，这小到可以忽略。如果 rolling checksum 和 md5 checksum 都相同，那就可以说明在 fileDst 中有相同的块，记下这一块在 fileDst 下的文件编号。 如果 fileSrc 的 rolling checksum 没有在 hash table 中找到，那就不用算 md5 checksum 了。表示这一块中有不同的信息。总之，只要 rolling checksum 或 md5 checksum 其中有一个在 fileDst 的 checksum hash 表中找不到匹配项，那么就会触发算法对 fileSrc 的 rolling 动作。于是，算法会住后 step 1 个字节，取 fileSrc 中字节 2-513 的文件块要做 checksum，然后继续第一步 – 这就是为什么叫 rolling checksum 。 这样，我们就可以找出 fileSrc 相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。 ","date":"2020-08-05","objectID":"/rsync/:2:4","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#比对算法"},{"categories":["Software"],"content":" Rolling Checksum 算法rolling checksum 算法也叫 Rabin-Karp 算法，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它用来解决多模式串匹配问题。其最大的精髓是，当往后面 step 1 个字符的时候，不用全部重新计算所有的 checksum，也就是说，从 [0, 512] rolling 到 [1, 513] 时，不需要重新计算从 1 到 513 的 checksum，而是重用 [0，512] 的 checksum 直接算出来。 其公式可以表示为： hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0 其中的 b 是一个常数基数，在 Rabin-Karp 算法中，一般取值为 256。 于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了： hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1) + t[m] * b ^0 rsync 算法示意 最终，得到的数据组可以想象为 BT 协议下载 torrent ：一些文件块已下载（匹配上），其他的文件块还未下载（未匹配上）。然后，同步端将这些未匹配上的文件打上标号发送，目的端根据标号重组文件就完成了同步。 ","date":"2020-08-05","objectID":"/rsync/:3:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#rolling-checksum-算法"},{"categories":["Software"],"content":" 使用 rsync rsync [OPTION]... SRC DEST rsync [OPTION]... SRC [USER@] host:DEST rsync [OPTION]... [USER@] HOST:SRC DEST rsync [OPTION]... [USER@] HOST::SRC DEST rsync [OPTION]... SRC [USER@] HOST::DEST rsync [OPTION]... rsync://[USER@] HOST [:PORT]/SRC [DEST] 对应于以上六种命令格式，rsync 有六种不同的工作模式： 拷贝本地文件。当 SRC 和 DES 路径信息都不包含有单个冒号 “:” 分隔符时就启动这种工作模式。如：rsync -a /data/backup 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 DST 路径地址包含单个冒号 “:” 分隔符时启动该模式。如：rsync -avz *.c foo:src 使用一个远程 shell 程序 (如 rsh、ssh) 来实现将远程机器的内容拷贝到本地机器。当 SRC 地址路径包含单个冒号 “:” 分隔符时启动该模式。如：rsync -avz foo:src/bar/data 从远程 rsync 服务器中拷贝文件到本地机。当 SRC 路径信息包含 “::” 分隔符时启动该模式。如：rsync -av root@192.168.78.192::www /databack 从本地机器拷贝文件到远程 rsync 服务器中。当 DST 路径信息包含 “::” 分隔符时启动该模式。如：rsync -av /databack root@192.168.78.192::www 列出远程主机的文件列表。这类似于 rsync 传输，不过只要在命令中省略掉本地机信息即可。如：rsync -v rsync://192.168.78.192/www 可用选项如下： -v, --verbose 详细模式输出。 -q, --quiet 精简输出模式。 -C, --cvs-exclude 使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。 -c, --checksum 打开校验开关，强制对文件传输进行校验。 -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 - rlptgoD。 -r, --recursive 对子目录以递归模式处理。 -R, --relative 使用相对路径信息。 -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为～filename。可以使用 --suffix 选项来指定不同的备份文件前缀。 -u, --update 仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。 -l, --links 保留软链结。 -L, --copy-links 想对待常规文件一样处理软链结。 -H, --hard-links 保留硬链结。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 -p, --perms 保持文件权限。 -o, --owner 保持文件属主信息。 -g, --group 保持文件属组信息。 -D, --devices 保持设备文件信息。 -t, --times 保持文件时间信息。 -S, --sparse 对稀疏文件进行特殊处理以节省 DST 的空间。 -T --temp-dir=DIR 在 DIR 中创建临时文件。 -n, --dry-run 现实哪些文件将被传输。 -w, --whole-file 拷贝文件，不进行增量检测。 -x, --one-file-system 不要跨越文件系统边界。 -B, --block-size=SIZE 检验算法使用的块尺寸，默认是 700 字节。 -e, --rsh=command 指定使用 rsh、ssh 方式进行数据同步。 -P 等同于 --partial。 -z, --compress 对备份的文件在传输时进行压缩处理。 -h, --help 显示帮助信息。 --backup-dir 将备份文件 (如～filename) 存放在在目录下。 -suffix=SUFFIX 定义备份文件前缀。 --copy-unsafe-links 仅仅拷贝指向 SRC 路径目录树以外的链结。 --safe-links 忽略指向 SRC 路径目录树以外的链结。 --rsync-path=PATH 指定远程服务器上的 rsync 命令所在路径信息。 --existing 仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。 --delete 删除那些 DST 中 SRC 没有的文件。 --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现 IO 错误也进行删除。 --max-delete=NUM 最多删除 NUM 个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组 id 匹配为用户名和组名。 --timeout=time ip 超时时间，单位为秒。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为 0。 --compare-dest=DIR 同样比较 DIR 中的文件来决定是否需要备份。 --progress 显示备份过程。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除 FILE 中指定模式的文件。 --include-from=FILE 不排除 FILE 指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的 rsyncd.conf 文件。 --port=PORT 指定其他的 rsync 服务端口。 --blocking-io 对远程 shell 使用阻塞 IO。 -stats 给出某些文件的传输状态。 --progress 在传输时现实传输过程。 --log-format=formAT 指定日志文件格式。 --password-file=FILE 从 FILE 中得到密码。 --bwlimit=KBPS 限制 I/O 带宽，KBytes per second。 ","date":"2020-08-05","objectID":"/rsync/:4:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#使用-rsync"},{"categories":["Software"],"content":" 参考 [1] The rsync algorithm [2] RSYNC 的核心算法 [3] rsync wikipedia [4] rsync command ","date":"2020-08-05","objectID":"/rsync/:5:0","series":null,"tags":["Software","Linux"],"title":"文件传输系列：rsync","uri":"/rsync/#参考"},{"categories":["Git"],"content":" 最常用的 Git Log 技巧令总结 ","date":"2020-08-01","objectID":"/git_log/:0:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#"},{"categories":["Git"],"content":" 概览提交历史 $ git log —oneline 该命令帮助您以更清晰的方式查看提交。每个提交仅显示为一行，并且只有最少量的信息，比如提交哈希、提交消息。 ","date":"2020-08-01","objectID":"/git_log/:1:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#概览提交历史"},{"categories":["Git"],"content":" 显示详细更改信息 $ git log -p 此命令会显示更新的详细更改信息，方便查阅。 ","date":"2020-08-01","objectID":"/git_log/:2:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#显示详细更改信息"},{"categories":["Git"],"content":" 根据时间筛选 $ git log --after=\"2020-15-05\" $ git log --after=\"2020-15-05\" --before=\"2020-25-05\" $ git log --after=\"yesterday\" // 显示昨天的提交 $ git log --after=\"today\" // 显示今天的提交 $ git log --before=\"10 day ago\" // 显示最近十天的提交 $ git log --after=\"1 week ago\" // 显示上周以来的提交 $ git log --after=\"2 month ago\" // 显示近两个月的提交 上述命令将按给定的时间段过滤出提交。 例如，--after 将仅筛选给定时间段之后的提交，而 --before 将仅筛选给定时间段之前的提交。 ","date":"2020-08-01","objectID":"/git_log/:3:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#根据时间筛选"},{"categories":["Git"],"content":" 根据作者筛选 $ git log --author=\"techkoala\" 该命令会显示由 techkoala 提交的更改。当然，可以结合上面介绍的命令，进行更加精确的筛选，例如： $ git log --after=\"1 week ago\" --author=\"techkoala\" -p ","date":"2020-08-01","objectID":"/git_log/:4:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#根据作者筛选"},{"categories":["Git"],"content":" 根据 log 信息筛选 $ git log --grep=\"ISSUE-43560\" 需要注意的是，上述筛选字段区分大小写，如果需要不区分，请加上 -i 选项。 此外，还支持正则表达式： $ git log -i --grep=\"issue-43560\\|issue-89786\" ","date":"2020-08-01","objectID":"/git_log/:5:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#根据-log-信息筛选"},{"categories":["Git"],"content":" 根据文件筛选 $ git log Git_Log.md 该命令显示针对特定文件的的提交历史。 当然，可以传入多个文件： $ git log Git_Log.md Github_Issue.md 同样的，结合别的命令可以做出更精确的筛选，例如： $ git log -i --grep=\"fix \" Git_Log.md Github_Issue.md ","date":"2020-08-01","objectID":"/git_log/:6:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#根据文件筛选"},{"categories":["Git"],"content":" 根据文件内容筛选 $ git log -S\"function login()\" 上述命令帮你在源代码中搜索已添加到提交历史记录中的特定字符串。同样的，加上 -i 可以不区分大小写。 ","date":"2020-08-01","objectID":"/git_log/:7:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#根据文件内容筛选"},{"categories":["Git"],"content":" 仅显示合并提交 $ git log --merges 该命令显示当前分支上合并的提交。 ","date":"2020-08-01","objectID":"/git_log/:8:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#仅显示合并提交"},{"categories":["Git"],"content":" 显示不同分支间的区别 $ git log master..develop 该命令将显示所有来自 develop 但不在 master 分支的提交。 ","date":"2020-08-01","objectID":"/git_log/:9:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#显示不同分支间的区别"},{"categories":["Git"],"content":" 自定义 log 信息格式 $ git log --pretty=format:\"%Cred%an - %ar%n %Cblue %h -%Cgreen %s %n\" Git 提供了用于自定义日志消息格式的选项，你可以查看自定义漂亮选项（custom pretty options ）以获得更多选项。 ","date":"2020-08-01","objectID":"/git_log/:10:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#自定义-log-信息格式"},{"categories":["Git"],"content":" 参考 [1] Ten Useful Git Log Tricks [2] Git 基础 - 查看提交历史 ","date":"2020-08-01","objectID":"/git_log/:11:0","series":null,"tags":["Git","Trick"],"title":"Git Log 使用技巧","uri":"/git_log/#参考"},{"categories":null,"content":" NetworkWeb: DigitalOcean Nginx Tool：Nginx Config 生成 cURL 命令转代码：支持将 curl 命令转换为各种代码 网站测速： BOCE 17CE 网络测速: CloudFlare Speed Test Speedtest by Ookla 测速网 NTU Speed5 IP\u0026DNS 测试： WHOER ipleak DnsLeakTest BrowserLeaks - Web Browser Fingerprinting Proxy Anonymity Check Ping, mtr, dig and TCP port check from multiple locations IPv6: IPv6 连接测试 IPv6 Test IPv6 测试聚合站 国家 IPv6 发展检测平台 IPv6 发展监测平台目录服务 WebRTC: 皮皮直连：浏览器局域网文件传输 Snapdrop ","date":"2020-07-30","objectID":"/tools/:1:0","series":null,"tags":null,"title":"工具","uri":"/tools/#network"},{"categories":null,"content":" Translator DeepL ","date":"2020-07-30","objectID":"/tools/:2:0","series":null,"tags":null,"title":"工具","uri":"/tools/#translator"},{"categories":null,"content":" ToolsFormat: 在线格式转换工具 小熊文件格式在线转换工具 EPUB 转换器 PDF 工具 Toolset: MikuTools - 工具集合 在线工具大全 一个工具箱 - 好用的在线工具都在这里！ 菜鸟编程工具 程序员的工具箱 ","date":"2020-07-30","objectID":"/tools/:3:0","series":null,"tags":null,"title":"工具","uri":"/tools/#tools"},{"categories":null,"content":" Reading Epub 在线阅读 ","date":"2020-07-30","objectID":"/tools/:4:0","series":null,"tags":null,"title":"工具","uri":"/tools/#reading"},{"categories":null,"content":" Wireless Communication Sandesh Dhagle’s Resource Grid Tools：LTE 资源网格生成 ","date":"2020-07-30","objectID":"/tools/:5:0","series":null,"tags":null,"title":"工具","uri":"/tools/#wireless-communication"},{"categories":null,"content":" Linux Linux Command：Linux 命令搜索引擎命令 ","date":"2020-07-30","objectID":"/tools/:6:0","series":null,"tags":null,"title":"工具","uri":"/tools/#linux"},{"categories":null,"content":" Pics webp2jpg：图片格式转换 squoosh：谷歌图片压缩 sm.ms：图床 Favicon Generator：网站图标生成 isoflow：好看的拓扑图绘制 sketchboard：卡通画风拓扑图绘制 Full Emoji List ","date":"2020-07-30","objectID":"/tools/:7:0","series":null,"tags":null,"title":"工具","uri":"/tools/#pics"},{"categories":null,"content":" OCR PearOCR ","date":"2020-07-30","objectID":"/tools/:8:0","series":null,"tags":null,"title":"工具","uri":"/tools/#ocr"},{"categories":null,"content":" Security Virustotal 微步在线威胁情报社区 ","date":"2020-07-30","objectID":"/tools/:9:0","series":null,"tags":null,"title":"工具","uri":"/tools/#security"},{"categories":null,"content":" File Share TMP.LINK：文件上传分享 transfer.sh：命令行文件上传分享 奶牛快传 Unicode Text Converter：Unicode 文本转换 ","date":"2020-07-30","objectID":"/tools/:10:0","series":null,"tags":null,"title":"工具","uri":"/tools/#file-share"},{"categories":null,"content":" Temporary serviceTempSMS: Z-SMS： Materialtools Freeonlinephone TempMail: Yopmail 24mail Snapmail 阅后即焚: Ubuntu Pastebin Vuash - 安全发送信息 Privnote - Send notes that will self-destruct after being read Verybin - Anonymous, Encrypted and Opensource pastebin. PrivateBin ","date":"2020-07-30","objectID":"/tools/:11:0","series":null,"tags":null,"title":"工具","uri":"/tools/#temporary-service"},{"categories":null,"content":" 老年人网上冲浪必备 能不能好好说话？：网络缩写翻译 小鸡词典 ","date":"2020-07-30","objectID":"/tools/:12:0","series":null,"tags":null,"title":"工具","uri":"/tools/#老年人网上冲浪必备"},{"categories":["Algorithm"],"content":" 最常见的 SHA-2 算法是如何实现的？本文逐步为你讲解。 SHA-2 (Secure Hash Algorithm 2)，是最流行的哈希算法之一，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。 SHA-2 以安全和速度著称，在未生成密钥的情况下（例如挖掘比特币），像 SHA-2 这样的快速哈希算法通常占据上风。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:0:0","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#"},{"categories":["Algorithm"],"content":" 哈希函数（Hash Function）如果，你还不清楚哈希是什么，可以参见我的另外一篇文章 简单来说，哈希函数的拥有如下三个重要特性： 哈希函数对数据进行确定性加扰。 无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。 无法从加扰数据中检索原始数据（单向函数）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:1:0","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#哈希函数hash-function"},{"categories":["Algorithm"],"content":" SHA-2 vs SHA-256有人可能会困惑：欸？我平时看到的都是 SHA-128、SHA-256 等等，这个 SHA-2 又是什么？ SHA-2 是一种算法，一种关于如何哈希数据的广义思想。SHA-256 设置了定义 SHA-2 算法行为的附加常量。其中一个常量是输出大小，“256” 和 “512” 是指它们各自的输出摘要大小（以位为单位）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:2:0","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#sha-2-vs-sha-256"},{"categories":["Algorithm"],"content":" 逐步详解 SHA-256接下来举例说明 SHA-256 如何工作: ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:0","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#逐步详解-sha-256"},{"categories":["Algorithm"],"content":" 第一步：消息预处理 将 hello world 转换为二进制 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 尾部追加单独的 1 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 1 填充 0 直到数据为 512 的整数倍，再减去 64 位（在本例中剩下 448 位）： 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 在末尾附加新的 64 位，这 64 位是一个大端整数，用于表示原始二进制输入的长度。在本文的例子中，是 88，或者二进制，1011000。 01101000 01100101 01101100 01101100 01101111 00100000 01110111 01101111 01110010 01101100 01100100 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 01011000 现在，得到了初始的输入值（通过对消息进行补位处理，最终的长度应该是 512 位的倍数）。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:1","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第一步消息预处理"},{"categories":["Algorithm"],"content":" 第二步：初始化哈希值（h）现在，初始化 8 个哈希值。这些是硬编码的常数，分别代表前 8 个素数（2、3、5、7、11、13、17、19）的平方根的小数部分的前 32 位： h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:2","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第二步初始化哈希值h"},{"categories":["Algorithm"],"content":" 第三步：初始化圆常数(k)与步骤 2 类似，初始化一些常量，一共有 64 个。每个值（0-63）是前 64 个素数（2-311）的立方根分数部分的前 32 位。 0x428a2f98 0x71374491 0xb5c0fbcf 0xe9b5dba5 0x3956c25b 0x59f111f1 0x923f82a4 0xab1c5ed5 0xd807aa98 0x12835b01 0x243185be 0x550c7dc3 0x72be5d74 0x80deb1fe 0x9bdc06a7 0xc19bf174 0xe49b69c1 0xefbe4786 0x0fc19dc6 0x240ca1cc 0x2de92c6f 0x4a7484aa 0x5cb0a9dc 0x76f988da 0x983e5152 0xa831c66d 0xb00327c8 0xbf597fc7 0xc6e00bf3 0xd5a79147 0x06ca6351 0x14292967 0x27b70a85 0x2e1b2138 0x4d2c6dfc 0x53380d13 0x650a7354 0x766a0abb 0x81c2c92e 0x92722c85 0xa2bfe8a1 0xa81a664b 0xc24b8b70 0xc76c51a3 0xd192e819 0xd6990624 0xf40e3585 0x106aa070 0x19a4c116 0x1e376c08 0x2748774c 0x34b0bcb5 0x391c0cb3 0x4ed8aa4a 0x5b9cca4f 0x682e6ff3 0x748f82ee 0x78a5636f 0x84c87814 0x8cc70208 0x90befffa 0xa4506ceb 0xbef9a3f7 0xc67178f2 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:3","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第三步初始化圆常数k"},{"categories":["Algorithm"],"content":" 第四步：块循环对输入的每 512 位分为一块，执行以下步骤： 注意 在本文的例子中，因为 “hello world” 太短了，所以只有一个块。在循环的每一次迭代中，都将对哈希值 h0-h7 进行变更，最终作为结果输出。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:4","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第四步块循环"},{"categories":["Algorithm"],"content":" 第五步：重组信息数组（w） 将步骤 1 中的输入数据重新排列到新数组中，其中每个条目都是一个 32 位字： 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 再加上 48 个初始化为零的字，这样就有了一个数组 w [0…63] 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 … … 00000000000000000000000000000000 00000000000000000000000000000000 使用以下算法修改数组末尾的零索引： For i from w[16…63]: s0 = (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 = (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10) w[i] = w[i-16] + s0 + w[i-7] + s1 以 w[16] 举例说明： w[1] rightrotate 7: 01101111001000000111011101101111 -\u003e 11011110110111100100000011101110 w[1] rightrotate 18: 01101111001000000111011101101111 -\u003e 00011101110110111101101111001000 w[1] rightshift 3: 01101111001000000111011101101111 -\u003e 00001101111001000000111011101101 s0 = 11011110110111100100000011101110 XOR 00011101110110111101101111001000 XOR 00001101111001000000111011101101 = 11001110111000011001010111001011 w[14] rightrotate 17: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 w[14] rightrotate19: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 w[14] rightshift 10: 00000000000000000000000000000000 -\u003e 00000000000000000000000000000000 s1 = 00000000000000000000000000000000 XOR 00000000000000000000000000000000 XOR 00000000000000000000000000000000 = 00000000000000000000000000000000 w[16] = w[0] + s0 + w[9] + s1 = 01101000011001010110110001101100 11001110111000011001010111001011 00000000000000000000000000000000 00000000000000000000000000000000 = 00110111010001110000001000110111 // addition is calculated modulo $ 2^{32} $ 总的结果就是： 01101000011001010110110001101100 01101111001000000111011101101111 01110010011011000110010010000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000000000000 00000000000000000000000001011000 00110111010001110000001000110111 10000110110100001100000000110001 11010011101111010001000100001011 01111000001111110100011110000010 00101010100100000111110011101101 01001011001011110111110011001001 00110001111000011001010001011101 10001001001101100100100101100100 01111111011110100000011011011010 11000001011110011010100100111010 10111011111010001111011001010101 00001100000110101110001111100110 10110000111111100000110101111101 01011111011011100101010110010011 00000000100010011001101101010010 00000111111100011100101010010100 00111011010111111110010111010110 01101000011001010110001011100110 11001000010011100000101010011110 00000110101011111001101","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:5","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第五步重组信息数组w"},{"categories":["Algorithm"],"content":" 第六步：压缩 初始化变量 a，b，c，d，e，f，g，h，并将它们分别设置为等于当前的哈希值：h0，h1，h2，h3，h4，h5，h6，h7 进行压缩循环。 压缩循环将改变 a…h 的值。压缩循环如下： for i from 0 to 63: S1 = (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) ch = (e and f) xor ((not e) and g) temp1 = h + S1 + ch + k[i] + w[i] S0 = (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) maj = (a and b) xor (a and c) xor (b and c) temp2 := S0 + maj h = g g = f e = d + temp1 d = c c = b b = a a = temp1 + temp2 下面演示第一次迭代，所有加法都是以 $ 2^{32} $ 为模的： a = 0x6a09e667 = 01101010000010011110011001100111 b = 0xbb67ae85 = 10111011011001111010111010000101 c = 0x3c6ef372 = 00111100011011101111001101110010 d = 0xa54ff53a = 10100101010011111111010100111010 e = 0x510e527f = 01010001000011100101001001111111 f = 0x9b05688c = 10011011000001010110100010001100 g = 0x1f83d9ab = 00011111100000111101100110101011 h = 0x5be0cd19 = 01011011111000001100110100011001 e rightrotate 6: 01010001000011100101001001111111 -\u003e 11111101010001000011100101001001 e rightrotate 11: 01010001000011100101001001111111 -\u003e 01001111111010100010000111001010 e rightrotate 25: 01010001000011100101001001111111 -\u003e 10000111001010010011111110101000 S1 = 11111101010001000011100101001001 XOR 01001111111010100010000111001010 XOR 10000111001010010011111110101000 = 00110101100001110010011100101011 e and f: 01010001000011100101001001111111 \u0026 10011011000001010110100010001100 = 00010001000001000100000000001100 not e: 01010001000011100101001001111111 -\u003e 10101110111100011010110110000000 (not e) and g: 10101110111100011010110110000000 \u0026 00011111100000111101100110101011 = 00001110100000011000100110000000 ch = (e and f) xor ((not e) and g) = 00010001000001000100000000001100 XOR 00001110100000011000100110000000 = 00011111100001011100100110001100 // k[i] 是圆常数 // w[i] 信息数组 temp1 = h + S1 + ch + k[i] + w[i] = 01011011111000001100110100011001 + 00110101100001110010011100101011 + 00011111100001011100100110001100 + 1000010100010100010111110011000 + 01101000011001010110110001101100 = 01011011110111010101100111010100 a rightrotate 2: 01101010000010011110011001100111 -\u003e 11011010100000100111100110011001 a rightrotate 13: 01101010000010011110011001100111 -\u003e 00110011001110110101000001001111 a rightrotate 22: 01101010000010011110011001100111 -\u003e 00100111100110011001110110101000 S0 = 11011010100000100111100110011001 XOR 00110011001110110101000001001111 XOR 00100111100110011001110110101000 = 11001110001000001011010001111110 a and b: 01101010000010011110011001100111 \u0026 10111011011001111010111010000101 = 00101010000000011010011000000101 a and c: 01101010000010011110011001100111 \u0026 00111100011011101111001101110010 = 00101000000010001110001001100010 b and c: 10111011011001111010111010000101 \u0026 00111100011011101111001101110010 = 00111000011001101010001000000000 maj = (a and b) xor (a and c) xor (b and c) = 00101010000000011010011000000101 XOR 00101000000010001110001001100010 XOR 00111000011001101010001000000000 = 00111010011011111110011001100111 temp2 = S0 + maj = 11001110001000001011010001111110 + 00111010011011111110011001100111 = 00001000100100001001101011100101 h = 00011111100000111101100110101011 g = 10011011000001010110100010001100 f = 01010001000011100101001001111111 e = 10100101010011111111010100111010 + 01011011110111010101100111010100 = 00000001001011010100111100001110 d = 00111100011011101111001101110010 c = 10111011011001111010111010000101 b = 01101010000010011110011001100111 a = 01011011110111010101100111010100 + 00001000100100001001101011100101 = 01100100011011011111010010111001 整个计算会继续循环进行了 63 次，期间不断修改了变量 a-h 的值。最终结果为： a = 4F434152 = 001001111010000110100000101010010 b = D7E58F83 = 011010111111001011000111110000011 c = 68BF5F65 = 001101000101111110101111101100101 d = 352DB6C0 = 000110101001011011011011011000000 e = 73769D64 = 001110011011101101001110101100100 f = DF4E1862 = 011011111010011100001100001100010 g = 71051E01 = 001110001000001010001111000000001 h = 870F00D0 = 010000111000011110000000011010000 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:6","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第六步压缩"},{"categories":["Algorithm"],"content":" 第七步：修改最终值压缩循环完成后，仍然处于在块循环中，通过向哈希值中添加它们各自的变量 a-h 来修改哈希值。同样的，所有的加法都是模 $ 2^{32} $。 h0 = h0 + a = 10111001010011010010011110111001 h1 = h1 + b = 10010011010011010011111000001000 h2 = h2 + c = 10100101001011100101001011010111 h3 = h3 + d = 11011010011111011010101111111010 h4 = h4 + e = 11000100100001001110111111100011 h5 = h5 + f = 01111010010100111000000011101110 h6 = h6 + g = 10010000100010001111011110101100 h7 = h7 + h = 11100010111011111100110111101001 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:7","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第七步修改最终值"},{"categories":["Algorithm"],"content":" 第八步: 组成最终的哈希值 digest = h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 = B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9 搞定！至此，本文非常详细地实现了 SHA-256 中的每一步 🙂。 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:3:8","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#第八步-组成最终的哈希值"},{"categories":["Algorithm"],"content":" 附录 SHA-2 的第 t 个加密循环 下面这段伪代码总结了上面执行的所有步骤： 几点说明 所有变量均为 32 位无符号整数，加法以 $ 2^{32} $ 为模 对于每一轮，在消息调度数组 w [i]，0≤i≤63 中有一个循环常数 k [i] 和一个条目。 压缩函数使用 8 个工作变量，a 到 h。 在此伪代码中表示常量时使用大端约定，并且当将消息块数据从字节解析到字时，例如，填充后的输入消息 “abc” 的第一个字是 0x61626380 Initialize hash values: (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19): h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 Initialize array of round constants: (first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311): k[0..63] := 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 Pre-processing (Padding): begin with the original message of length L bits append a single '1' bit append K '0' bits, where K is the minimum number \u003e= 0 such that L + 1 + K + 64 is a multiple of 512 append L as a 64-bit big-endian integer, making the total post-processed length a multiple of 512 bits Process the message in successive 512-bit chunks: break message into 512-bit chunks for each chunk create a 64-entry message schedule array w[0..63] of 32-bit words (The initial values in w[0..63] don't matter, so many implementations zero them here) copy chunk into first 16 words w[0..15] of the message schedule array Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array: for i from 16 to 63 s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3) s1 := (w[i- 2] rightrotate 17) xor (w[i- 2] rightrotate 19) xor (w[i- 2] rightshift 10) w[i] := w[i-16] + s0 + w[i-7] + s1 Initialize working variables to current hash value: a := h0 b := h1 c := h2 d := h3 e := h4 f := h5 g := h6 h := h7 Compression function main loop: for i from 0 to 63 S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25) ch := (e and f) xor ((not e) and g) temp1 := h + S1 + ch + k[i] + w[i] S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22) maj := (a and b) xor (a and c) xor (b and c) temp2 := S0 + maj h := g g := f f := e e := d + temp1 d := c c := b b := a a := temp1 + temp2 Add the compressed chunk to the current hash value: h0 := h0 + a h1 := h1 + b h2 := h2 + c h3 := h3 + d h4 := h4 + e h5 := h5 + f h6 := h6 + g h7 := h7 + h Produce the final hash value (big-endian): digest := hash := h0 append h1 append h2 append h3 append h4 append h5 append h6 append h7 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:4:0","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#附录"},{"categories":["Algorithm"],"content":" 参考 [1] How SHA-2 Works Step-By-Step (SHA-256) [2] SHA-2 ","date":"2020-07-28","objectID":"/learn_sha_2_step_by_step/:5:0","series":null,"tags":["SHA-2","SHA-256","Hash","Translation"],"title":"逐步详解 SHA-2 算法（以 SHA-256 为例）","uri":"/learn_sha_2_step_by_step/#参考"},{"categories":["Algorithm"],"content":" 哈希函数入门介绍。 一点说明 本文中英文和二进制之间的相互转换并没有遵循任何模式，请读者不要纠结于这一点。当然，实际中，有很多方法用于将我们熟知的字符（例如中文、英语等）转换为二进制（十六进制），如果感兴趣，可以点击下面的参考中的内容 ","date":"2020-07-25","objectID":"/hash_functions/:0:0","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#"},{"categories":["Algorithm"],"content":" 哈希函数（Hash Function）用来做什么？哈希函数，又称散列函数，广泛应用于互联网的各处，包括但不限于安全地存储密码、查找重复记录、快速存储和检索数据等。例如，Qvault 应用使用哈希将主密码扩展为私人加密密钥。你还可以 点击这里 查看哈希函数用于何处。 ","date":"2020-07-25","objectID":"/hash_functions/:1:0","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#哈希函数hash-function用来做什么"},{"categories":["Algorithm"],"content":" 重要特性哈希函数的拥有如下三个重要特性，这些特性可以说是最重要的特性： 哈希函数对数据进行确定性加扰。 无论输入是什么，哈希函数的输出始终具有相同的长度（大小）。 无法从加扰数据中检索原始数据（单向函数）。 ","date":"2020-07-25","objectID":"/hash_functions/:2:0","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#重要特性"},{"categories":["Algorithm"],"content":" 确定性加扰想象一下，如果随机扭动一个魔方，到最后会得到一些和开始时不一样的东西。但是，如果重新开始，并做完全相同的一系列动作，那么将能够反复得到完全相同的结果。尽管结果可能看起来是随机的，但它其实是严格按照一定的规则进行变幻地，这就是确定性加扰的含义。 确定性对于安全存储密码很重要。例如，假设我的密码是 iLoveBitcoin，我可以使用哈希函数对其进行加扰： iLoveBitcoin → “2f5sfsdfs5s1fsfsdf98ss4f84sfs6d5fs2d1fdf15” 现在，任何人看到加扰后的版本，他们都不会知道我的原始密码！这一点很重要，因为这意味着作为一个网站开发人员，我只需要存储我用户密码的哈希(加扰数据)就可以验证它们。当用户注册时，我将用户密码进行哈希运算然后将其存储在我的数据库中。当用户登录时，我只是对他们输入的内容再次进行哈希运算，并比较两个哈希值。因为给定的输入总是生成相同的哈希值，所以能够很方便地进行验证。 ","date":"2020-07-25","objectID":"/hash_functions/:2:1","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#确定性加扰"},{"categories":["Algorithm"],"content":" 输出定长如果对单个单词进行哈希处理，则输出将具有一定的大小（对于 SHA-256，则为特定的哈希函数，大小为 256 位）。即便我对一本书进行哈希处理，输出同样将是相同的大小。 这是另一个重要的功能，因为它可以节省我们的计算时间。 一个典型的例子是使用哈希作为数据映射中的键。 数据映射是计算机科学中用来存储数据的一种简单结构。 数据映射 当程序在映射中存储数据时，会为映射指定一个键和值。当程序想要访问该值时，它只要提供适当的键就能接收相应的值。数据映射很好，因为它们可以立即找到数据。计算机通过键可以立即找到对应的值，而不是花费数小时在数百万条记录中搜索。 因为键类似于地址，所以它们不能太大。如果我想将图书存储在数据映射中，我可以对图书的内容进行哈希，并使用该哈希作为键。 ","date":"2020-07-25","objectID":"/hash_functions/:2:2","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#输出定长"},{"categories":["Algorithm"],"content":" 哈希处理如何进行？接下来，以 LANEHASH 算法为例，简要讲解哈希处理是如何完成的。 首先，选取下面的数据进行哈希处理 iLoveBitcoin 将字母转换成二进制 iLoveBitcoin→ 100010100000101111 注意 在这一步中，我们通过各种预定的步骤来转换我们的原始数据。转换方式可以采用各种方式，但重要的是，每当我们使用 LANEHASH 时，都需要使用相同的步骤，以便我们的算法是确定性的。 将比特前四位从左移到右边 100010100000101111 → 101000001011111000 奇偶分离比特 101000001011111000 → 110011110 \u0026 000001100 分别转化为十进制数 110011110 → 414 000001100→ 12 两数相乘 414 *12 = 4968 乘积平方 4968 ^ 2 = 24681024 再次转换为二进制 24681024 →1011110001001101001000000 剥离右边的 9 个比特以得到 16 位比特 1011110001001101001000000 → 1011110001001101 转换回字母/数字 1011110001001101 → “8sj209dsns02k2” 正如你所看到的，如果在开始时使用相同的单词，则在结束时将始终得到相同的输出。然而，即使你改了一个字母，结果也会发生很大的变化。 ","date":"2020-07-25","objectID":"/hash_functions/:3:0","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#哈希处理如何进行"},{"categories":["Algorithm"],"content":" 总结哈希函数实际上就是按照特定的规则将数据进行一系列转换，最后得到一串键值用来代替/指代原始数据，但是需要注意的是，哈希函数需要满足确定性、定长性、不可逆性。 ","date":"2020-07-25","objectID":"/hash_functions/:4:0","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#总结"},{"categories":["Algorithm"],"content":" 参考 [1] (Very) Basic Intro to Hash Functions (SHA-256, MD5, etc) [2] Hash Function [3] ASCII [4] Unicode ","date":"2020-07-25","objectID":"/hash_functions/:5:0","series":null,"tags":["Hash","Translation"],"title":"哈希函数简介","uri":"/hash_functions/#参考"},{"categories":["Software"],"content":" SCP 就是 SSH 协议的文件传输功能吗？ ","date":"2020-07-18","objectID":"/scp/:0:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#"},{"categories":["Software"],"content":" 什么是 SCPSCP（Secure Copy Protocol，安全复制协议）允许我们在两台计算机之间复制文件（和目录）。 使用起来特别方便： $ scp local_file remote_host:/home 这将把本地文件 localfile 复制到远程主机的 /home 文件之下。 SCP 使用起来特别便利，因为他能工作在几乎所有的 Unix-like 的系统中，并且 Windows 下拥有许多客户端。但是仅仅复制文件并不是关键。SCP 真正的价值是对 计算机的身份进行验证 以及对 传输文件进行加密（也就是 S 代表的含义）。 使用前需要首先配置到远程主机的 SSH 连接权限。SCP 的验证提示和 SSH 看起很像，因为 SCP 跑在 SSH 的上层，仅仅把它作为文件数据的管道。事实上，SSH 负责处理所有安全相关的任务，SCP 只是将一些文件扔到 SSH 连接上。 维基百科上的条目讲述了 SCP 的历史，简而言之：在旧的 BSD 系统上曾经有一个叫 RCP 的工具，可以在电脑之间移动文件。在当时受信任的网络时代，每个人都是别人的朋友。后来人们意识到，也许并不是每个人在他们的网络上都是这么好的朋友。于是有人把 RCP 的实现复制到 OpenSSH 的前身上，然后简单地在 SSH 会话上运行它，以保护文件不被非好友发现。问题解决了！从此以后，它就留在了 OpenSSH 中。 ","date":"2020-07-18","objectID":"/scp/:1:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#什么是-scp"},{"categories":["Software"],"content":" SCP 工作原理SCP 并不是一个标准协议，并没有一个 RFC 或者任何官方描述如何实现它。OpenSSH 实现是一个事实上的规范。此实现有两个部分：连接建立和之后的传输协议。 ","date":"2020-07-18","objectID":"/scp/:2:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#scp-工作原理"},{"categories":["Software"],"content":" 建立连接实际上，这并不是真正的连接。因为它只是利用 SSH 执行命令后的 STDIN/STDOUT ，有点类似 Unix 管道。OpenSSH 中包含两个程序来完成:sshd 和 scp。sshd 是始终运行的服务器守护进程，接受新的 SSH 连接。SCP 是伪装成 SSH 的客户端程序，发送和接受文件。 当 SCP 运行时，他将开启一个新的 SSH 连接。在该连接上，它会在服务端执行另一个带有特殊标志的 SCP 程序。你可以认为是 ssh exec scp [flags]。主要的标志包含 -t（“to”）和 -f（“from”）用于代表接受和发送，而 -d 表示文件夹，-r 表示递归。 建立连接 值得注意的是，SCP 协议是单向的，一端发送文件，另一端接收文件。在远程端 SCP 开始运行后，实际的 SCP 协议命令开始通过 STDIN 和 STDOUT 运行。 ","date":"2020-07-18","objectID":"/scp/:2:1","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#建立连接"},{"categories":["Software"],"content":" 传输协议现在，安全的 I/O 通道建立起来，并且已经有效地切换到 RCP 协议上。该协议是 顺序（一次一个操作）和 同步（每个命令执行完后才执行下一个命令）执行的。 命令格式大致为（不带括号或空格）：[command type][arguments]\\n [optional data] [command type] 通常是一个 ASCII 字符： ‘C’- 写入文件 ‘D’- 输入目录 ‘E’- 退出最后一个目录 ‘T’- 设置下一个文件或目录的创建 / 更新时间戳 [arguments] 是特定于命令的，如文件 / 目录名称、文件大小或时间戳。“E” 命令没有参数。 [optional data] 在上一个命令为 “C”（创建文件）时发送。数据的大小指定为 “C” 的参数。 此外，还有控制字节，这些字节是在没有新行的情况下自己发送的： ‘0x00’-“OK”，确认完成最后一个命令（如编写本地文件）。接收方也会在启动时发送此消息，让发送方知道它已准备好接收命令。 ‘0x00’-“警告”，后面是要向用户显示的行（由新行终止）。 ‘0x00’-“错误” 后跟随可选消息（和警告相同），但连接随后终止。 下面这个带有注释的图片实例，详细讲述了这个过程： 传输过程 ","date":"2020-07-18","objectID":"/scp/:2:2","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#传输协议"},{"categories":["Software"],"content":" 使用 SCP $ scp 选项 参数 其中选项如下： -1：使用ssh协议版本1； -2：使用ssh协议版本2； -4：使用ipv4； -6：使用ipv6； -B：以批处理模式运行； -C：使用压缩； -F：指定ssh配置文件； -l：指定宽带限制； -o：指定使用的ssh选项； -P：指定远程主机的端口号； -p：保留文件的最后修改时间，最后访问时间和权限模式； -q：不显示复制进度； -r：以递归方式复制。 参数分别为： 源文件：指定要复制的源文件。 目标文件：格式为 user@host：filename（文件名为目标文件的名称）。 ","date":"2020-07-18","objectID":"/scp/:3:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#使用-scp"},{"categories":["Software"],"content":" SCP 的问题看起来，SCP 听起来似乎没什么问题。它是一个简单易用的工具，然而存在一些现实问题。 ","date":"2020-07-18","objectID":"/scp/:4:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#scp-的问题"},{"categories":["Software"],"content":" 性能传输协议的顺序性：每个命令的强制确认都会增加大量开销。例如，如果沿途丢弃单个确认数据包，则整个连接将暂停，直到重新传输开始。最重要的是，发送所有数据而不压缩或询问接收方是否已经拥有该文件并不理想。 有经验的系统管理员可以告诉您，使用 tar 归档文件并发送比使用 scp 递归命令传输要快得多。事实上，这样的话你甚至无需使用 SCP： # Copy a local folder with 10000 files $ find /tmp/big_folder/-type f | wc -l 10000 # Using scp $ time scp -r -q /tmp/big_folder/server:/tmp/big_folder ________________________________________________________ Executed in 882.99 millis fish external usr time 114.09 millis 0.00 micros 114.09 millis sys time 278.46 millis 949.00 micros 277.51 millis # Using tar over ssh $ time sh -c \"tar cf - /tmp/big_folder | ssh server 'tar xC /tmp/-f -'\" tar: Removing leading '/' from member names ________________________________________________________ Executed in 215.68 millis fish external usr time 93.22 millis 0.00 micros 93.22 millis sys time 66.51 millis 897.00 micros 65.62 millis 在这种比较糟糕的情况下，tar\u0026ssh 的 215.68ms 对比 SCP 的 882.99ms，足足有四倍的速度提升。 ","date":"2020-07-18","objectID":"/scp/:4:1","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#性能"},{"categories":["Software"],"content":" 安全我们已经知道，SCP 靠 SSH 负担安全工作，因此它完全安全… 吗？ OpenSSH 的发行说明提到： scp 协议已经过时、不灵活且不容易修复。我们建议使用更现代的协议，如 sftp 和 rsync 来传输文件。 如果远程端的 shell 打印出任何非交互式会话，则本地 SCP 进程将愉快地将该输出解释为 SCP 命令。好的话，这仅仅是打破 SCP 协议中模糊的错误。但在最坏的情况下，远程 shell 启动脚本是恶意的，并向你发送恶意文件，而不是所需的文件。 此外，早在 2018 年，Harry Sintonen 就发现了流行的 SCP 实现（包括 OpenSSH）中的一堆漏洞。包括从修改目录的权限到覆盖任意文件（由于 ～/.ssh/authorized_keys 或 ～/.bashrc）、有效地执行代码，以及注入终端转义序列来隐藏任何追踪。这些漏洞对于任何构建网络 CLI 应用程序的人来说都是一个很好的教训。 ","date":"2020-07-18","objectID":"/scp/:4:2","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#安全"},{"categories":["Software"],"content":" SCP 的替代方案SFTP 被广泛认为是 SCP 的继承者。为了传输层安全性，它仍然在 SSH 上运行，并且不需要单独设置访问。它可以为您提供一个自定义交互式提示来探索远程文件系统，或者您可以使用预先编写的一系列命令编写脚本。 缺点是，您需要学习 SFTP 提示命令，协议本身尚未完全标准化（有很多 RFC 草稿，但作者最终放弃了）。 Rsync 是另一个很好的选择。使用与 SCP 命令完全相同 - 它也利用 SSH。Rsync 着重优化性能 - 它执行大量的复杂本地计算从而通过网络发送尽可能少的数据。从技术上讲，它致力于数据同步而不是纯传输文件 - 如果远程和本地内容相似，则只会发送增量。 同样，它也有其自身的缺点：发送方使用大量的 CPU 资源来计算要发送什么，并且接收方使用大量磁盘 IO 将数据按正确的顺序放在一起。与 OpenSSH 不同，Rsync 在大多数系统上并不预安装。 ","date":"2020-07-18","objectID":"/scp/:5:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#scp-的替代方案"},{"categories":["Software"],"content":" 结论SCP 是一个简单的工具，它在复制文件方面做得很好，但较新的软件在很多方面都优于它。对于您信任的计算机之间的个人简单使用，SCP 仍然适合。 但是，如果您遇到性能问题或需要满足更高的安全标准，则上面列出的任何备选方案都比 SCP 更可取。选择最适合您需求的，然后试着开始使用。 ","date":"2020-07-18","objectID":"/scp/:6:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#结论"},{"categories":["Software"],"content":" 另见 rsync SFTP ","date":"2020-07-18","objectID":"/scp/:7:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#另见"},{"categories":["Software"],"content":" 参考 [1] SCP - Familiar, Simple, Insecure, and Slow [2] Wikipedia Secure copy [3] Call for testing: OpenSSH 8.0 [4] Scp ","date":"2020-07-18","objectID":"/scp/:8:0","series":null,"tags":["Software","Linux","Translation"],"title":"文件传输系列：SCP","uri":"/scp/#参考"},{"categories":["Network"],"content":" NAT 引发的问题以及解决方法 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:0:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#"},{"categories":["Network"],"content":" 问题对称型 NAT（Symmetric NAT）常常在游玩联机游戏（尤其是 P2P 联机方式）时候给我们造成困扰。如果 Xbox、PS、switch 或者 PC 上的应用程序报告 NAT 是严格、类型 3、类型 D、对称这样的字样，那么就意味着你将会出现联机问题。 理解这个问题之前，首先要认识到，这些设备及软件是无法感知它们是否被 NAT 化的。但是，在 Internet 上与之通信的任何设备都应该使用公共 IP 地址，例如 1.1.1.1。在进行任何连接尝试时，都必须知道目标公共 IP 地址和端口。在上面的所有示例中，你应该发现了网站 IP 地址和端口均已知，这些地址是固定的，并且未曾发生更改。但是，某些程序会使用一系列动态端口。在运行游戏时，你的主机选择一个随机端口来进行游戏。由于其他主机不知道你的 IP 地址或端口，因此必须在连接之前以某种方式了解它。你的主机会将游戏的 IP 地址和端口发送到 Xbox Live 或 PS 网络，这样其他主机便可以在其中检索它，然后直接与你连接。但问题是，它发送的是内部 IP 地址 192.168.0.1 和端口 54324，而不是 Nat 后的公共 IP。它应该发送的是（例如）1.1.1.1 的公共 IP 地址和端口 54324。而且当处于对称型 NAT 时，该端口也会发生更改，因此它必须发送经过 NAT 处理的端口，例如 54254，而不是主机本身的内部端口（54324）。 这不仅仅是游戏面对的问题，这一直是 NAT 的问题。 那么，主机如何得知它位于 NAT 之后，并告诉其他主机将数据发送到 NAT 后的 IP 地址和端口而不是其自身的内部 IP 地址和端口？ ","date":"2020-07-15","objectID":"/nat_issues_solutions/:1:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#问题"},{"categories":["Network"],"content":" 解决办法","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#解决办法"},{"categories":["Network"],"content":" STUN（Session Traversal Utilities）STUN 是 NAT 的 Session Traversal Utilities 的缩写，你可能已经猜到了它的名字，它是一个实用工具的集合，以帮助 NAT 设备穿越内网。简单地说，STUN 允许你的主机 / PC 或内部设备了解它的公共 NAT 的 IP 地址和端口是什么。一旦实现了这一点，你的设备现在可以发送正确的 IP 和端口，其他设备也可以连接到你。但是，它在对称型 NAT 下无法工作，在对称型 NAT 中，你的主机可以得知它的公共 IP 地址，但无法得知它的公共端口（因为，端口是 NAT 随机生成的）。 STUN 的工作原理很简单。你连接到一个运行 STUN 协议的服务器 (Xbox Live Servers)，它从接收的数据包中读取源 IP 地址和源端口，这些当然会是 NAT 后的（这是我们需要的）。然后 STUN 将这些信息返回给客户端，它的工作就完成了。你的主机现在知道了它的 NAT 后的 IP 和端口，并且会把这些信息发送到其他设备上。 STUN 算法 如果你还记得，除了对称型 NAT 之外，所有其他类型的 NAT 都不会改变源端口。这意味着当我的主机创建一个 NAT 映射时，它将对所有这种类型的连接使用它，当向互联网上的个设备发送和接收数据包时，它使用同一个映射，因此它使用相同的公共 IP 地址和端口； 但在对称型 NAT 的情况下，每一个连接都有一个不同的映射，有一个不同的（随机生成的）端口，意味着连接到 STUN 服务器也将有它自己独特的映射，表现的就像一个新的设备接入一样。这意味着每个映射都有不同的端口，在这种情况下，STUN 检测到的端口现在已经没有用了，因为这个映射是 STUN 服务器独有的。无论映射到其他设备的端口是什么，都是未知的，STUN 也没有办法检测到它。由于你的主机无法得知每个映射到每个主机的公共 NAT 化端口，因此无法将这些信息传递给你，也就意味着没有设备可以连接到你的游戏，这就是对称型 NAT 导致如此多游戏联机问题的原因。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:1","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#stunsession-traversal-utilities"},{"categories":["Network"],"content":" DMZ（Demilitarized zone)路由器上的外围网络（也称 DMZ）功能用于消除对 Internet 的限制。它主要是将你的设备移到你的网络防火墙之外的区域，将部分用于提供对外服务的服务器主机划分到一个特定的子网 —— DMZ 内，在 DMZ 的主机能与同处 DMZ 内的主机和外部网络的主机通信，而同内部网络主机的通信会被受到限制。这使 DMZ 的主机能被内部网络和外部网络所访问，而内部网络又能避免外部网络所得知。 注意 当你设置外围网络时在主机上使用静态 IP 地址十分重要。要设置静态 IP 地址，请使用路由器的 DHCP 预留功能（如果可用）。如果该功能不可用，你将需要在你的设备 上配置手动 IP 设置。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:2","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#dmzdemilitarized-zone"},{"categories":["Network"],"content":" UPnP（Universal Plug and Play）UPnP（Universal Plug and Play）是帮助路由器有效通信的一个标准。如果路由器或网关支持 UPnP，则它在默认情况下可能已启用。开启 UPnP 功能后，局域网中的计算机可以请求路由器自动进行端口转换。这样，互联网上的计算机就能在需要时访问局域网计算机上的资源（如 MSN Messenger 或迅雷、BT、PPLive 等支持 UPnP 协议的应用程序）。 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:2:3","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#upnpuniversal-plug-and-play"},{"categories":["Network"],"content":" 参考 [1] Symmetric NAT and It’s Problems | Think Like A Computer [2] Wikipedia STUN [3] Wikipedia DMZ [4] 解决 NAT 错误和多人游戏问题 ","date":"2020-07-15","objectID":"/nat_issues_solutions/:3:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：问题及解决方法","uri":"/nat_issues_solutions/#参考"},{"categories":["Network"],"content":" 一文概览 NAT ","date":"2020-07-14","objectID":"/nat/:0:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#"},{"categories":["Network"],"content":" NATNAT（Network Address Translation，网络地址转换）在计算机网络中是一种在 IP 数据包通过路由器或防火墙时重写来源 IP 地址或目的 IP 地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有 IP 地址访问互联网的私有网络中。 NAT 从大类上都可以分为两类：静态 NAT 和 动态 NAT。 静态 NAT 是管理员手动创建和维护映射，通常与 NAT 的入站类型相关联。 动态 NAT 是路由器根据需要自动创建和维护映射，通常与 NAT 的出站类型相关联。 每个 TCP/IP 数据包都包含一个 源 IP 地址、源端口、目的 IP 地址 和 目的端口。所有类型的 NAT 都会使用这些值创建 NAT 映射。 例如，一个 IP 为 192.168.0.1 的内部客户机使用端口 56876，经过 NAT 转变后 IP 变为 3.3.3.3（翻译后的源 IP）和端口 56876（源端口）连接到 IP 2.2.2.2（目的 IP 地址）的 80 端口（目的端口）。NAT 使用原始内部 IP 和端口、翻译后 IP 和端口这 4 个值创建一个映射。当数据包从网站返回到路由器时，使用与该映射相关值，NAT 将数据包转发到内部客户端。 ","date":"2020-07-14","objectID":"/nat/:1:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#nat"},{"categories":["Network"],"content":" NAT 的四种类型","date":"2020-07-14","objectID":"/nat/:2:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#nat-的四种类型"},{"categories":["Network"],"content":" 全锥型 NAT（Full Cone NAT) 全锥型 NAT 全锥型 NAT 是静态 NAT，也是唯一一种永久开放端口的 NAT，允许从 任何外部主机 进行入站连接。全锥型 NAT 将一个公共 IP 地址和端口映射到 LAN IP 和端口。任何外部主机都可以通过映射的 NAT IP 和端口向 LAN IP 发送数据。但是，如果它试图通过不同的端口发送数据，就会失败。这种类型的 NAT 也被称为端口转发。这是受限制最少的 NAT 类型，唯一的要求是连接在一个特定的端口（客户端打开的端口）。 例如，我的电脑有一个网站在 80 端口上运行，我创建了一个一对一的规则，将路由器的 WAN IP 1.1.1.1 映射到 192.168.0.1，端口 80 映射到 80 端口。凡是在 80 端口向 1.1.1.1 发送数据的外部主机都会被 NAT 转发到 192.168.0.1 80 端口。 注意： 端口号不必相同；我可以在 56456 端口上运行我的网站，但创建 NAT 映射，将 80 端口转发到 56456 端口。这样，外部客户端就会认为我的网站在 80 端口上，而在任何其他端口上的连接尝试都会被丢弃。 ","date":"2020-07-14","objectID":"/nat/:2:1","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#全锥型-natfull-cone-nat"},{"categories":["Network"],"content":" 受限锥形 NAT（Restricted Cone NAT） 受限锥形 NAT 受限锥体 NAT 是动态 NAT，它的工作方式与全锥型 NAT 相同，但会对进站的 IP 地址施加额外的限制。根据限制，唯一的要求是数据包必须从映射的端口进入，并且来自内部客户端已发送数据包的 IP 地址。亦即需要内部主机首先发起连接的外部主机，才能被接受入站。 例如，我的电脑与一个网站 (56.45.34.78) 进行外向连接，源 IP 为 192.168.0.1，源端口为 56723。NAT 使用源端口 56723 创建一个（动态）映射到我的电脑。使用目的端口 56723（这是出站 NAT 的源端口）到达的源 IP 为 56.45.34.78（网站 IP）的数据包将被接受，接着网站返回数据至我的 PC。任何其他 IP 即使使用正确的 56723 端口进行连接尝试将被丢弃。同样，即使正确的 IP 使用 56723 以外的目的端口进行的连接尝试也将被丢弃。 ","date":"2020-07-14","objectID":"/nat/:2:2","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#受限锥形-natrestricted-cone-nat"},{"categories":["Network"],"content":" 端口受限锥型 NAT（Port Restricted Cone NAT) 端口受限锥型 NAT 端口受限锥型 NAT 是动态 NAT，它的作用与受限锥形 NAT 完全相同，但同时对端口进行限制。受限锥形 NAT 接受来自外部主机任何源端口的连接，而端口受限锥型 NAT 则进一步要求外部主机的源端口是固定的。 例如，我的电脑在 80 端口（目标端口）上向网站 IP 217.87.69.8 建立了一个外向连接。NAT 将我的源 IP 192.168.0.1 映射到 WAN IP 1.1.1.1 和源端口 56723。当网站发回数据包时，它的源 IP 必须是 217.87.69.8，目的端口是 56723（就像一个受限锥型 NAT），但除此之外，还要求源端口必须是 80。如果这三者中的任何一个不一样，端口受限锥型 NAT 就会放弃连接。 ","date":"2020-07-14","objectID":"/nat/:2:3","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#端口受限锥型-natport-restricted-cone-nat"},{"categories":["Network"],"content":" 对称型 NAT（Symmetric NAT） 对称型 NAT 对称型 NAT 是动态 NAT，它限制的方式与端口受限锥型 NAT 完全相同，但处理 NAT 转换的方式不同。目前讨论的所有类型的 NAT 在 NAT 连接时都 不会改变源端口。 例如，当客户端使用 IP 192.168.0.1 和源端口 56723 访问互联网时，NAT 将源 IP 改变为 56.35.67.35，但保持端口号不变，这被称为端口保留。 而对称型 NAT 会将端口改为 随机生成的新端口，甚至是同一客户端到不同目的地的连接也会发生。亦即为每个连接创建唯一的映射 例如，在端口受限锥型 NAT 的例子上进行扩展，我的 PC 向网站 IP 217.87.69.8 和 56.76.87.98 建立两个出站连接。我的电脑使用源 IP 192.168.0.1 和源端口 56723 进行两个连接。到目前为止，在所有类型的 NAT 上，这两个连接都会被 NAT 化，只改变源 IP 地址而保持源端口不变。然而这次，对称型 NAT 没有将源端口保留为 56723，而是将其中一个连接的源端口改为 45765，另一个连接的源端口改为 53132（随机）。这就为每个连接创建了唯一的映射，来自这些目的地的流量必须通过各自的端口进入。所以 217.87.69.8 必须将数据包发送到目的端口 45765，56.76.87.98 必须将数据包发送到端口 53132，此外还需要遵循端口受限锥型 NAT 的要求。 ","date":"2020-07-14","objectID":"/nat/:2:4","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#对称型-natsymmetric-nat"},{"categories":["Network"],"content":" 对 NAT 的正面评价 NAT 在一定程度上缓解了 IPv4 地址短缺的问题，让更多的设备（间接）接入了互联网。 NAT 全双工连接支持的缺少在一些情况下可以看作是一个有好处的特征而不是一个限制。在一定程度上，NAT 依赖于本地网络上的一台机器来初始化和路由器另一边的主机的任何连接，它可以阻止外部网络上的主机的恶意活动。这样就可以阻止网络蠕虫病毒来提高本地系统的可靠性，阻挡恶意浏览来提高本地系统的私密性。很多具有 NAT 功能的防火墙都是使用这种功能来提供核心保护的。另外，它也为 UDP 的跨局域网的传输提供了方便。 ","date":"2020-07-14","objectID":"/nat/:3:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#对-nat-的正面评价"},{"categories":["Network"],"content":" 对 NAT 的批评 在一个具有 NAT 功能的路由器下的主机并没有获得真正的 IP 地址，并且不能参与一些因特网协议，一些需要初始化从外部网络创建的 TCP 连接和无状态协议（比如 UDP）无法实现。除非 NAT 路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址。 端对端连接是被 IAB 委员会（Internet Architecture Board）支持的核心因特网协议之一，因此有些人据此认为 NAT 是对公用因特网的一个破坏。一些因特网服务提供商（ISP）只向他们的客户提供本地 IP 地址，所以他们必须通过 NAT 来访问 ISP 网络以外的服务，并且这些公司能不能算的上真正的提供了因特网服务的话题也被谈起。 NAT 使得 IP 协议从面向无连接变成立面向连接。NAT 必须维护专用 IP 地址与公用 IP 地址以及端口号的映射关系。在 TCP/IP 协议体系中，如果一个路由器出现故障，不会影响到 TCP 协议的执行。因为只要几秒收不到应答，发送进程就会进入超时重传处理。而当存在 NAT 时，最初设计的 TCP/IP 协议过程将发生变化，Internet 可能变得非常脆弱。 NAT 违反了基本的网络分层结构模型的设计原则。因为在传统的网络分层结构模型中，第 N 层是不能修改第 N+1 层的报头内容的。NAT 破坏了这种各层独立的原则。 NAT 同时存在对高层协议和安全性的影响问题。RFC 对 NAT 存在的问题进行了讨论。NAT 的反对者认为这种临时性的缓解 IP 地址短缺的方案推迟了 IPv6 迁移的进程，而并没有解决深层次的问题，他们认为是不可取的。 ","date":"2020-07-14","objectID":"/nat/:4:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#对-nat-的批评"},{"categories":["Network"],"content":" 参考 [1] Wikipedia NAT [2] What you need to know about symmetric NAT | Think Like A Computer [3] NAT Types Defined ","date":"2020-07-14","objectID":"/nat/:5:0","series":null,"tags":["NAT","Translation"],"title":"NAT 系列：认识 NAT","uri":"/nat/#参考"},{"categories":["Network"],"content":" DNS 如何工作？更新网站的 DNS 记录的时候发生了什么？更新后必须等待 48 小时才能生效吗？为什么有人看到的是新 IP，有人看到的是旧 IP？ ","date":"2020-07-02","objectID":"/dns_update/:0:0","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#"},{"categories":["Network"],"content":" DNS 分类我们知道，DNS 服务器有两种：权威服务器（authoritative）和递归服务器（recursive） 权威 DNS 服务器（也称为名称服务器，NS，nameserver） 具有其所负责的每个域的 IP 地址数据库。 例如，github.com 的权威 DNS 服务器是 NS-421.awsdNS-52.com 您可以像这样要求它提供 github.com 的 IP: $ dig @NS-421.awsdNS-52.com github.com 递归 DNS 服务器，本身并不知道谁拥有什么 IP 地址。它们通过询问正确的权威 DNS 服务器，找出域名的 IP 地址，然后缓存这个 IP 地址，以备再次询问。8.8.8.8 是一个递归 DNS 服务器。 当人们访问你的网站时，他们可能会向递归 DNS 服务器进行 DNS 查询。那么，递归 DNS 服务器是如何工作的呢？ ","date":"2020-07-02","objectID":"/dns_update/:1:0","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#dns-分类"},{"categories":["Network"],"content":" 递归 DNS 服务器如何工作以 8.8.8.8 为例，如果我们向其请求 github.com 的 IP 地址（A 记录），如果它存在缓存，那么就直接返回缓存结果。然而，缓存是有期限的，如果所有缓存都过期了呢？那么情况是这样的： 递归服务器内部硬编码（hardcoded）有根 DNS 服务器 . 的 IP 地址（参见 [2][3]），选择一个根 DNS 服务器，例如 198.41.0.4 询问根 DNS 服务器有关 com. 的 NS 此步可以使用如下方法模拟： $ dig @198.41.0.4 github.com ... com. 172800 IN NS a.gtld-servers.net. ... a.gtld-servers.net. 172800 IN A 192.5.6.30 ... 可以看到，这里我们得到一个 com. 的权威 NSa.gtld-servers.net. 及其 IP 地址 192.5.6.30 注意 实际上，99.99% 的情况下，此步我们就将得到 github.com 的 A 记录，但为了展示完整 DNS 解析进程，假设这里我们没有得到。 询问该权威 NS 有关 github.com 的 NS $ dig @192.5.6.30 github.com ... github.com. 172800 IN NS NS-421.awsdNS-52.com. NS-421.awsdNS-52.com. 172800 IN A 205.251.193.165 ... 这里，我们得到的 github.com.NSNS-421.awsdNS-52.com. 及其 IP 地址 205.251.193.165 询问该 NS 有关 github.com 的 A 记录 $ dig @205.251.193.165 github.com github.com. 60 IN A 140.82.112.4 至此，在假设没有缓存的情况下，我们通过完整的流程（实际上绝大多数情况不需要完整进行）获得了 github.com 的 IP 地址。 此外，使用 $ dig @8.8.8.8 +trace github.com 可以一次性显示上述所有步骤。 ","date":"2020-07-02","objectID":"/dns_update/:1:1","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#递归-dns-服务器如何工作"},{"categories":["Network"],"content":" 更新 DNS 记录更新 DNS 记录时，有两种情况： 保持相同的 NS 变更 NS ","date":"2020-07-02","objectID":"/dns_update/:2:0","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#更新-dns-记录"},{"categories":["Network"],"content":" 首先谈谈生存时间（TTLs，time to live）上面已经说到，DNS 服务器一般存有缓存，而控制缓存是否过期的参数就是 TTL。 我们假设得到一个查询结果： $ dig @205.251.193.165 github.com github.com. 60 IN A 140.82.112.4 这里的 60（秒）即表示 TTL，这是一个很短的 TTL。理论上，如果每个用户都遵循 DNS 标准，那么 github.com 在更改了 IP 地址后，每个用户都应该在 60 秒内得到这个新的地址。但实际上呢？ ","date":"2020-07-02","objectID":"/dns_update/:2:1","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#首先谈谈生存时间ttlstime-to-live"},{"categories":["Network"],"content":" 更新同一 NS 上的 DNS 记录假设我们已经在域名商处更新了新的 DNS 记录 test.jvNS.ca–\u003e1.2.3.4，试着查询： $ dig @8.8.8.8 test.jvNS.ca test.jvNS.ca. 299 IN A 1.2.3.4 如果此前没有设置过 DNS 记录，因为没有缓存，所以立刻生效了。这里可以看到 TTL 是 299。那么，修改 IP 为 5.6.7.8 呢。 $ dig @8.8.8.8 test.jvNS.ca test.jvNS.ca. 144 IN A 1.2.3.4 可以看到，IP 并没有发生改变且 TTL 表示缓存还将存在 144 秒。而且，多次查询，你可能会发现，有时候可以得到新的 IP，但有的时候又是旧的 IP。 这里是因为像 8.8.8.8 这样的 DNS 服务器采用了负载均衡，每次查询可能被分配到不同的后端服务器，而他们的缓存不尽相同。 等待 5 分钟后，所有的缓存都更新了，再次查询，将会始终返回新 IP。 ","date":"2020-07-02","objectID":"/dns_update/:2:2","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#更新同一-ns-上的-dns-记录"},{"categories":["Network"],"content":" TTL 并非总是可靠与大多数互联网协议一样，并不是所有的终端都服从 DNS 规范（包括 8.8.8.8 这样的大型 DNS 也不尊重 TTL）。一些 ISP 的 DNS 服务器会将缓存记录的时间比 TTL 规定的时间长，比如可能是 2 天而不是 5 分钟。而且人们总是可以在他们的 /etc/hosts 中硬编码旧的 IP 地址。 此外，应用程序（例如浏览器）都内置了自己的 DNS 缓存，或者本地网关也存在缓存。 这也是为什么，即便正确地设置了对应的 TTL（大部分 DNS 将会在短时间内更新缓存），有些 DNS 服务器仍然需要更长时间生效，这也导致我们的查询也并不总是会得到新的 IP 地址。 ","date":"2020-07-02","objectID":"/dns_update/:2:3","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#ttl-并非总是可靠"},{"categories":["Network"],"content":" 连同 NS 一起更新假设此前的 NS 为 dNS1.p01.NSone.net，现在我们把他修改为谷歌的 NSNS-cloud-b1.googledomaiNS.com。 通常，当你修改完成后，你的域名商会提示你：“修改将在 48 小时内生效”。 然后设置一个新的 A 记录指向 1.2.3.4 dig 看看： $ dig @8.8.8.8 examplecat.com examplecat.com. 17 IN A 104.248.50.87 8.8.8.8 没有变化，询问别的 DNS： $ dig @1.1.1.1 examplecat.com examplecat.com. 299 IN A 1.2.3.4 1.1.1.1 更新了。 造成这样不同结果的原因，可能是此前并没有人询问过 1.1.1.1，所以他没有缓存，能立刻得到新的 IP。 而如果我们向新的 NS 查询，肯定会得到新的 IP 记录： $ dig @NS-cloud-b1.googledomaiNS.com examplecat.com examplecat.com. 300 IN A 1.2.3.4 ","date":"2020-07-02","objectID":"/dns_update/:2:4","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#连同-ns-一起更新"},{"categories":["Network"],"content":" NS 的 TTL 要长很多域名商提示：“修改将在 48 小时内生效” 的原因是 NS 记录（告诉递归 NS 应该向哪个 NS 查询）的 TTL 要长的多。 回到上一节中，我们的查询结果显示： $ dig @192.5.6.30 github.com ... github.com. 172800 IN NS NS-421.awsdNS-52.com. NS-421.awsdNS-52.com. 172800 IN A 205.251.193.165 ... 172800 秒是 48 小时！这就是为什么更改 NS 后需要更长的时间来生效。 ","date":"2020-07-02","objectID":"/dns_update/:2:5","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#ns-的-ttl-要长很多"},{"categories":["Network"],"content":" NS 如何得到更新？更新 NS 后，我们向根服务器查询的话就会到得到这样的结果： $ dig NS @j.gtld-servers.net examplecat.com examplecat.com. 172800 IN NS NS-cloud-b1.googledomaiNS.com 你可能会疑惑，新的 NS 记录是如何在根服务器处更新的呢？是因为当你在域名商那里更改你域名的 NS 后，他们会负责将这个给更改告知根服务器。 通常这个更新将在几分钟内就生效，但是对于其他一些顶级域名（TLD）（非.com）可能速度稍微慢一些。 ","date":"2020-07-02","objectID":"/dns_update/:2:6","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#ns-如何得到更新"},{"categories":["Network"],"content":" 总结本文展示了 DNS 的解析过程以及我们更新 DNS 记录时发送了什么，希望有助于你理解这一过程。 ","date":"2020-07-02","objectID":"/dns_update/:3:0","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#总结"},{"categories":["Network"],"content":" 参考 [1] What happens when you update your DNS? [2] unbound’s source code [3] iana root files ","date":"2020-07-02","objectID":"/dns_update/:4:0","series":null,"tags":["DNS","Translation"],"title":"深入浅出 DNS 解析","uri":"/dns_update/#参考"},{"categories":["Network"],"content":" 简要介绍 Nagle 算法 ","date":"2020-06-28","objectID":"/nagle/:0:0","series":null,"tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/#"},{"categories":["Network"],"content":" Nagle 算法Nagle 算法通过减少网络发包频率从而提高 TCP/IP 网络的效率。 主要解决由于 TCP 包头大小，导致频繁发送小数据包有效数据内容太少，开销过大段的问题。 Nagle 算法是将大量等待发送的小数据包合并起来，然后一次性全部发送出去。具体地说，只要有一个发送方没有收到任何确认的数据包，发送方就应该一直缓冲它的输出，直到它有一个完整的数据包的输出，这样就允许一次发送所有的输出。 其思路可以由下面的步骤所描述： if there is new data to send then if the window size ≥ MSS and available data is ≥ MSS then send complete MSS segment now else if there is unconfirmed data still in the pipe then enqueue data in the buffer until an acknowledge is received else send data immediately end if end if end if Nagle 算法可能导致期望实时响应和低延迟的应用程序体验不佳。 诸如网络多人视频游戏或鼠标在远程控制的操作系统中移动等应用程序，期望立即发送操作，而算法故意延迟传输，以牺牲延迟为代价提高带宽效率。因此，具有低带宽时间敏感传输的应用程序通常用于绕过 Nagle 延迟的 ACK 延迟。 ","date":"2020-06-28","objectID":"/nagle/:1:0","series":null,"tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/#nagle-算法"},{"categories":["Network"],"content":" Windows 下关闭 Nagle 算法 打开注册表编辑器 打开如下路径 计算机 \\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces 注册表界面 依次点击下方注册表项，检查右窗格中是否包含 DhcpIPAddress 值； 在包含有 DhcpIPAddress 的子项下，分别建立两个 DWORD (32) 值，依次命名为 TcpAckFrequency 和 TCPNoDelay，键值全部设为 1。 注意 包含 DhcpIPAddress 的子项可能不只一个，所有的都要添加。 ","date":"2020-06-28","objectID":"/nagle/:2:0","series":null,"tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/#windows-下关闭-nagle-算法"},{"categories":["Network"],"content":" 参考 [1] Nagel 算法维基百科 [2] RFC896 ","date":"2020-06-28","objectID":"/nagle/:3:0","series":null,"tags":["Nagle"],"title":"Nagle 算法","uri":"/nagle/#参考"},{"categories":["Linux"],"content":" Linux 记录一些常见的 Linux 服务器安全问题分析以及防护措施 ","date":"2020-06-07","objectID":"/linux_security/:0:0","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#"},{"categories":["Linux"],"content":" 日志分析","date":"2020-06-07","objectID":"/linux_security/:1:0","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#日志分析"},{"categories":["Linux"],"content":" 常用日志文件Debian 以及 RHEL 系的系统日志是由一个名为 syslog 的服务管理的，如以下日志文件都是由 syslog 日志服务驱动的： /var/log/boot.log：记录了系统在引导过程中发生的事件，就是 Linux 系统开机自检过程显示的信息 /var/log/lastlog ：记录最后一次用户成功登陆的时间、登陆 IP 等信息 /var/log/messages ：记录 Linux 操作系统常见的系统和服务错误信息 /var/log/secure ：Linux 系统安全日志，记录用户和工作组变坏情况、用户登陆认证情况 /var/log/syslog：只记录警告信息，常常是系统出问题的信息，使用 lastlog 查看 /var/log/wtmp：该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件，使用 last 命令查看 /var/run/utmp：该日志文件记录有关当前登录的每个用户的信息。如 who、w、users、finger 等就需要访问这个文件 /var/log/btmp：记录 Linux 登陆失败的用户、时间以及远程 IP 地址 /var/log/auth.log 或 /var/log/secure 存储来自可插拔认证模块 (PAM) 的日志，包括成功的登录，失败的登录尝试和认证方式。 注：Debian 系在 /var/log/auth.log 中存储认证信息而 RHEL 系则在 /var/log/secure 中存储。 Archlinux 使用 systemd 提供的日志系统（logging system），称为 journal。使用 systemd 日志，无需额外安装日志服务（syslog）。 ","date":"2020-06-07","objectID":"/linux_security/:1:1","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#常用日志文件"},{"categories":["Linux"],"content":" 相关日志查看命令 $ cat /var/log/secure | awk '/Failed/{print $(NF-3)}' | sort | uniq -c | awk '{print $2\"=\"$1;}' 查看尝试暴力登录 root 的 IP 及次数 $ grep \"Failed password for root\" /var/log/auth.log | awk '{print $11}' | sort | uniq -c | sort -nr | more ","date":"2020-06-07","objectID":"/linux_security/:1:2","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#相关日志查看命令"},{"categories":["Linux"],"content":" 常见防护措施","date":"2020-06-07","objectID":"/linux_security/:2:0","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#常见防护措施"},{"categories":["Linux"],"content":" SSH 编辑 SSH 配置文件 $ vim /etc/ssh/sshd_config 1、修改端口 #Port 22 —\u003e Port xxxx 2、关闭 root 登录 PermitRootLogin yes -\u003e PermitRootLogin no 3、使用证书登录 若不存在证书首先执行下面步骤 在客户端生成密钥: $ ssh-keygen -t rsa 把公钥拷贝至服务器: $ ssh-copy-id -i .ssh/id_rsa.pub server 或手动将 id_rsa.pub 拷贝至服务器用户目录的.ssh 中，并修改访问权限： $ scp .shh/id_rsa.pub server:~/.ssh 服务器中： $ chmod 400 authorized_keys 打开证书登录： RSAAuthentication yes 开启公钥验证： PubkeyAuthentication yes 验证文件路径： AuthorizedKeysFile .ssh/authorized_keys 禁止密码认证： PasswordAuthentication no 禁止空密码： PermitEmptyPasswords no 最后，重启 SSHD 服务 $ systemctl restart sshd ","date":"2020-06-07","objectID":"/linux_security/:2:1","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#ssh"},{"categories":["Linux"],"content":" SSH 编辑 SSH 配置文件 $ vim /etc/ssh/sshd_config 1、修改端口 #Port 22 —\u003e Port xxxx 2、关闭 root 登录 PermitRootLogin yes -\u003e PermitRootLogin no 3、使用证书登录 若不存在证书首先执行下面步骤 在客户端生成密钥: $ ssh-keygen -t rsa 把公钥拷贝至服务器: $ ssh-copy-id -i .ssh/id_rsa.pub server 或手动将 id_rsa.pub 拷贝至服务器用户目录的.ssh 中，并修改访问权限： $ scp .shh/id_rsa.pub server:~/.ssh 服务器中： $ chmod 400 authorized_keys 打开证书登录： RSAAuthentication yes 开启公钥验证： PubkeyAuthentication yes 验证文件路径： AuthorizedKeysFile .ssh/authorized_keys 禁止密码认证： PasswordAuthentication no 禁止空密码： PermitEmptyPasswords no 最后，重启 SSHD 服务 $ systemctl restart sshd ","date":"2020-06-07","objectID":"/linux_security/:2:1","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#编辑-ssh-配置文件"},{"categories":["Linux"],"content":" 用户以及用户组管理 无用用户、用户组Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#用户以及用户组管理"},{"categories":["Linux"],"content":" 用户以及用户组管理 无用用户、用户组Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#无用用户用户组"},{"categories":["Linux"],"content":" 用户以及用户组管理 无用用户、用户组Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#空口令账户"},{"categories":["Linux"],"content":" 用户以及用户组管理 无用用户、用户组Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#登录失败后强制延时"},{"categories":["Linux"],"content":" 用户以及用户组管理 无用用户、用户组Linux 系统中可以删除的默认用户和组大致有如下这些： 可删除的用户，如 adm,lp,sync,shutdown,halt,news,uucp,operator,games,gopher 等。 可删除的组，如 adm,lp,news,uucp,games,dip,pppusers,popusers,slipusers 等。 空口令账户使用如下命令检测空口令账户： $ awk -F: '$2==\"!!\" {print $1}' /etc/shadow 然后查看 /etc/passwd 确认空口令用户是否可以登录，选择是否加固密码。 登录失败后强制延时在 /etc/pam.d/system-login 中添加 auth optional pam_faildelay.so delay=4000000，表示延时 4 秒（单位微秒） 限制 root 权限可以为单个用户启用单个程序的 root 权限，而不用为了运行一个程序启用该用户对 root 的完整访问权。例如，要授予用户 alice 对特定程序的访问权限： 编辑 /etc/sudoers $ visudo 若要指定 visudo 的默认编辑器，最好是修改 /etc/sudoers 中的 Defaults editor=xxxx 而不是使用 $ EDITOR=nano visudo 因为任何程序都可以通过该命令指定作为编辑器，存在风险。 添加： alice ALL = NOPASSWD: /path/to/program ","date":"2020-06-07","objectID":"/linux_security/:2:2","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#限制-root-权限"},{"categories":["Linux"],"content":" 关闭不必要的服务例如 某台 Linux 服务器用于 www 应用，那么除了 httpd 服务和系统运行是必须的服务外，其他服务都可以关闭。下面这些服务一般情况下是不需要的，可以选择关闭： anacron、auditd、autofs、avahi-daemon、avahi-dnsconfd、bluetooth、cpuspeed、firstboot、gpm、haldaemon、hidd、ip6tables、ipsec、isdn、lpd、mcstrans、messagebus、netfs、nfs、nfslock、nscd、pcscd portmap、readahead_early、restorecond、rpcgssd、rpcidmapd、rstatd、sendmail、setroubleshoot、yppasswdd ypserv ","date":"2020-06-07","objectID":"/linux_security/:2:3","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#关闭不必要的服务"},{"categories":["Linux"],"content":" 文件系统安全文件权限检查和修改 （1）查找系统中任何用户都有写权限的文件或目录 $ find / -type f -perm -2 -o -perm -20 |xargs ls -al //查找文件 $ find / -type d -perm -2 -o -perm -20 |xargs ls –ld //查找目录 （2）查找系统中所有含 “s” 位的程序 $ find / -type f -perm -4000 -o -perm -2000 -print | xargs ls –al 含有 “s” 位权限的程序对系统安全威胁很大，通过查找系统中所有具有 “s” 位权限的程序，可以把某些不必要的 “s” 位程序去掉，这样可以防止用户滥用权限或提升权限的可能性。 （3）检查系统中所有 suid 及 sgid 文件 $ find / -user root -perm -2000 -print -exec md5sum {} ; $ find / -user root -perm -4000 -print -exec md5sum {} ; 将检查的结果保存到文件中，可在以后的系统检查中作为参考。 （4）检查系统中没有属主的文件 $ find / -nouser -o –nogroup 没有属主的孤儿文件比较危险，因此找到这些文件后，要么删除掉，要么修改文件的属主，使其处于安全状态。 ","date":"2020-06-07","objectID":"/linux_security/:2:4","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#文件系统安全"},{"categories":["Linux"],"content":" 常用防护软件","date":"2020-06-07","objectID":"/linux_security/:3:0","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#常用防护软件"},{"categories":["Linux"],"content":" fail2banfail2ban 通过扫描日志文件，筛选登录失败后继续频繁尝试登录的同一来源的非善意行为，根据用户定义的规则对访问来源做响应的封禁处理。 1、安装 以 debian 为例： $ sudo apt update $ sudo apt install fail2ban 2、复制配置文件 fail2ban 安装在 /etc/fail2ban 路径下,监控目标在 /etc/fail2ban/jail.conf 文件中，官方建议自定义的监控目标放在 /etc/fail2ban/jail.local 或者在 /etc/fail2ban/jail.d 目录中新建配置文件。因此，这里首先复制一份本地配置文件： $ cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local 3、修改配置文件 配置文件中的一些全局关键字段说明： ignoreip = 127.0.0.1 # \"ignoreip\" 是指不会被禁止访问的主机地址，它可以是单 IP 地址、CIDR （汇聚网段）地址，甚至可以是 DNS （主机域名），若有多个条目，各条目间用空格分隔。 bantime = 3600 # \"bantime\" 字段设置禁止访问的时间间隔，以秒为单位。 findtime = 600 # \"findtime\" 是指在指定时间间隔内，达到或超过 \"Maxretry\" 次失败连接尝试，即被命中，禁止访问，以秒为单位。 Maxretry = 3 # \"Maxretry\" 是指最大尝试次数。 此外，fail2ban 使用 jail 的概念对每个需要保护的服务进行配置，其中配置文件中已经对常见的服务进行了预设，当然，你也可以自定义不同服务的详细信息。jail 的模板如下： [xxx] #jail的名字 enabled = true #是否启用 port = xxxx #需要进行保护的端口 filter = xxxx #指定 SSH 监控使用的规则过滤配置文件，大量默认规则保存在 /etc/fail2ban/filter.d，使用默认规则直接输入名称即可。 action = xxxx #发现恶意IP后采取的操作。action.d 目录中预定义了许多常用操作，例如调用 iptables/firewalld 封禁、sendmail 发送通知邮件； logpath = xxxxxxxx #指定 fail2ban 监控日志文件路径，可换行输入多个路径 bantime = xxxx findtime = xxxx maxretry = xxxx 以保护 SSH 为例编辑配置文件jail.local，开启 ssh 保护，其中可定义多个字段： [ssh] enabled = true port = ssh filter = sshd action = iptables[name=SSH, port=ssh, protocol=tcp] logpath = /var/log/auth.log maxretry = 6 其余未设置的项尊崇全局设置。 4、启动并查看状态 配置好后保存配置文件，设置开启启动并启动 fail2ban： $ systemctl enable fail2ban $ systemctl start fail2ban 查看 fail2ban 的运行状态 $ fail2ban-client status 输出 Status |- Number of jail: 1 `- Jail list: sshd 需要查看详情，则只需使用 $ fail2ban-client status sshd 即可输出对应 jail 的详细信息，如： Status for the jail: sshd |- Filter | |- Currently failed: 0 | |- Total failed: 2479 | `- File list: /var/log/auth.log `- Actions |- Currently banned: 4 |- Total banned: 118 `- Banned IP list: 31.184.198.75 173.212.240.196 116.110.108.227 171.227.208.32 ","date":"2020-06-07","objectID":"/linux_security/:3:1","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#fail2ban"},{"categories":["Linux"],"content":" fail2banfail2ban 通过扫描日志文件，筛选登录失败后继续频繁尝试登录的同一来源的非善意行为，根据用户定义的规则对访问来源做响应的封禁处理。 1、安装 以 debian 为例： $ sudo apt update $ sudo apt install fail2ban 2、复制配置文件 fail2ban 安装在 /etc/fail2ban 路径下,监控目标在 /etc/fail2ban/jail.conf 文件中，官方建议自定义的监控目标放在 /etc/fail2ban/jail.local 或者在 /etc/fail2ban/jail.d 目录中新建配置文件。因此，这里首先复制一份本地配置文件： $ cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local 3、修改配置文件 配置文件中的一些全局关键字段说明： ignoreip = 127.0.0.1 # \"ignoreip\" 是指不会被禁止访问的主机地址，它可以是单 IP 地址、CIDR （汇聚网段）地址，甚至可以是 DNS （主机域名），若有多个条目，各条目间用空格分隔。 bantime = 3600 # \"bantime\" 字段设置禁止访问的时间间隔，以秒为单位。 findtime = 600 # \"findtime\" 是指在指定时间间隔内，达到或超过 \"Maxretry\" 次失败连接尝试，即被命中，禁止访问，以秒为单位。 Maxretry = 3 # \"Maxretry\" 是指最大尝试次数。 此外，fail2ban 使用 jail 的概念对每个需要保护的服务进行配置，其中配置文件中已经对常见的服务进行了预设，当然，你也可以自定义不同服务的详细信息。jail 的模板如下： [xxx] #jail的名字 enabled = true #是否启用 port = xxxx #需要进行保护的端口 filter = xxxx #指定 SSH 监控使用的规则过滤配置文件，大量默认规则保存在 /etc/fail2ban/filter.d，使用默认规则直接输入名称即可。 action = xxxx #发现恶意IP后采取的操作。action.d 目录中预定义了许多常用操作，例如调用 iptables/firewalld 封禁、sendmail 发送通知邮件； logpath = xxxxxxxx #指定 fail2ban 监控日志文件路径，可换行输入多个路径 bantime = xxxx findtime = xxxx maxretry = xxxx 以保护 SSH 为例编辑配置文件jail.local，开启 ssh 保护，其中可定义多个字段： [ssh] enabled = true port = ssh filter = sshd action = iptables[name=SSH, port=ssh, protocol=tcp] logpath = /var/log/auth.log maxretry = 6 其余未设置的项尊崇全局设置。 4、启动并查看状态 配置好后保存配置文件，设置开启启动并启动 fail2ban： $ systemctl enable fail2ban $ systemctl start fail2ban 查看 fail2ban 的运行状态 $ fail2ban-client status 输出 Status |- Number of jail: 1 `- Jail list: sshd 需要查看详情，则只需使用 $ fail2ban-client status sshd 即可输出对应 jail 的详细信息，如： Status for the jail: sshd |- Filter | |- Currently failed: 0 | |- Total failed: 2479 | `- File list: /var/log/auth.log `- Actions |- Currently banned: 4 |- Total banned: 118 `- Banned IP list: 31.184.198.75 173.212.240.196 116.110.108.227 171.227.208.32 ","date":"2020-06-07","objectID":"/linux_security/:3:1","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#以保护-ssh-为例"},{"categories":["Linux"],"content":" 参考 [1] Linux 服务器为什么被黑？ [2] linux 系统安全加固 – 账号相关 [3] Security - Archlinux Wiki ","date":"2020-06-07","objectID":"/linux_security/:4:0","series":null,"tags":["Security"],"title":"Linux 安全分析与加固","uri":"/linux_security/#参考"},{"categories":["Software"],"content":" Huginn 简单介绍使用 Docker 运行的 Huginn 数据的备份与恢复 ","date":"2020-05-27","objectID":"/huginn_backup/:0:0","series":null,"tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/#"},{"categories":["Software"],"content":" 备份数据使用命令在容器中生成备份： $ docker exec -it huginn mysqldump --single-transaction --opt -u root -ppassword huginn_production \u003e huginn_backupfile.sql 或直接拷贝数据到容器外： $ docker exec -it huginn mysqldump -u root -ppassword huginn_production \u003e /root/test_db.sql ","date":"2020-05-27","objectID":"/huginn_backup/:0:1","series":null,"tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/#备份数据"},{"categories":["Software"],"content":" 恢复数据首先复制文件到 docker 中： $ docker cp /home/xxxx/huginn_backupfile.sql huginn:/app/huginn_backupfile.sql 然后进入 docker： $ docker exec -ti huginn bash 接下来恢复数据库: $ mysql -u root -ppassword huginn_production \u003c huginn_backupfile.sql ","date":"2020-05-27","objectID":"/huginn_backup/:0:2","series":null,"tags":["Software","Huginn"],"title":"Huginn（Docker）数据备份与恢复","uri":"/huginn_backup/#恢复数据"},{"categories":["VM"],"content":" Hyper-V 桥接模式 Hyper-V 没有 VM 的桥接模式可以选择，为了让虚拟机可以和宿主机同网段，需要搭建网桥。 创建网桥的步骤如下： 操作 -\u003e 虚拟交换机管理器 -\u003e 新建虚拟网络交换机 -\u003e 选择外部类型 -\u003e 创建虚拟交换机 -\u003e 设置连接类型为内部网络 -\u003e 应用 首先点击虚拟机右边的 Hyper-V 操作选项虚拟交换机管理器： 网络拓扑图 新建虚拟交换机： 网络拓扑图 将主机的网络和虚拟网络进行桥接： 网络拓扑图 设置虚拟机的 IP 与宿主机的 IP 为同一网段，方便进行连接。 ","date":"2020-05-20","objectID":"/hyper-v_bridging/:0:0","series":null,"tags":["Hyper-V","Q\u0026A"],"title":"Hyper-V 桥接网络","uri":"/hyper-v_bridging/#"},{"categories":["VM"],"content":" PVE 安装过程中遇到的问题以及解决方法 ","date":"2020-05-19","objectID":"/pve_q_a/:0:0","series":null,"tags":["Q\u0026A","Hyper-V"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/#"},{"categories":["VM"],"content":" PVE 安装 Q\u0026A近期将家里的服务器从 Hyper-V 迁移到 PVE 上。 目前安装有黑群晖、Openwrt、Ubuntu 18.09LTS 目前的网络拓扑图如下： 网络拓扑图 将安装过程中遇到的问题以及解决方法整理如下： ","date":"2020-05-19","objectID":"/pve_q_a/:0:0","series":null,"tags":["Q\u0026A","Hyper-V"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/#pve-安装-qa"},{"categories":["VM"],"content":" 1. Temporary failure in name resolution：由于开始使用路由器拨号，因此初次安装设置的 DNS 服务器为路由器地址，安装软路由后更改了地址，所以导致 DNS 服务器设置错误 192.168.1.190 \u003e 192.168.1.1 ","date":"2020-05-19","objectID":"/pve_q_a/:0:1","series":null,"tags":["Q\u0026A","Hyper-V"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/#1-temporary-failure-in-name-resolution"},{"categories":["VM"],"content":" 2. 群晖挂载硬盘：PVE 正确识别到了 NTFS 的一硬盘，但是群晖不能自动挂载。需要关机后，在 PVE 虚拟机管理界面，添加，然后重启才能识别。(否则显示为红色，同样的，移除硬件需要同样的操作) ","date":"2020-05-19","objectID":"/pve_q_a/:0:2","series":null,"tags":["Q\u0026A","Hyper-V"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/#2-群晖挂载硬盘"},{"categories":["VM"],"content":" 3. PVE 节点监视图不显示，时间为 1970-1-1：删除界面缓存文件即可： $ rm /var/lib/rrdcached/db/pve2-node ","date":"2020-05-19","objectID":"/pve_q_a/:0:3","series":null,"tags":["Q\u0026A","Hyper-V"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/#3-pve-节点监视图不显示时间为-1970-1-1"},{"categories":["VM"],"content":" 4. 群晖 socks 代理Openwrt 安装 luci-app-Privoxy，设置转发规则： $ /ip:port . ","date":"2020-05-19","objectID":"/pve_q_a/:0:4","series":null,"tags":["Q\u0026A","Hyper-V"],"title":"PVE 安装 Q\u0026A","uri":"/pve_q_a/#4-群晖-socks-代理"},{"categories":["Web"],"content":" 记录使用 Hugo 搭配 LoveIt 搭建本博客遇到的问题以及解决方案 LoveIt 停更后，迁移到 DoIt 依然适用 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:0","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#"},{"categories":["Web"],"content":" 1. 虚拟机中 Hugo server 无法远程访问hugo server 默认只会 bind localhost 使用： $ Hugo server --bind xxx.xxx.xxx.xxx 指定虚拟机 IP，即可通过同网域机器访问该 web 服务 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:1","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#1-虚拟机中-hugo-server-无法远程访问"},{"categories":["Web"],"content":" 2. 使用 git 信息生成文章上一次修改时间首先，启用 git 信息： enableGitInfo = true 然后，启用 gitRepo 参数： gitRepo = “/xxx/xxxx/.git/” 需要注意的是： 这里 .git 应该 init 在 Hugo 生成的项目根目录中 但是这样，如果只 push public 文件夹到 Github 上部署的话，网页上无法正确跳转对应的 commit 详情页。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:2","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#2-使用-git-信息生成文章上一次修改时间"},{"categories":["Web"],"content":" 3. 页面出现 %!(EXTRA string=xxxx)LoveIt Github Issue 提到该问题的解决方案 但实际通过修改 config.toml 中的defaultContentLanguage = \"zh\"为defaultContentLanguage = \"zh-cn\"即可解决。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:3","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#3-页面出现-extra-stringxxxx"},{"categories":["Web"],"content":" 4.开启 Gitalk 评论Gitalk 使用 Github 仓库的 Issue 页面存储评论内容。 因此，首先我们需要在 Github 新建一个仓库（推荐）用于存储评论。 接着打开 Settings \u003e Developer settings \u003e OAuth Apps ，点击 New OAuth App 新建 OAuth App 然后填写信息： Application name : 随便填写 Homepage URL : 随便填写 Application description : 随便填写 Authorization callback URL : 一定要填写你的博客地址 完成后，点击 Register application 完成注册。 然后找到博客项目根目录中的 config.toml ，修改以下字段： [params.page.comment.gitalk] enable = true owner = “techkoala” # 你的 Github 用户名 repo = “commets_of_blog” # 用于存储评论的仓库名 clientId = “xxxxxx” # 请于 OAuth App 页面获取 clientSecret = “xxxxxx” # 请于 OAuth App 页面获取 完成上述设置后，现在就可以正常使用 Gitalk 评论系统了。评论内容可以通过 Github 对应仓库的 Issue 页面进行管理。 ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:4","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#4开启-gitalk-评论"},{"categories":["Web"],"content":" 5.CDN 配置LoveIt 的默认的 CDN 数据文件位于 themes/LoveIt/assets/data/cdn/ 目录。 将该目录下的 jsdelivr.yml 移动到你的项目下相同路径： assets/data/cdn/。（如果需要使用别的 CDN，可以执行参考 CDN 网站的配置说明对 jsdelivr.yml 进行修改 然后修改 config.toml 文件中的： CSS 和 JS 文件的 CDN 设置 [params.cdn] CDN 数据文件名称, 默认不启用 (“jsdelivr.yml”) data = “jsdelivr.yml” ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:5","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#5cdn-配置"},{"categories":["Web"],"content":" 6.Hugo 矩阵渲染因为 hugo 默认的 Markdown 引擎先处理 Markdown，而反斜杠\\在 Markdown 中代表转义字符，所以双斜杠无法正确渲染矩阵， $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\ 0\u00261\\end{bmatrix}$ 解决办法是在 Katex 原始语法再加入一个斜杠就好了 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ ","date":"2020-05-12","objectID":"/hugo_loveit_q_a/:0:6","series":null,"tags":["Hugo","Q\u0026A"],"title":"Hugo 搭配 LoveIt 技巧总结","uri":"/hugo_loveit_q_a/#6hugo-矩阵渲染"},{"categories":["Git"],"content":" 总结使用 Github 时遇到的问题以及解决方法 ","date":"2020-05-10","objectID":"/github_issue/:0:0","series":null,"tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/#"},{"categories":["Git"],"content":" 无法推送​ 首先，使用如下命令检查问题详情： $ ssh -vT git@github.com ​ 然后确认您的私钥已生成并加载到 SSH。 如果使用的是 OpenSSH 6.7 或更早版本： # 在后台启动 ssh-agent $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 $ ssh-add -l \u003e 2048 a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/you/.ssh/id_rsa (RSA) ​ 如果使用的是 OpenSSH 6.8 或更新版本： # 在后台启动 ssh-agent $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 $ ssh-add -l -E md5 \u003e 2048 MD5:a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/you/.ssh/id_rsa (RSA) ","date":"2020-05-10","objectID":"/github_issue/:1:0","series":null,"tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/#无法推送"},{"categories":["Git"],"content":" 确认公钥已附加到账户​ 在后台启动 SSH 代理程序。 $ eval \"$(ssh-agent -s)\" \u003e Agent pid 59566 ​ 找到并记录公钥指纹。 如果使用的是 OpenSSH 6.7 或更早版本： $ ssh-add -l \u003e 2048 a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/USERNAME/.ssh/id_rsa (RSA) ​ 如果使用的是 OpenSSH 6.8 或更新版本： $ ssh-add -l -E md5 \u003e 2048 MD5:a0:dd:42:3c:5a:9d:e4:2a:21:52:4e:78:07:6e:c8:4d /Users/USERNAME/.ssh/id_rsa (RSA) 如果没有添加，则 $ ssh-add /xxx/.ssh/xxx 注意 不知为何，使用自定义名字的密钥，每次 git 操作都要重新添加一次，尚不明确原因。 ","date":"2020-05-10","objectID":"/github_issue/:1:1","series":null,"tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/#确认公钥已附加到账户"},{"categories":["Git"],"content":" 添加到 Github​ Settings \u003e SSH and GPG keys \u003e 添加公钥即可 ","date":"2020-05-10","objectID":"/github_issue/:1:2","series":null,"tags":["Github"],"title":"Github 使用问题","uri":"/github_issue/#添加到-github"},{"categories":["Linux"],"content":" Linux 中如何查看进程信息？ Linux 中常使用 ps 命令显示当前运行中进程的相关信息的一份快照，包括 PID 等等。而 top 命令可以实时刷新进程信息，包括 CPU 占用，内存占用等等。 ","date":"2020-03-02","objectID":"/process/:0:0","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#"},{"categories":["Linux"],"content":" ps 命令Linux 上进程有 5 种状态： 运行(正在运行或在运行队列中等待) 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放) 停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行) ps 工具标识进程的 5 种状态码： D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (“zombie”) process ","date":"2020-03-02","objectID":"/process/:1:0","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#ps-命令"},{"categories":["Linux"],"content":" 语法 $ ps [选项] ","date":"2020-03-02","objectID":"/process/:1:1","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#语法"},{"categories":["Linux"],"content":" 选项 -a： 显示所有终端机下执行的程序，除了阶段作业领导者之外。 a： 显示现行终端机下的所有程序，包括其他用户的程序。 -A： 显示所有程序。 -c： 显示CLS和PRI栏位。 c： 列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。 -C\u003c指令名称\u003e： 指定执行指令的名称，并列出该指令的程序的状况。 -d： 显示所有程序，但不包括阶段作业领导者的程序。 -e： 此选项的效果和指定\"A\"选项相同。 e： 列出程序时，显示每个程序所使用的环境变量。 -f： 显示UID,PPIP,C与STIME栏位。 f： 用ASCII字符显示树状结构，表达程序间的相互关系。 g： 显示现行终端机下的所有程序，包括群组领导者的程序。 -G\u003c群组识别码\u003e：列出属于该群组的程序的状况，也可使用群组名称来指定。 h： 不显示标题列。 -H： 显示树状结构，表示程序间的相互关系。 -j或j： 采用工作控制的格式显示程序状况。 -l或l： 采用详细的格式来显示程序状况。 L： 列出栏位的相关信息。 -m或m： 显示所有的执行绪。 n： 以数字来表示USER和WCHAN栏位。 -N： 显示所有的程序，除了执行ps指令终端机下的程序之外。 -p\u003c程序识别码\u003e：指定程序识别码，并列出该程序的状况。 r： 只列出现行终端机正在执行中的程序。 -s\u003c阶段作业\u003e： 指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。 s： 采用程序信号的格式显示程序状况。 S： 列出程序时，包括已中断的子程序资料。 -t\u003c终端机编号\u003e：指定终端机编号，并列出属于该终端机的程序的状况。 -T： 显示现行终端机下的所有程序。 u： 以用户为主的格式来显示程序状况。 -U\u003c用户识别码\u003e：列出属于该用户的程序的状况，也可使用用户名称来指定。 U\u003c用户名称\u003e： 列出属于该用户的程序的状况。 v： 采用虚拟内存的格式显示程序状况。 -V或V： 显示版本信息。 -w或w： 采用宽阔的格式来显示程序状况。　x： 显示所有程序，不以终端机来区分。 -y： 配合选项\"-l\"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位。 --headers： 重复显示标题列。 --help： 在线帮助。 --info： 显示排错信息。 ","date":"2020-03-02","objectID":"/process/:1:2","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#选项"},{"categories":["Linux"],"content":" 实例显示所有运行中的进程： $ ps aux | less 查看系统中的每个进程： $ ps -A 或 $ ps -e 查看非 root 运行的进程： $ ps -U root -u root -N 查看用户 xxx 运行的进程 $ ps -u xxx 获得线程信息： $ ps -eLf $ ps axms 获得安全信息： $ ps -eo euser,ruser,suser,fuser,f,comm,label $ ps axZ $ ps -eM 显示进程的树状图： $ ps -ejH $ ps axjf 此外 pstree 也可以以树状显示正在运行的进程。树的根节点为 pid 或 init。如果指定了用户名，进程树将以用户所拥有的进程作为根节点。 $ pstree 查找进程： ps 可以打搭配 grep 进行指定关键词进程的查找： $ ps aux | grep zsh 此外使用 pgrep 也能查找当前正在运行的进程并列出符合条件的进程 ID。 例如显示 firefox 的进程 ID： $ pgrep firefox 显示进程名为 sshd、所有者为 root 的进程： $ pgrep -u root sshd ","date":"2020-03-02","objectID":"/process/:1:3","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#实例"},{"categories":["Linux"],"content":" top 命令top 命令提供了运行中系统的动态实时视图。 ","date":"2020-03-02","objectID":"/process/:2:0","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#top-命令"},{"categories":["Linux"],"content":" 语法 $ top [参数] ","date":"2020-03-02","objectID":"/process/:2:1","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#语法-1"},{"categories":["Linux"],"content":" 参数 -b 批处理 -c 显示完整的治命令 -I 忽略失效过程 -s 保密模式 -S 累积模式 -i\u003c时间\u003e 设置间隔时间 -u\u003c用户名\u003e 指定用户名 -p\u003c进程号\u003e 指定进程 -n\u003c次数\u003e 循环显示的次数 top 命令 按 q 退出，按 h 进入帮助。 ","date":"2020-03-02","objectID":"/process/:2:2","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#参数"},{"categories":["Linux"],"content":" 实例将进程快照储存到文件中： $ top -b -n1 \u003e /tmp/process.log 将结果通过邮件发送： $ top -b -n1 | mail -s 'Process snapshot' you@example.com ","date":"2020-03-02","objectID":"/process/:2:3","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#实例-1"},{"categories":["Linux"],"content":" HtopHtop 是一个类似 top 的交互式进程查看工具，可以垂直和水平滚动来查看所有进程和他们的命令行。进程的相关操作(killing，renicing)不需要输入 PID。Htop 一般需要自行安装。 $ htop Htop 命令 ","date":"2020-03-02","objectID":"/process/:3:0","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#htop"},{"categories":["Linux"],"content":" atopatop 是一个用来查看 Linux 系统负载的交互式监控工具。它能展现系统层级的关键硬件资源(从性能角度)的使用情况，如 CPU、内存、硬盘和网络。 $ atop atop 命令 ","date":"2020-03-02","objectID":"/process/:4:0","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#atop"},{"categories":["Linux"],"content":" 参考 [1] 如何在 Linux 中查看所有正在运行的进程 [2] 每天一个linux命令（41）：ps命令 ","date":"2020-03-02","objectID":"/process/:5:0","series":null,"tags":["Commands"],"title":"查看 Linux 进程信息","uri":"/process/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 物理信号详解 ","date":"2020-02-20","objectID":"/lte_physical_signals/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#"},{"categories":["WirelessCommunication"],"content":" 导频信号","date":"2020-02-20","objectID":"/lte_physical_signals/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#导频信号"},{"categories":["WirelessCommunication"],"content":" 下行导频信号物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#下行导频信号"},{"categories":["WirelessCommunication"],"content":" 下行导频信号物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#导频序列"},{"categories":["WirelessCommunication"],"content":" 下行导频信号物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#导频图案"},{"categories":["WirelessCommunication"],"content":" 下行导频信号物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#小区公用导频信号"},{"categories":["WirelessCommunication"],"content":" 下行导频信号物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#mbsfn-导频"},{"categories":["WirelessCommunication"],"content":" 下行导频信号物理层定义了 3 种下行导频信号（Reference Signal，RS），包括： 普通子帧的小区导频信号（Cell-specific RS，CRS） 指的是小区在下行普通子帧中全频带广播发送的导频信号，该信号以小区为单位，可以作为小区内用户进行下行测量、同步以及数据解调的参考符号 MBSFN 导频信号 指的是小区在下行 MBSFN 子帧中全频带广播发送的导频符号，该信号以 MBSFN 小区或小区集合为单位，可以用作对广播／多播（Malticast/Broadcast）业务情况下的下行测量、同步以及数据解调的参考符号 用户专用导频信号（UE-specific RS，又称为 DRS，Dedicated RS） 指的是小区在下行普通子帧中发送的用户专用的导频信号，该信号以用户为单位，通过高层信令指示是否发送了该信号并且用作用户下行数据解调的参考符号。DRS 仅在承载该用户数据的资源块上传输。 导频序列使用 gold 序列 生成的伪随机（PN）序列作为物理层下行导频信号（CRS/MBSFN RS/DRS）使用的复数序列，序列的数学表达式是： $r_{l,n_s}=\\frac{1}{\\sqrt{2}}(1-2c(2m))+j\\frac{1}{\\sqrt{2}}(1-2c(2m+1))$ 其中，$c(n)$是寄存器长度为 31 的 gold 序列，生成的序列由初始值 cinit 所确定。 3 种下行导频信号，根据各自的特性，序列的初始值有相应的设置方法。 对于普通子帧的小区导频信号，即 CRS。信号的发送以小区为单位，每个小区有各自的导频序列，序列的初始值与 小区 ID（$N_{ID}^{cell}$ ，0 ～ 503）相关。为了保证导频序列具有充分的随机性，在每个包含 CRS 的 OFDM 符号上，根据 OFDM 符号的位置（时隙在无线帧中的编号 ns ：0 ～ 19、OFDM 符号在时隙内的序号：0 ～ 6/0 ～ 5）、小区使用的 CP 选项（NCP =1/0：Normal CP/Extended CP）结合前面提到的 小区 ID（$N_{ID}^{cell}$）共同确定该符号上所使用的 CRS 导频序列的初始值。具体的数学表达式为： $c_{init}=2^{10}(7(n_s+1)+l+1)(2N_{ID}^{cell}+1)+2N_{ID}^{cell}+N_{CP}$ 对于 MBSFN 导频信号，信号的发送以 MBSFN 小区／小区集合为单位。序列的初始值与 MBSFN ID 相关，在每个包含 MBSFN 导频的 OFDM 符号 上，根据 OFDM 符号 的位置和 MBSFN ID 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=2^9(7(n_s+1)+l+1)(2N_{ID}^{MBSFN}+1)+N_{ID}^{MBSFN}$ 用户专用导频信号，即 DRS。信号的发送以用户为单位，每个用户有各自的导频。序列以子帧为单位进行初始化，在每个子帧的开始，根据 子帧的位置、小区 ID（alt ）以及 用户的 RNTI 共同确定导频序列的初始值。具体的数学表达式为： $c_{init}=(\\left\\lfloor\\frac{n_s}{2}\\right\\rfloor)(2N_{ID}^{cell}+1)2^{16}+n_{RNTI}$ 导频图案导频信号在时频域的图案规定了放置导频符号的时频域资源位置，LTE 物理层导频图案采用了二维的设计方法，规定了下行各个天线端口（Antenna port）导频信号的时频域位置，包括： 普通子帧的小区公用导频信号（CRS）支持 1 ～ 4 个发送天线使用的 Antenna port 0 ～ 3 用于 MBSFN 发送的 Antenna port 4 用于用户专用导频（DRS）的 Antenna port 5 小区公用导频信号小区公用导频信号支持最多 4 个天线端口的发送（port 0 ～ 3） 对于前 2 个天线端口（port 0 ～ 1），每个时隙有 2 个 OFDM 符号携带导频符号 对于后 2 个天线端口（port 2 ～ 3），每个时隙有 1 个 OFDM 符号携带导频符号 在每个 OFDM 符号内导频符号的频域间隔为 6 个子载波，采用交错放置的方式。 下行正常子帧小区导频信号图案（CRS） 为了避免同基站不同发射天线端口之间导频与数据的干扰，在某一天线端口的导频位置上，同一基站的其他天线端口空出相应的时频资源。小区 CRS 导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免不同小区的导频之间的同频干扰。 MBSFN 导频MBSFN 导频采用单天线端口的发送，即 port 4。由于 MBSFN 广播／多播的业务特性，较大的小区半径和多小区信号的合并带来的时延扩展增加了无线信道的频率选择性。为了适应这样的特点，导频采用较小的频域间隔，即每 2 个子载波放置 1 个导频符号（在 MBSFN 专用载波采用 7.5kHz 子载波间隔时，每 4 个子载波放置 1 个导频符号）。另外，根据广播业务的移动性特点，适当地降低了导频信号在时间上的密度。 下行 MBSFN 导频图案 MBSFN 导频只支持在 Extended CP 情况下发送。MBSFN 导频子载波在频域的绝对位置与小区 ID 无关，各小区导频在相同的频域位置，实现 MBSFN 集合内的不同小区导频信号的宏分集接收。 用户专用导频LTE Release 8 中用户专用导频信号采用单天线端口的发送，即天线端口 5。通过高层信令的指示，通知终端在数据传输中是否使用了用户专用导频，以及终端是否应该使用用户专用导频进行下行数据的解调。（DRS 主要用于支持下行波束赋形，即 BeamForming 操作） 在发送 UE specific 的专用导频时，保持小区公用导频信号（CRS）不变，插入用户专用导频符号，每个 PRB pair 中发送 12 个用户专用导频符号。 下行用户专用导频图案 用户专用导频子载波在频域的绝对位置与小区 ID 相关，因此不同小区之间形成频域的相对偏移，避免导频之间的同频干扰。 在专用导频与物理信道／信号（PBCH/PSS/SSS）发生位置冲突的时候，将丢弃冲突位置的专用导频的传输，即对专用导频进行打孔。因为仅在有数据发送时才进行 DRS 的传输，而小区导频 CRS 是始终在传输的，因此，即使用户数据的发送使用了 DRS，用户对于下行信道质量，即 CQI 的测量将始终基于小区 CRS 导频。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#用户专用导频"},{"categories":["WirelessCommunication"],"content":" 上行导频信号物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#上行导频信号"},{"categories":["WirelessCommunication"],"content":" 上行导频信号物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#导频序列-1"},{"categories":["WirelessCommunication"],"content":" 上行导频信号物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#导频图案-1"},{"categories":["WirelessCommunication"],"content":" 上行导频信号物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#上行共享信道-pusch-的解调导频"},{"categories":["WirelessCommunication"],"content":" 上行导频信号物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#上行控制信道-pucch-的解调导频"},{"categories":["WirelessCommunication"],"content":" 上行导频信号物理层定义了两种上行导频信号，包括： 数据解调导频（DeModulation RS，DMRS） 指的是终端在上行共享信道或者上行控制信道（PUSCH/PUCCH）中发送的导频信号，用于基站接收上行数据／控制信息时进行解调的参考符号 Sounding 导频（Sounding RS，SRS） 指的是终端在上行发送的用于信道状态测量的导频信号，基站通过接收该信号测量上行信道的状态，相关的信息用于对上行数据传输的自适应调度。在 TDD 的情况下，由于同频段上下行信道的对称性，通过对上行 SRS 的测量还可以获得下行信道状态的信息，可用于辅助下行传输 导频序列使用具有衡包络零自相关（ConstantAmplitude ZeroAutoCorrelation，CAZAC）特性的序列作为上行导频序列（DMRS/SRS），长度为 $M_{SC}^{RS}$ 的导频序列的数学表达式为： $r_{u,v}^{(α)}=e^{jan}\\bar{r}_{u,v}(n) , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $\\bar{r}_{u,v}(n)$ 表示基序列，由基序列组的编号 u和组内的基序列编号 v共同确定。$α$ 是对基序列的循环移位（Cyclic Shift），相同基序列的不同移位将形成不同的导频序列。 对于长度大于或者等于 36 的导频序列，使用长度为质数的 Zadoff-Chu 序列生成基序列，以保证良好的自相关和互相关特性，序列的数学表达式是： $\\bar{r}_{u,v}(n)=x_q(n mod N_{ZC}^{RS} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $x_q$ 是序号为 q、长度是 $N_{ZC}^{RS}$ 的 Zadoff-Chu 根序列，即 $x_q(m)=e^-j\\frac{\\pi qm(m+1)}{N_{ZC}^{RS}}$ 。序号 q 由基序列的编号 $\\frac{u}{v}$ 确定，长度 $N_{ZC}^{RS}$ 是小于导频序列长度 $M_{SC}^{RS}$ 的最大质数。 对于长度小于 36，即长度为 12 或者 24 的导频序列，使用计算机搜索的方法以获得自相关／互相关特性最优的序列。序列的数学表达式为： $\\bar{r}_{u,v}(n)=e^{jϕ（n）\\pi/4} , 0\\leqslant n \\leqslant M_{SC}^{RS}-1$ 其中 $ϕ(n)$采用计算机搜索的方式进行查找，在标准中以列表的形式给出了确定的数值。 导频图案 上行解调导频（DMRS）在用户发送数据或者控制信息的资源上发送 在共享信道 PUSCH 上，每个时隙内 DMRS 占用 1 个 OFDM 符号 在控制信道 PUCCH 上，根据控制信息格式的不同，每个时隙内 DMRS 占用 2 ～ 3 个 OFDM 符号。 上行 Sounding 导频（SRS）与用户发送数据的资源位置无关，由系统调度，终端在预定义的、需要进行测量的频率位置上进行发送，发送时将占用子帧的最后一个 OFDM 符号，小区内不同用户在相同时刻发送的 SRS 采用频分和码分（基序列不同的循环移位）的方式进行区分。 上行共享信道 PUSCH 的解调导频上行共享信道 PUSCH 的解调导频在每个时隙内占用 1 个 OFDM 符号，在用户发送上行数据的资源上发送，用于共享信道（PUSCH）数据的解调。 上行 PUSCH 数据解调导频 每个时隙的导频符号采用 12 或者 24 的导频序列。其中 $M_{SC}^{RS}$ 是导频序列的长度，等于频域子载波的个数。导频序列由小区在该时隙的上行导频基序列 $\\bar{r}_{u,v}(n)$ 和本次发送采用的循环移位 $α$共同确定。 上行控制信道 PUCCH 的解调导频上行控制信道 PUCCH 的解调导频根据上行控制信道格式的不同在每个时隙内占用 2 或者 3 个 OFDM 符号，用于控制信道（PUCCH）数据的解调。 PUCCH 格式 1/1a/1b 的导频发送格式。 PUCCH Format1/1a/1b 的解调导频（Normal CP） 其中 $\\bar{w}(m)$ 是长度为 3 的正交扩频序列。$r_{u,v}^{\\alpha}$ 表示基序列序号为 $u,v$，循环移位为 $α$ 的导频序列，长度是 12，映射在 1 个 PRB 内的子载波上。 PUCCH Format1/1a/1b 中导频映射的过程包括：时隙内采用正交序列的块扩频，然后与长度为 12 的导频 CACAZ 序列相乘，最后映射在上行控制信息 PUCCH 所对应的 PRB 资源的 12 个子载波上。 PUCCH 格式 2/2a/2b 的导频发送格式。 PUCCH Format2/2a/2b 的解调导频（Normal CP） 上行 Sounding 导频信号上行 Sounding 导频信号的发送与上行物理信道无关，是独立的的上行信号，根据预定义的周期、终端在需要进行信道测量的频域位置上进行发送。 上行 Sounding 导频（SRS）在子帧的最后一个 OFDM 符号上发送。在每个小区，采用配置小区 SRS 子帧周期 TSFC 和偏移量 ∆SFC 的方式，定义了小区内可用于发送上行 Sounding 导频符号的子帧时间位置，标准中列表给出了各种可能的配置选项，在系统广播消息 SIB 中使用 4 个比特进行指示。 例如，假设配置 $T_{SFC} =5，∆SFC ={0,1}$，那么小区 SRS 子帧的时间位置如图所示。 小区的 SRS 子帧时间位置 在定义小区 SRS 子帧位置的基础上，采用类似的方法进一步定义了小区内某个用户发送上行 SRS 导频的子帧位置，即通过配置用户发送 SRS 导频的子帧周期 TSRS 和偏移量 Toffset ，可以确定该用户发送上行 SRS 导频的子帧位置。 假设，在以上举例的小区 SRS 子帧配置的基础上，配置用户 x 的 $T_{SRS} =10，Toffset =1$，可以得到该用户 SRS 导频的发送时间位置如图所示。 用户的 SRS 子帧时间位置 Sounding 导频（SRS）使用与解调导频相似的基序列生成方法，只是它的循环移位的数值改由高层信令直接进行配置。 在导频序列向物理资源的映射上，SRS 导频采用 2 个子载波的频域间隔，形成梳状的频域结构，根据起始位置的不同（奇数或者偶数，kTC =0/1），可以频分复用 2 个梳状。相同的梳状内可以通过基序列不同的循环移位（8 种），以码分的方式进行更多的复用。 Sounding 导频图案 其中 SRS 导频带宽 $m_{SRS,b}$ 以资源块（RB）为单位，并且是 4 的整数倍。同时，可以容易地看出，导频序列的长度是 SRS 导频所占用子载波宽度的一半。 ","date":"2020-02-20","objectID":"/lte_physical_signals/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#上行-sounding-导频信号"},{"categories":["WirelessCommunication"],"content":" 同步信号（PSS/SSS）下行同步信号用于支持物理层的小区搜索，实现用户终端对小区的识别以及对系统下行信号的频率和时间同步。 同步信号包括： 主同步信号（Primary Synchronization Signal，PSS） 辅同步信号（Secondary Synchronization Signal，SSS） PSS 和 SSS 的传输周期都是 5ms，每个同步信号的时间长度为 1 个 OFDM 符号，在频域上占用下行频带中心 1.08MHz 的带宽。 PSS/SSS 信号使用的序列与物理层小区 ID 相关，因此可用于终端对小区的识别。 物理层支持 504 个小区 ID：分为 168 个组（0 ～ 167），每个组包含 3 个小区 ID（0 ～ 2）。 主同步信号 PSS 序列包含 3 种可能性，指示小区的组内 ID 辅同步信号 SSS 序列包含 168 种可能性，指示小区的组 ID FDD Type 1 和 TDD Type 2 帧结构中，同步信号具有不同的时间位置。 在 FDD Type 1 帧结构中，PSS/SSS 信号位于第 0 和第 5 子帧 在 TDD Type 2 中，PSS 信号位于第 1 和第 6 子帧（即特殊子帧），SSS 信号位于第 0 和第 5 子帧。 因此，两种帧结构下 PSS 与 SSS 的相对位置有所不同： FDD Type 1 帧结构中，PSS/SSS 位于两个连续的 OFDM 符号 TDD Type 2 帧结构中，PSS/SSS 之间有两个 OFDM 符号的间隔 这种同步信号相对位置的区别，可用于终端在小区搜索的最初阶段检测 LTE 系统的双工方式。 LTE 下行同步信号（FDD Type 1 帧结构） LTE 下行同步信号（TDD Type 2 帧结构） PSS 和 SSS 在相同的某一根天线上发送，对于各种不同的系统带宽（1.4MHz、3MHz、5MHz、10MHz、15MHz、20MHz），同步信号的传输带宽相同： 占用频带中心的 1.08MHz 带宽，其中同步序列占用 62 个子载波，两边各预留 5 个子载波作为保护带。 同步信号 PSS/SSS 频域结构 ","date":"2020-02-20","objectID":"/lte_physical_signals/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#同步信号psssss"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-02-20","objectID":"/lte_physical_signals/:3:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信号","uri":"/lte_physical_signals/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 多天线技术（MIMO）详解 ","date":"2020-02-01","objectID":"/lte_mimo/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#"},{"categories":["WirelessCommunication"],"content":" 多天线技术（MIMO）在收到信道编码后的数据（codeword）之后，物理层进一步的处理过程包括加扰、调制、层映射、预编码（precoding）以及针对各个物理天线端口的资源映射和 OFDM 信号生成的过程。 物理层数据处理过程 加扰操作是指使用扰码对经过信道编码后的数据进行逐比特的加扰，实现数据间干扰的随机化。采用伪随机码作为扰码，在每个子帧的起始位置，根据 RNTI（Radio Network Temporary Identifier）、Cell ID、Codeword 的编号以及无线帧内的时隙编号等信息，对扰码的 PN 序列 进行初始化。 调制指的是对比特数据进行复数调制，包括 QPSK、16QAM 或者 64QAM。 在完成调制后，物理层的基带处理过程将进行 MIMO 相关的处理，包括 层映射 和 预编码 。LTE Release 8 版本支持不同的发射天线数目（1 / 2 / 4），以及多种不同的 MIMO 方案，包括单天线发送、空间复用和发送分集。 ","date":"2020-02-01","objectID":"/lte_mimo/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#多天线技术mimo"},{"categories":["WirelessCommunication"],"content":" 层映射层映射实现信道编码之后的码字（Codeword）向空间多天线形成的多个层（layer）之间的映射。 对于单天线的情况，直观地可以得到：物理层使用 1 个码字，并且这个码字直接映射到单天线的 1 个层上 对于多天线实现空间复用的情况，当空间复用的层数目大于 1 的时候，可以同时发送 2 个码字 以 4×4 天线配置的情况为例，根据无线信道的情况可以支持 1、2、3 或者 4 个层的空间复用，当空间复用的层数目大于 1 的时候，可以将 2 个码字映射在这些层上采用空间复用的方式同时进行发送。对于发送分集的情况，使用 1 个码字，按照发送天线数目的不同（2 或者 4），对应于 2 或者 4 个层，此时这 1 个码字将以逐比特转换的方式映射到这些层上。 ","date":"2020-02-01","objectID":"/lte_mimo/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#层映射"},{"categories":["WirelessCommunication"],"content":" 预编码预编码（precoding）实现层到物理天线端口的映射。物理层使用不同的预编码方案，实现不同的 MIMO 模式：单天线发送、空间复用或者发送分集。 单天线发送对于单天线发送的情况，直观的可以得出，1 个层将直接映射到 1 个物理天线端口上。 空间复用对于多天线实现空间复用的情况，LTE 中采用基于码本（codebook）进行预编码向量选择的机制，分为开环和闭环两种复用传输模式，分别采用无循环延迟的预编码和大循环延迟的预编码。 在 2 个发送天线的情况时，基站一般使用线性阵列（Uniform LinearArray，ULA）的天线配置，因此，相对应地采用基于 DFT 正交距阵的码本设计方法。 对应于 1 个层的传输，设计了 4 个可供选择的预编码向量 对应于 2 个层的传输，设计了 3 个可供选择的预编码向量。 对于 4 个发送天线的情况，天线的部署要更为复杂，实际情况下可能不使用线性阵列的天线配置，而采用例如双极化天线 所以，基于对各种场景下的性能和复杂度等因素的综合考虑，选择了采用基于 householder 变换 的码本设计方法。对应于 1/2/3/4 个层的传输，均有 16 个可供选择的预编码向量。 预编码向量选取常用的两个准则： 信噪比最大化，对应于容量最大化。将每个可选择的项代入，得到一个等效信道矩阵，计算等效信噪比，选择对应 SNR 最大的向量元素。 最小码距，对应于最小误码率。计算信道信息给出的加权矩阵与码本中元素的距离，选择距离最小的作为预编码向量。 无循环延迟的预编码用于闭环的 MIMO 空间复用。闭环模式下，终端通过对下行信道状态的测量选择适当的空间复用的层数目，并且从码本集合中选择预编码向量，分别表示为 RI（Rank Indicator）和 PMI（Precoding Matrix Indicator）的形式通过上行链路反馈给基站。基站根据这些信息进行预测，确定随后的下行发送中将采用的空间复用方案（包括采用的层数目和预编码向量）。 大循环延迟的预编码用于开环的 MIMO 空间复用。开环模式下，终端不再向基站反馈预编码向量 PMI 的信息，但仍可以根据基站的配置测量并且反馈下行信道的 RI 信息，即空间复用的层数目。基站根据终端上报的 RI 信息或者自行确定的层数目，选择在下行发送中所采用的预编码方案，包括采用发送分集，或者空间复用以及相应的层数目。 在开环空间复用中，采用的预编码向量是固定的。 在使用 2 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案。 当选择 RI=2 时，采用对应码本的第一个元素，即 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ 作为预编码向量。 在使用 4 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案 当选择 RI=2/3/4 时，采用对应的码本，以发送时刻为单位，固定的循环使用码本中序号为 12/13/14/15 的元素作为预编码向量。 对于大循环延迟的预编码，除了预编码向量 $W (i)$ 之外，有两个用于完成循环延迟（Cyclic Delay Diversity，CDD）功能的矩阵，即 $U$ 和 $D (i)$。 假设层数目为 v，那么这两个矩阵的大小都是 $v×v$ 的，其中 $U$ 是 DFT 矩阵，通过对输入信号进行 DFT 变换实现层到虚拟天线的映射，将每个层的信号能量均匀地分布在虚拟天线上 $D (i)$是 CDD 矩阵，实现虚拟天线间增量为 $\\frac{1}{v}$ 的时延。 发送分集对于多天线实现发送分集的情况，分别采用 SFBC（Space Frequency Block Codiing）和 SFBC+FSTD（Frequency Switched Transmit Diversity）的方案支持 2 和 4 个发送天线的场景。 在 2 个发送天线时，使用 SFBC 的发送分集方案，实现“层”到物理天线映射的预编码操作。 SFBC 发送分集 在 4 个发送天线时，使用 SFBC+FSTD 的发送分集方案。相应地，实现层到物理天线映射的预编码操作可以表示为下图所示的形式，即 SFBC 结合 FSTD 在天线间频域的位置转换。 SFBC+FSTD 发送分集 ","date":"2020-02-01","objectID":"/lte_mimo/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#预编码"},{"categories":["WirelessCommunication"],"content":" 预编码预编码（precoding）实现层到物理天线端口的映射。物理层使用不同的预编码方案，实现不同的 MIMO 模式：单天线发送、空间复用或者发送分集。 单天线发送对于单天线发送的情况，直观的可以得出，1 个层将直接映射到 1 个物理天线端口上。 空间复用对于多天线实现空间复用的情况，LTE 中采用基于码本（codebook）进行预编码向量选择的机制，分为开环和闭环两种复用传输模式，分别采用无循环延迟的预编码和大循环延迟的预编码。 在 2 个发送天线的情况时，基站一般使用线性阵列（Uniform LinearArray，ULA）的天线配置，因此，相对应地采用基于 DFT 正交距阵的码本设计方法。 对应于 1 个层的传输，设计了 4 个可供选择的预编码向量 对应于 2 个层的传输，设计了 3 个可供选择的预编码向量。 对于 4 个发送天线的情况，天线的部署要更为复杂，实际情况下可能不使用线性阵列的天线配置，而采用例如双极化天线 所以，基于对各种场景下的性能和复杂度等因素的综合考虑，选择了采用基于 householder 变换 的码本设计方法。对应于 1/2/3/4 个层的传输，均有 16 个可供选择的预编码向量。 预编码向量选取常用的两个准则： 信噪比最大化，对应于容量最大化。将每个可选择的项代入，得到一个等效信道矩阵，计算等效信噪比，选择对应 SNR 最大的向量元素。 最小码距，对应于最小误码率。计算信道信息给出的加权矩阵与码本中元素的距离，选择距离最小的作为预编码向量。 无循环延迟的预编码用于闭环的 MIMO 空间复用。闭环模式下，终端通过对下行信道状态的测量选择适当的空间复用的层数目，并且从码本集合中选择预编码向量，分别表示为 RI（Rank Indicator）和 PMI（Precoding Matrix Indicator）的形式通过上行链路反馈给基站。基站根据这些信息进行预测，确定随后的下行发送中将采用的空间复用方案（包括采用的层数目和预编码向量）。 大循环延迟的预编码用于开环的 MIMO 空间复用。开环模式下，终端不再向基站反馈预编码向量 PMI 的信息，但仍可以根据基站的配置测量并且反馈下行信道的 RI 信息，即空间复用的层数目。基站根据终端上报的 RI 信息或者自行确定的层数目，选择在下行发送中所采用的预编码方案，包括采用发送分集，或者空间复用以及相应的层数目。 在开环空间复用中，采用的预编码向量是固定的。 在使用 2 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案。 当选择 RI=2 时，采用对应码本的第一个元素，即 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ 作为预编码向量。 在使用 4 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案 当选择 RI=2/3/4 时，采用对应的码本，以发送时刻为单位，固定的循环使用码本中序号为 12/13/14/15 的元素作为预编码向量。 对于大循环延迟的预编码，除了预编码向量 $W (i)$ 之外，有两个用于完成循环延迟（Cyclic Delay Diversity，CDD）功能的矩阵，即 $U$ 和 $D (i)$。 假设层数目为 v，那么这两个矩阵的大小都是 $v×v$ 的，其中 $U$ 是 DFT 矩阵，通过对输入信号进行 DFT 变换实现层到虚拟天线的映射，将每个层的信号能量均匀地分布在虚拟天线上 $D (i)$是 CDD 矩阵，实现虚拟天线间增量为 $\\frac{1}{v}$ 的时延。 发送分集对于多天线实现发送分集的情况，分别采用 SFBC（Space Frequency Block Codiing）和 SFBC+FSTD（Frequency Switched Transmit Diversity）的方案支持 2 和 4 个发送天线的场景。 在 2 个发送天线时，使用 SFBC 的发送分集方案，实现“层”到物理天线映射的预编码操作。 SFBC 发送分集 在 4 个发送天线时，使用 SFBC+FSTD 的发送分集方案。相应地，实现层到物理天线映射的预编码操作可以表示为下图所示的形式，即 SFBC 结合 FSTD 在天线间频域的位置转换。 SFBC+FSTD 发送分集 ","date":"2020-02-01","objectID":"/lte_mimo/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#单天线发送"},{"categories":["WirelessCommunication"],"content":" 预编码预编码（precoding）实现层到物理天线端口的映射。物理层使用不同的预编码方案，实现不同的 MIMO 模式：单天线发送、空间复用或者发送分集。 单天线发送对于单天线发送的情况，直观的可以得出，1 个层将直接映射到 1 个物理天线端口上。 空间复用对于多天线实现空间复用的情况，LTE 中采用基于码本（codebook）进行预编码向量选择的机制，分为开环和闭环两种复用传输模式，分别采用无循环延迟的预编码和大循环延迟的预编码。 在 2 个发送天线的情况时，基站一般使用线性阵列（Uniform LinearArray，ULA）的天线配置，因此，相对应地采用基于 DFT 正交距阵的码本设计方法。 对应于 1 个层的传输，设计了 4 个可供选择的预编码向量 对应于 2 个层的传输，设计了 3 个可供选择的预编码向量。 对于 4 个发送天线的情况，天线的部署要更为复杂，实际情况下可能不使用线性阵列的天线配置，而采用例如双极化天线 所以，基于对各种场景下的性能和复杂度等因素的综合考虑，选择了采用基于 householder 变换 的码本设计方法。对应于 1/2/3/4 个层的传输，均有 16 个可供选择的预编码向量。 预编码向量选取常用的两个准则： 信噪比最大化，对应于容量最大化。将每个可选择的项代入，得到一个等效信道矩阵，计算等效信噪比，选择对应 SNR 最大的向量元素。 最小码距，对应于最小误码率。计算信道信息给出的加权矩阵与码本中元素的距离，选择距离最小的作为预编码向量。 无循环延迟的预编码用于闭环的 MIMO 空间复用。闭环模式下，终端通过对下行信道状态的测量选择适当的空间复用的层数目，并且从码本集合中选择预编码向量，分别表示为 RI（Rank Indicator）和 PMI（Precoding Matrix Indicator）的形式通过上行链路反馈给基站。基站根据这些信息进行预测，确定随后的下行发送中将采用的空间复用方案（包括采用的层数目和预编码向量）。 大循环延迟的预编码用于开环的 MIMO 空间复用。开环模式下，终端不再向基站反馈预编码向量 PMI 的信息，但仍可以根据基站的配置测量并且反馈下行信道的 RI 信息，即空间复用的层数目。基站根据终端上报的 RI 信息或者自行确定的层数目，选择在下行发送中所采用的预编码方案，包括采用发送分集，或者空间复用以及相应的层数目。 在开环空间复用中，采用的预编码向量是固定的。 在使用 2 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案。 当选择 RI=2 时，采用对应码本的第一个元素，即 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ 作为预编码向量。 在使用 4 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案 当选择 RI=2/3/4 时，采用对应的码本，以发送时刻为单位，固定的循环使用码本中序号为 12/13/14/15 的元素作为预编码向量。 对于大循环延迟的预编码，除了预编码向量 $W (i)$ 之外，有两个用于完成循环延迟（Cyclic Delay Diversity，CDD）功能的矩阵，即 $U$ 和 $D (i)$。 假设层数目为 v，那么这两个矩阵的大小都是 $v×v$ 的，其中 $U$ 是 DFT 矩阵，通过对输入信号进行 DFT 变换实现层到虚拟天线的映射，将每个层的信号能量均匀地分布在虚拟天线上 $D (i)$是 CDD 矩阵，实现虚拟天线间增量为 $\\frac{1}{v}$ 的时延。 发送分集对于多天线实现发送分集的情况，分别采用 SFBC（Space Frequency Block Codiing）和 SFBC+FSTD（Frequency Switched Transmit Diversity）的方案支持 2 和 4 个发送天线的场景。 在 2 个发送天线时，使用 SFBC 的发送分集方案，实现“层”到物理天线映射的预编码操作。 SFBC 发送分集 在 4 个发送天线时，使用 SFBC+FSTD 的发送分集方案。相应地，实现层到物理天线映射的预编码操作可以表示为下图所示的形式，即 SFBC 结合 FSTD 在天线间频域的位置转换。 SFBC+FSTD 发送分集 ","date":"2020-02-01","objectID":"/lte_mimo/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#空间复用"},{"categories":["WirelessCommunication"],"content":" 预编码预编码（precoding）实现层到物理天线端口的映射。物理层使用不同的预编码方案，实现不同的 MIMO 模式：单天线发送、空间复用或者发送分集。 单天线发送对于单天线发送的情况，直观的可以得出，1 个层将直接映射到 1 个物理天线端口上。 空间复用对于多天线实现空间复用的情况，LTE 中采用基于码本（codebook）进行预编码向量选择的机制，分为开环和闭环两种复用传输模式，分别采用无循环延迟的预编码和大循环延迟的预编码。 在 2 个发送天线的情况时，基站一般使用线性阵列（Uniform LinearArray，ULA）的天线配置，因此，相对应地采用基于 DFT 正交距阵的码本设计方法。 对应于 1 个层的传输，设计了 4 个可供选择的预编码向量 对应于 2 个层的传输，设计了 3 个可供选择的预编码向量。 对于 4 个发送天线的情况，天线的部署要更为复杂，实际情况下可能不使用线性阵列的天线配置，而采用例如双极化天线 所以，基于对各种场景下的性能和复杂度等因素的综合考虑，选择了采用基于 householder 变换 的码本设计方法。对应于 1/2/3/4 个层的传输，均有 16 个可供选择的预编码向量。 预编码向量选取常用的两个准则： 信噪比最大化，对应于容量最大化。将每个可选择的项代入，得到一个等效信道矩阵，计算等效信噪比，选择对应 SNR 最大的向量元素。 最小码距，对应于最小误码率。计算信道信息给出的加权矩阵与码本中元素的距离，选择距离最小的作为预编码向量。 无循环延迟的预编码用于闭环的 MIMO 空间复用。闭环模式下，终端通过对下行信道状态的测量选择适当的空间复用的层数目，并且从码本集合中选择预编码向量，分别表示为 RI（Rank Indicator）和 PMI（Precoding Matrix Indicator）的形式通过上行链路反馈给基站。基站根据这些信息进行预测，确定随后的下行发送中将采用的空间复用方案（包括采用的层数目和预编码向量）。 大循环延迟的预编码用于开环的 MIMO 空间复用。开环模式下，终端不再向基站反馈预编码向量 PMI 的信息，但仍可以根据基站的配置测量并且反馈下行信道的 RI 信息，即空间复用的层数目。基站根据终端上报的 RI 信息或者自行确定的层数目，选择在下行发送中所采用的预编码方案，包括采用发送分集，或者空间复用以及相应的层数目。 在开环空间复用中，采用的预编码向量是固定的。 在使用 2 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案。 当选择 RI=2 时，采用对应码本的第一个元素，即 $W(i)=\\frac{1}{\\sqrt{2}}\\begin{bmatrix}1\u00260 \\\\ 0\u00261\\end{bmatrix}$ 作为预编码向量。 在使用 4 个发送天线的情况下 当选择层数目 RI=1 时，采用发送分集的预编码方案 当选择 RI=2/3/4 时，采用对应的码本，以发送时刻为单位，固定的循环使用码本中序号为 12/13/14/15 的元素作为预编码向量。 对于大循环延迟的预编码，除了预编码向量 $W (i)$ 之外，有两个用于完成循环延迟（Cyclic Delay Diversity，CDD）功能的矩阵，即 $U$ 和 $D (i)$。 假设层数目为 v，那么这两个矩阵的大小都是 $v×v$ 的，其中 $U$ 是 DFT 矩阵，通过对输入信号进行 DFT 变换实现层到虚拟天线的映射，将每个层的信号能量均匀地分布在虚拟天线上 $D (i)$是 CDD 矩阵，实现虚拟天线间增量为 $\\frac{1}{v}$ 的时延。 发送分集对于多天线实现发送分集的情况，分别采用 SFBC（Space Frequency Block Codiing）和 SFBC+FSTD（Frequency Switched Transmit Diversity）的方案支持 2 和 4 个发送天线的场景。 在 2 个发送天线时，使用 SFBC 的发送分集方案，实现“层”到物理天线映射的预编码操作。 SFBC 发送分集 在 4 个发送天线时，使用 SFBC+FSTD 的发送分集方案。相应地，实现层到物理天线映射的预编码操作可以表示为下图所示的形式，即 SFBC 结合 FSTD 在天线间频域的位置转换。 SFBC+FSTD 发送分集 ","date":"2020-02-01","objectID":"/lte_mimo/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#发送分集"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-02-01","objectID":"/lte_mimo/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：多天线技术（MIMO）","uri":"/lte_mimo/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 数据的编码、复用和交织 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#"},{"categories":["WirelessCommunication"],"content":" 数据的编码、复用和交织为了进行传输信道向物理信道的映射，提高数据传输的性能，并且将数据是否正确传输的情况向高层报告，物理层需要对传输信道的数据进行一系列信道编码相关的处理，通常的过程包括： 码字 CRC 计算 码块分割和码块 CRC 计算 码块信道编码 码块交织和速率匹配 码块连接的过程 传输块物理层信道编码的过程 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#数据的编码复用和交织"},{"categories":["WirelessCommunication"],"content":" CRC 计算循环冗余校验码（Cyclic Redundancy Check，CRC）是数据通信领域中最常用的一种差错校验码，接收端通过对所接收到的数据信息和相应的 CRC 信息进行校验，可以判断接收到的数据是否正确。 物理层提供了 4 种 CRC 计算方法，分别用于不同信息的处理过程，其中包括 2 种长度为 24 比特的 CRC 计算方法，1 种长度为 16 比特的 CRC 计算方法，和 1 种长度为 8 比特的 CRC 计算方法。 长度为 24 比特的 CRC 用于下行共享信道（DL-SCH）、寻呼信道（PCH）、多播信道（MCH）和上行共享信道（UL-SCH）等传输信道信息的处理过程 长度为 16 比特的 CRC 用于广播信道（BCH）和下行控制信息（DCI）的处理过程 长度为 8 比特的 CRC 用于上行控制信息（UCI）在上行物理共享信道（PUSCH）中传输时可能需要的 CRC 操作，对应的计算多项式为： $gCRC8 (D)=[D8 +D7 +D4 +D3 +D+1]$ CRC 计算（gCRC8） ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#crc-计算"},{"categories":["WirelessCommunication"],"content":" 码块分割传输信道中的 1 个传输块（transport block）对应于物理层的 1 个码字（codeword），码字是物理层进行信道编码等相关操作的单位。 当收到来自 MAC 层的 1 个传输块后，物理层将其对应为 1 个码字，首先对整个码字进行 CRC 的计算，得到添加了 CRC 比特后的码字数据流。 考虑到信道纠错编码的性能与处理时延的因素，标准中定义了最大的编码长度为 6144。也就是说，如果添加 CRC 比特后 1 个码字数据流的长度大于 6144 个比特，那么需要对码字进行分割，将 1 个码字分割为若干个码块（code block），这时候需要对每个码块再添加相应的 CRC 比特，然后以码块为单位进行后续的信道纠错编码，以满足信道纠错编码最大长度的限制。 码块分割 物理层采用的 Turbo 编码的内交织器对数据的长度有一定的要求，标准中以列表的方式给出了所支持的数值，因此，在分块过程中，可能需要进行一定的填充，保证每一个码块的长度符合内交织器的要求。 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#码块分割"},{"categories":["WirelessCommunication"],"content":" 信道编码物理层支持包括块编码、截尾的卷积编码和 Turbo 码 3 种不同的信道纠错编码方法。 Turbo 码由于其良好的性能，用于大部分传输信道数据信息的信道编码方法 卷积码的译码复杂度比较低，另外在码长比较短的时候，卷积码的性能与 Turbo 码相近，因此采用截尾的卷积码作为广播信道和物理层下行控制信息主要的信道编码方法 使用块编码作为一些长度更短的信息的信道编码方法，包括控制格式指示信息（PCFICH）、下行 HARQ 指示信息（PHICH）和物理层上行控制信息（上行 ACK 信息、CQI 信息等）。 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#信道编码"},{"categories":["WirelessCommunication"],"content":" 速率匹配在速率匹配的过程中，对信道编码后形成的比特流进行选取，以匹配于最终实际使用的物理资源。根据所选取的数据数量的不同，形成不同的编码速率。在这个过程中，以信道编码的每个码块为单位。 Turbo 码速率匹配的数据选择 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#速率匹配"},{"categories":["WirelessCommunication"],"content":" 码块连接在完成以码块为单位的信道编码和速率匹配的过程之后，将对 1 个码字内所有的码块进行串行连接，形成码字（即传输块）所对应的传输序列，然后就可以进一步地进行信号调制相关的处理与发送了。 码块连接 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:1:5","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#码块连接"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2020-01-10","objectID":"/lte_encoding_multiplexing_and_interleaving/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：编码、复用和交织","uri":"/lte_encoding_multiplexing_and_interleaving/#参考"},{"categories":null,"content":" 粗体 表示跨平台软件 斜体 表示优先选择表示商店版本(Windows \u0026 macOS) Linux 优先选用对应包管理器安装 ","date":"2019-12-30","objectID":"/softwares/:0:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#"},{"categories":null,"content":" 浏览器 Microsoft Edge FireFox Vivaldi 浏览器插件 ClearURLs MONKNOW OneNote Web Clipper Proxy SwitchyOmega Save to Pocket Tampermonkey uBlock Origin 沙拉查词-聚合词典划词翻译 隐私獾 Augmented Steam：Steam 增强 Imagus：鼠标悬停放大图片 Little Star：Github 分类管理 Notion Web Clipper OneTab Stylus Vimium C - 全键盘操作浏览器 二管家：扩展管理 Dark Reader HTTPS Everywhere 图片助手(ImageAssistant) 批量图片下载器 简悦 - SimpRead Bitwarden - 免费密码管理器 ","date":"2019-12-30","objectID":"/softwares/:1:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#浏览器"},{"categories":null,"content":" 浏览器 Microsoft Edge FireFox Vivaldi 浏览器插件 ClearURLs MONKNOW OneNote Web Clipper Proxy SwitchyOmega Save to Pocket Tampermonkey uBlock Origin 沙拉查词-聚合词典划词翻译 隐私獾 Augmented Steam：Steam 增强 Imagus：鼠标悬停放大图片 Little Star：Github 分类管理 Notion Web Clipper OneTab Stylus Vimium C - 全键盘操作浏览器 二管家：扩展管理 Dark Reader HTTPS Everywhere 图片助手(ImageAssistant) 批量图片下载器 简悦 - SimpRead Bitwarden - 免费密码管理器 ","date":"2019-12-30","objectID":"/softwares/:1:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#浏览器插件"},{"categories":null,"content":" 压缩\u0026解压缩 7-zip PeaZip Windows： Bandizip：7.0 版本已增加付费，建议使用 6.29 ","date":"2019-12-30","objectID":"/softwares/:2:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#压缩解压缩"},{"categories":null,"content":" 压缩\u0026解压缩 7-zip PeaZip Windows： Bandizip：7.0 版本已增加付费，建议使用 6.29 ","date":"2019-12-30","objectID":"/softwares/:2:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows"},{"categories":null,"content":" 下载 FDM Motrix Xtreme Download Manager NeatDownloadManager Windows： IDM Linux： Aria2 Aria2NG Curl Wget macOS Downie：视频下载 ","date":"2019-12-30","objectID":"/softwares/:3:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#下载"},{"categories":null,"content":" 下载 FDM Motrix Xtreme Download Manager NeatDownloadManager Windows： IDM Linux： Aria2 Aria2NG Curl Wget macOS Downie：视频下载 ","date":"2019-12-30","objectID":"/softwares/:3:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-1"},{"categories":null,"content":" 下载 FDM Motrix Xtreme Download Manager NeatDownloadManager Windows： IDM Linux： Aria2 Aria2NG Curl Wget macOS Downie：视频下载 ","date":"2019-12-30","objectID":"/softwares/:3:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux"},{"categories":null,"content":" 下载 FDM Motrix Xtreme Download Manager NeatDownloadManager Windows： IDM Linux： Aria2 Aria2NG Curl Wget macOS Downie：视频下载 ","date":"2019-12-30","objectID":"/softwares/:3:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#macos"},{"categories":null,"content":" 游戏平台及工具 Windows： 战网 Steam Origin Uplay GOG Galaxy 网易 UU Logitech G Hub ","date":"2019-12-30","objectID":"/softwares/:4:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#游戏平台及工具"},{"categories":null,"content":" 游戏平台及工具 Windows： 战网 Steam Origin Uplay GOG Galaxy 网易 UU Logitech G Hub ","date":"2019-12-30","objectID":"/softwares/:4:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-2"},{"categories":null,"content":" Code Visual studio code Git Python3 Windows： Matlab Linux： Pycharm-professional Goland Go ","date":"2019-12-30","objectID":"/softwares/:5:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#code"},{"categories":null,"content":" Code Visual studio code Git Python3 Windows： Matlab Linux： Pycharm-professional Goland Go ","date":"2019-12-30","objectID":"/softwares/:5:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-3"},{"categories":null,"content":" Code Visual studio code Git Python3 Windows： Matlab Linux： Pycharm-professional Goland Go ","date":"2019-12-30","objectID":"/softwares/:5:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-1"},{"categories":null,"content":" 文档工具 Typora Notion Windows： Office 365 Office tools plus：Office 套件管理工具 iSlide Tools DrawBoard PDF Adobe acrobat DC Visio OneNote ","date":"2019-12-30","objectID":"/softwares/:6:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#文档工具"},{"categories":null,"content":" 文档工具 Typora Notion Windows： Office 365 Office tools plus：Office 套件管理工具 iSlide Tools DrawBoard PDF Adobe acrobat DC Visio OneNote ","date":"2019-12-30","objectID":"/softwares/:6:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-4"},{"categories":null,"content":" 视频\u0026音乐 VLC Spotify：网页 \u0026 全平台客户端 Youtube Music：网页 \u0026 Android 客户端 Apple Music：网页 \u0026 Android 客户端 Macast: PC 充当 DLNA 接收器 Android: Podcast Republic Windows： Potplayer Mp3tag (歌曲信息管理) foobar2000 Linux： Petal：Linux 下豆瓣 FM 第三方客户端 macOS: IINA ","date":"2019-12-30","objectID":"/softwares/:7:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#视频音乐"},{"categories":null,"content":" 视频\u0026音乐 VLC Spotify：网页 \u0026 全平台客户端 Youtube Music：网页 \u0026 Android 客户端 Apple Music：网页 \u0026 Android 客户端 Macast: PC 充当 DLNA 接收器 Android: Podcast Republic Windows： Potplayer Mp3tag (歌曲信息管理) foobar2000 Linux： Petal：Linux 下豆瓣 FM 第三方客户端 macOS: IINA ","date":"2019-12-30","objectID":"/softwares/:7:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#android"},{"categories":null,"content":" 视频\u0026音乐 VLC Spotify：网页 \u0026 全平台客户端 Youtube Music：网页 \u0026 Android 客户端 Apple Music：网页 \u0026 Android 客户端 Macast: PC 充当 DLNA 接收器 Android: Podcast Republic Windows： Potplayer Mp3tag (歌曲信息管理) foobar2000 Linux： Petal：Linux 下豆瓣 FM 第三方客户端 macOS: IINA ","date":"2019-12-30","objectID":"/softwares/:7:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-5"},{"categories":null,"content":" 视频\u0026音乐 VLC Spotify：网页 \u0026 全平台客户端 Youtube Music：网页 \u0026 Android 客户端 Apple Music：网页 \u0026 Android 客户端 Macast: PC 充当 DLNA 接收器 Android: Podcast Republic Windows： Potplayer Mp3tag (歌曲信息管理) foobar2000 Linux： Petal：Linux 下豆瓣 FM 第三方客户端 macOS: IINA ","date":"2019-12-30","objectID":"/softwares/:7:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-2"},{"categories":null,"content":" 视频\u0026音乐 VLC Spotify：网页 \u0026 全平台客户端 Youtube Music：网页 \u0026 Android 客户端 Apple Music：网页 \u0026 Android 客户端 Macast: PC 充当 DLNA 接收器 Android: Podcast Republic Windows： Potplayer Mp3tag (歌曲信息管理) foobar2000 Linux： Petal：Linux 下豆瓣 FM 第三方客户端 macOS: IINA ","date":"2019-12-30","objectID":"/softwares/:7:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#macos-1"},{"categories":null,"content":" 网盘工具 Onedrive：网页 \u0026 各平台客户端 rclone Goodsync Resilio Sync Windows： RaiDrive ","date":"2019-12-30","objectID":"/softwares/:8:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#网盘工具"},{"categories":null,"content":" 网盘工具 Onedrive：网页 \u0026 各平台客户端 rclone Goodsync Resilio Sync Windows： RaiDrive ","date":"2019-12-30","objectID":"/softwares/:8:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-6"},{"categories":null,"content":" 即时通信 Telegram Unigram ：Telegram 第三方客户端，对比官方客户端增加了 PC 端的端到端加密聊天功能 微信 QQ ","date":"2019-12-30","objectID":"/softwares/:9:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#即时通信"},{"categories":null,"content":" 密码管理 Bitwarden Enpass：官方存在失信行为 ","date":"2019-12-30","objectID":"/softwares/:10:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#密码管理"},{"categories":null,"content":" 网络工具 Clash Best Trace tabby ZeroTier One Wireshark Clash for Windows Windows： Fiddler Linux: Remmina ：Linux 远程桌面 macOS： ClashX ","date":"2019-12-30","objectID":"/softwares/:11:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#网络工具"},{"categories":null,"content":" 网络工具 Clash Best Trace tabby ZeroTier One Wireshark Clash for Windows Windows： Fiddler Linux: Remmina ：Linux 远程桌面 macOS： ClashX ","date":"2019-12-30","objectID":"/softwares/:11:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-7"},{"categories":null,"content":" 网络工具 Clash Best Trace tabby ZeroTier One Wireshark Clash for Windows Windows： Fiddler Linux: Remmina ：Linux 远程桌面 macOS： ClashX ","date":"2019-12-30","objectID":"/softwares/:11:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-3"},{"categories":null,"content":" 网络工具 Clash Best Trace tabby ZeroTier One Wireshark Clash for Windows Windows： Fiddler Linux: Remmina ：Linux 远程桌面 macOS： ClashX ","date":"2019-12-30","objectID":"/softwares/:11:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#macos-2"},{"categories":null,"content":" 效率工具 Meld：跨平台开源文件/文件夹对比软件 Utools Windows： PowerToys Strokesplus.net：Windows 鼠标手势 Fastcopy-M：基于原版的二次开发 Everything Pollar Linux: Easystroke：Linux 鼠标手势 ","date":"2019-12-30","objectID":"/softwares/:12:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#效率工具"},{"categories":null,"content":" 效率工具 Meld：跨平台开源文件/文件夹对比软件 Utools Windows： PowerToys Strokesplus.net：Windows 鼠标手势 Fastcopy-M：基于原版的二次开发 Everything Pollar Linux: Easystroke：Linux 鼠标手势 ","date":"2019-12-30","objectID":"/softwares/:12:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-8"},{"categories":null,"content":" 效率工具 Meld：跨平台开源文件/文件夹对比软件 Utools Windows： PowerToys Strokesplus.net：Windows 鼠标手势 Fastcopy-M：基于原版的二次开发 Everything Pollar Linux: Easystroke：Linux 鼠标手势 ","date":"2019-12-30","objectID":"/softwares/:12:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-4"},{"categories":null,"content":" 软件\u0026磁盘管理 Windows： Dism++ Scoop：PowerShell 包管理器 Geek Uninstaller SpaceSniffer CrystalDiskMark CrystalDiskInfo DiskGenius ","date":"2019-12-30","objectID":"/softwares/:13:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#软件磁盘管理"},{"categories":null,"content":" 软件\u0026磁盘管理 Windows： Dism++ Scoop：PowerShell 包管理器 Geek Uninstaller SpaceSniffer CrystalDiskMark CrystalDiskInfo DiskGenius ","date":"2019-12-30","objectID":"/softwares/:13:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-9"},{"categories":null,"content":" 安全工具 Windows： 火绒 Sandboxie OpenHashTab：Windows 属性菜单添加 Hash 值直接查看 macOS: LuLu ","date":"2019-12-30","objectID":"/softwares/:14:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#安全工具"},{"categories":null,"content":" 安全工具 Windows： 火绒 Sandboxie OpenHashTab：Windows 属性菜单添加 Hash 值直接查看 macOS: LuLu ","date":"2019-12-30","objectID":"/softwares/:14:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-10"},{"categories":null,"content":" 安全工具 Windows： 火绒 Sandboxie OpenHashTab：Windows 属性菜单添加 Hash 值直接查看 macOS: LuLu ","date":"2019-12-30","objectID":"/softwares/:14:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#macos-3"},{"categories":null,"content":" 虚拟机 VMware Workstation Pro Windows： Hyper-V ","date":"2019-12-30","objectID":"/softwares/:15:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#虚拟机"},{"categories":null,"content":" 虚拟机 VMware Workstation Pro Windows： Hyper-V ","date":"2019-12-30","objectID":"/softwares/:15:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-11"},{"categories":null,"content":" 阅读 FreshRSS Fluent Reader Linux: Liferea Android: Fluent Reader Lite Feedme macOS: Reader NetNewsWire ","date":"2019-12-30","objectID":"/softwares/:16:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#阅读"},{"categories":null,"content":" 阅读 FreshRSS Fluent Reader Linux: Liferea Android: Fluent Reader Lite Feedme macOS: Reader NetNewsWire ","date":"2019-12-30","objectID":"/softwares/:16:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-5"},{"categories":null,"content":" 阅读 FreshRSS Fluent Reader Linux: Liferea Android: Fluent Reader Lite Feedme macOS: Reader NetNewsWire ","date":"2019-12-30","objectID":"/softwares/:16:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#android-1"},{"categories":null,"content":" 阅读 FreshRSS Fluent Reader Linux: Liferea Android: Fluent Reader Lite Feedme macOS: Reader NetNewsWire ","date":"2019-12-30","objectID":"/softwares/:16:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#macos-4"},{"categories":null,"content":" Cli Linux: Zsh Oh-my-zsh Navi Screenfetch Htop ","date":"2019-12-30","objectID":"/softwares/:17:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#cli"},{"categories":null,"content":" Cli Linux: Zsh Oh-my-zsh Navi Screenfetch Htop ","date":"2019-12-30","objectID":"/softwares/:17:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-6"},{"categories":null,"content":" 系统工具 Linux: BleachBit Redshift Deepin-wine Docker TimeShift：系统备份 macOS： Better and Better iStat Menus Stats Mounty 自动切换输入法Lite ","date":"2019-12-30","objectID":"/softwares/:18:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#系统工具"},{"categories":null,"content":" 系统工具 Linux: BleachBit Redshift Deepin-wine Docker TimeShift：系统备份 macOS： Better and Better iStat Menus Stats Mounty 自动切换输入法Lite ","date":"2019-12-30","objectID":"/softwares/:18:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-7"},{"categories":null,"content":" 系统工具 Linux: BleachBit Redshift Deepin-wine Docker TimeShift：系统备份 macOS： Better and Better iStat Menus Stats Mounty 自动切换输入法Lite ","date":"2019-12-30","objectID":"/softwares/:18:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#macos-5"},{"categories":null,"content":" 邮件 Windows： Outlook Linux: Thunderbird ","date":"2019-12-30","objectID":"/softwares/:19:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#邮件"},{"categories":null,"content":" 邮件 Windows： Outlook Linux: Thunderbird ","date":"2019-12-30","objectID":"/softwares/:19:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#windows-12"},{"categories":null,"content":" 邮件 Windows： Outlook Linux: Thunderbird ","date":"2019-12-30","objectID":"/softwares/:19:0","series":null,"tags":null,"title":"软件","uri":"/softwares/#linux-8"},{"categories":null,"content":" 🤷‍♂️我 一只通信🐕，对网络有浓厚的兴趣 目前从事 Android Wi-Fi 相关研发工作 👨‍💻 擅长 Linux(Arch \u0026 Ubuntu 24.04) \u0026 Windows 11 \u0026 MacOS 开关机 ","date":"2019-12-30","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于","uri":"/about/#man_shrugging我"},{"categories":null,"content":" 这个网站本质上，就是我自己的笔记📔，某天突发奇想💭：做成网站也不错，随时都可以查看，于是就诞生了这个网站。 更新随缘，内容随意。 如果内容对你有所帮助，那将是我莫大的荣幸。 文章使用 Markdown 撰写排版 网页利用 Hugo 渲染生成 页面由 DoIt 装点 托管在 Vercel 套用了 jsDelivr 的 CDN 致谢 在此，感谢上述开发者 \u0026 公司。 说明 网站内容包括两部分： 学习笔记 此部分内容站在“巨人”的肩膀上，学习消化并加以整理，产出一定的成果，这也便是网站副标题Input/Output的来由。 转载的文章 本站原则上会全文转载原文，保留原作者的所有内容以及观点（仅作排版优化以便阅读）并注明出处和版权，但这并不意味着本站认同原文章中的所有观点和内容。 之所以转载文章，是因为现在网页的坏链率越来越高，但有一些文章和观点值得留存，所以算是私自做一个备份吧。 此外，私以为学习不应该仅拘泥于自己的视角，不同的角度，特别是对立面的想法，往往更能丰富对于事物的全面认识，因此本站会转载持有各种观点的文章。 ","date":"2019-12-30","objectID":"/about/:0:2","series":null,"tags":null,"title":"关于","uri":"/about/#这个网站"},{"categories":null,"content":" 本站的内容授权 版权说明 本站点发布内容默认采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议（CC BY-NC-SA 4.0）进行许可，即： 本授权条款允许您（用户）可以复制、发行、展览、表演、放映、广播或通过信息网络传播本站作品； 您必须以附加本站 URL (https://www.techkoala.net/) 的方式对作品进行署名； 若您改变、转变或更改本作品，仅在遵守与本作品相同的许可条款下，您才能散布由本作品产生的派生作品； 您不得为商业目的而使用本作品； 转载作品另行声明，遵守原作者授权协议，所有权利归原作者所有； ","date":"2019-12-30","objectID":"/about/:0:3","series":null,"tags":null,"title":"关于","uri":"/about/#本站的内容授权"},{"categories":["WirelessCommunication"],"content":" LTE 物理层概要 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/#"},{"categories":["WirelessCommunication"],"content":" 下行共享信道的传输与接收物理层下行数据传输包含了链路自适应的过程，基站根据终端所上报的链路质量信息（CQI/PMI/RI）选择适当的物理资源和相应的编码调制方式进行下行数据的发送，实现对系统下行无线资源的优化利用，达到最佳的性能。 信道状态信息反馈和下行链路自适应传输 物理层下行共享信道的传输包括了 调度信息（PDCCH） 数据信息（PDSCH） 在长度为 1ms 的子帧结构中，前面的 1 ～ 3 个 OFDM 符号用于传输下行控制信息，其中包括了传输数据调度信息的 PDCCH；而子帧中剩余的符号用于传输数据信息（PDSCH）。 下行数据传输的子帧结构 在下行数据接收的过程中，终端对当前子帧中所有 PDCCH 信道进行盲检测，如果发现属于自己的调度信息，那么终端将根据该调度信息的指示（包括资源位置、编码调制方法等）解调接收当前子帧中属于自己的 PDSCH 数据信息。 下行数据的调度与传输 物理层下行支持 29 种调制编码格式，其中包括了 QPSK、16QAM 和 64QAM 3 种不同的调制方式和不同的信道编码速率（范围是 0.16 ～ 0.92）。根据这样的原则，针对每一种物理资源 PRB 的占用数目，规范中定义了 29 种传输块大小（Tranport block size）。 在进行下行数据传输时，下行调度信息中使用 5 个比特对所调度数据使用的编码调制格式（MCS）进行指示。接收端根据该信息可以确定数据所使用的调制方式； 同时，将这 5 比特 MCS 信息和调度信息中所分配的 PRB 数目相结合，可以查表确定传输块大小，即信道编码数据源大小的信息，由此实现下行数据的正确传输与接收。 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/#下行共享信道的传输与接收"},{"categories":["WirelessCommunication"],"content":" 上行共享信道的调度与传输物理层上行数据的传输包含了链路自适应的调度过程。 首先，终端在上行发送 Sounding 导频 信号，基站利用该信号对用户上行信道的质量进行测量，根据测量的结果选择适当的物理资源和相应的编码调制方式，在上行资源调度信息中进行指示，终端根据基站的指示进行上行数据的发送，实现对系统上行无线资源的优化利用。 Sounding 导频和上行链路自适应 上行共享信道的传输包括 上行调度信息（PDCCH） 数据信息（PUSCH） 根据 PDCCH 上行调度信息的指示，终端使用相应的资源进行上行数据的发送。与下行情况不同的是，在下行共享信道的传输过程中，调度信息与对应的数据信息处于同一个子帧内。而在上行的情况中，终端需要根据 PDCCH 调度信息的指示，进行上行数据的发送，因此二者之间存在一定的时延，考虑无线传播和设备处理时间的因素 FDD 中定义该时延的数值为 4ms，即对于在子帧 n 中接收到的 PDCCH 上行调度信息，终端将在子帧 n+4 进行对应的上行数据传输。 TDD 的情况中，在时延最小值等于 4ms 的前提下，还需要区分是上行或者下行子帧，因为只有在属于上行子帧的时间才能进行上行数据的发送。 上行数据的调度与传输 与下行类似，物理层上行支持 29 种调制编码格式，其中包括了 QPSK、16QAM 和 64QAM 3 种不同的调制方式和不同的信道编码速率（范围是 0.16 ～ 0.92），使用与下行相同的传输块大小的表格定义，规定了在各种 PRB 数目的情况下，所对应的 29 种传输块大小（Transport block size）。 在进行上行数据传输时，上行调度信息中使用 5 个比特指示数据的调制编码格式（MCS），终端根据该信息可以确定所使用的调制方法（QPSK/16QAM/64QAM）；同时，将这 5 比特 MCS 信息和调度信息中所分配的 PRB 数目相结合，可以查表确定传输块大小，即信道编码数据源的大小。最后，终端进行信道编码、速率匹配的信号处理过程，实现上行数据的发送。 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/#上行共享信道的调度与传输"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-11-22","objectID":"/lte_transmission_and_reception/:3:0","series":null,"tags":["LTE"],"title":"LTE 系列：共享信道传输与接收","uri":"/lte_transmission_and_reception/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 多址方式详解 ","date":"2019-10-20","objectID":"/lte_multiple_access/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/#"},{"categories":["WirelessCommunication"],"content":" 多址方式LTE 的空中接口采用以 OFDM 技术为基础的多址方式，使用 15kHz 的子载波宽度，通过不同的子载波数目（72 ～ 1200 ）实现了从 1.4 ～ 20MHz 之间多种可变的系统带宽。另外，考虑到在不同应用场景的情况下，无线信道的多径传输具有不同的时延扩展特性，所以 LTE 支持两种不同循环前缀（Cyclic Prefix，CP）长度的配置：Normal CP 和 Extend CP，它们的长度分别约为 4.7μs 和 16.7μs。 在 OFDM 技术的基础上，根据下行和上行两个方向通信的不同特点，LTE 分别选择了多载波 OFDM 和单载波 SC-FDMA（即 DFT-SOFDM）作为多址方式的具体实现方法。 ","date":"2019-10-20","objectID":"/lte_multiple_access/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/#多址方式"},{"categories":["WirelessCommunication"],"content":" 下行多址方式LTE 采用 OFDM（Orthogonal Frequency Division Multiplexing）作为下行无线信号传输的多址方式。OFDM 是一种多载波调制的传输技术，将数据流经过串并变换，形成多路子数据流（N 路），使用它们分别去调制 N 路子载波后并行传输。通过这样的处理，子数据流的速率是原来的 1/N，即符号周期是原来的 N 倍，使得该符号周期远大于信道的时延扩展，从而实现了将一个宽带频率选择性信道划分成 N 个窄带平坦衰落信道，因此 OFDM 信号具有很强的抗无线信道多径衰落和抗脉冲干扰的能力，并且由于实现方式简单，所以特别适用于高速无线数据传输。 OFDM 调制的信号处理流程 ","date":"2019-10-20","objectID":"/lte_multiple_access/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/#下行多址方式"},{"categories":["WirelessCommunication"],"content":" 上行多址方式上行方向上，LTE 采用单载波 SC-FDMA（即 DFT-SOFDM） 作为多址方式。其中，同样采用了 15kHz 的子载波带宽，不同子载波数目实现不同的系统带宽。 DFT-SOFDM 调制的信号处理流程 与 ODFM 中信号直接映射到频域的子载波上形成多载波信号不同，DFT-SOFDM 中信号由时域输入，通过 DFT 的操作转换到频域后再进行子载波的调制，因此 DFT-SOFDM 属于单载波的调制方式，其发射信号也具有单载波的特性。 在 OFDM 多载波调制中，由于多路信号在频域的并行传输，叠加后形成的时域输出信号具有较大峰均比。由于基站功率放大器的能力较强，因此在下行峰均比不会成为影响系统性能的主要问题。在上行方向上，考虑到终端的成本和功率效率，使用具有单载波特性的发送信号，这是因为较低的信号峰均比具有重要的意义。根据调制方式的不同（QPSK、16QAM），与 OFDM 相比较，单载波信号具有 1.5 ～ 2.5dB 的峰均比增益，这也是 LTE 选择单载波 SC-FDMA 作为上行多址方式的主要原因。 另一方面，为了使信号真正具有单载波的特性，DFT-SOFDM 调制过程中对于子载波的映射需要满足一定的限制。除了集中式的映射之外（此时，DFT-SOFDM 的信号处理过程相当于对输入信号进行时域的过采样），在分布式的映射中，为了保持单载波特性，DFT-SOFDM 调制必须采用等间隔的子载波映射，即 L1 =L2 =…=LN （此时，DFT-SOFDM 的处理过程相当于对输入信号进行时域的块重复），而不能够使用间隔不相等的分布式映射，因为那将破坏输出信号的单载波特性。 OFDM/DFT-SOFDM 的子载波映射 ","date":"2019-10-20","objectID":"/lte_multiple_access/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/#上行多址方式"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-10-20","objectID":"/lte_multiple_access/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：多址方式","uri":"/lte_multiple_access/#参考"},{"categories":["Linux"],"content":" Linux 中使用 df 和 du 查看磁盘以及文件存储信息的 ","date":"2019-10-10","objectID":"/command_df_du/:0:0","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#"},{"categories":["Linux"],"content":" dfdf 命令用于显示磁盘分区上的可使用的磁盘空间。主要用于查看一级文件夹大小、使用比例、档案系统及其挂入点，但无法查看单个文件大小。 默认显示单位为 KB。 ","date":"2019-10-10","objectID":"/command_df_du/:1:0","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#df"},{"categories":["Linux"],"content":" 语法 df [选项] [参数] ","date":"2019-10-10","objectID":"/command_df_du/:1:1","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#语法"},{"categories":["Linux"],"content":" 选项 -a或--all 包含全部的文件系统； --block-size=\u003c区块大小\u003e 以指定的区块大小来显示区块数目； -h或--human-readable 以可读性较高的方式来显示信息； -H或--si 与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes； -i或--inodes 显示inode的信息； -k或--kilobytes 指定区块大小为1024字节； -l或--local 仅显示本地端的文件系统； -m或--megabytes 指定区块大小为1048576字节； --no-sync 在取得磁盘使用信息前，不要执行sync指令，此为预设值； -P或--portability 使用POSIX的输出格式； --sync 在取得磁盘使用信息前，先执行sync指令； -t\u003c文件系统类型\u003e或--type=\u003c文件系统类型\u003e 仅显示指定文件系统类型的磁盘信息； -T或--print-type 显示文件系统的类型； -x\u003c文件系统类型\u003e或--exclude-type=\u003c文件系统类型\u003e 不要显示指定文件系统类型的磁盘信息； --help 显示帮助； --version 显示版本信息。 ","date":"2019-10-10","objectID":"/command_df_du/:1:2","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#选项"},{"categories":["Linux"],"content":" dudu 命令是查看文件和目录磁盘使用的空间。 ","date":"2019-10-10","objectID":"/command_df_du/:2:0","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#du"},{"categories":["Linux"],"content":" 语法 du [选项] [文件] ","date":"2019-10-10","objectID":"/command_df_du/:2:1","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#语法-1"},{"categories":["Linux"],"content":" 选项 -a或-all 显示目录中个别文件的大小。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k或--kilobytes 以KB(1024bytes)为单位输出。 -m或--megabytes 以MB为单位输出。 -s或--summarize 仅显示总计，只列出最后加总的值。 -h或--human-readable 以K，M，G为单位，提高信息的可读性。 -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -L\u003c符号链接\u003e或--dereference\u003c符号链接\u003e 显示选项中所指定符号链接的源文件大小。 -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。 -X\u003c文件\u003e或--exclude-from=\u003c文件\u003e 在\u003c文件\u003e指定目录或文件。 --exclude=\u003c目录或文件\u003e 略过指定的目录或文件。 -D或--dereference-args 显示指定符号链接的源文件大小。 -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或--count-links 重复计算硬件链接的文件。 ","date":"2019-10-10","objectID":"/command_df_du/:2:2","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#选项-1"},{"categories":["Linux"],"content":" 实例按文件大小排序： $ du -sh * | sort -h 显示目录或者文件所占空间： $ du 显示指定文件所占空间： $ du xxxxx 查看指定目录的所占空间： $ du scf 显示多个文件所占空间： $ du xxxx.tar.gz yyyy.tar.gz 4 xxxx.tar.gz 4 yyyy.tar.gz 只显示总和的大小: $ du -s 1288 . $ du -s scf 32 scf 显示总和的大小且易读: du -sh \\$dir ","date":"2019-10-10","objectID":"/command_df_du/:2:3","series":null,"tags":["Commands"],"title":"使用 df 和 du 查看存储信息","uri":"/command_df_du/#实例"},{"categories":["WirelessCommunication"],"content":" LTE 物理层概要综列 ","date":"2019-09-15","objectID":"/lte_cell_synchronize/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：小区搜索和下行同步","uri":"/lte_cell_synchronize/#"},{"categories":["WirelessCommunication"],"content":" 终端的小区搜索和下行同步通过小区搜索的过程，终端实现对服务小区下行信号时间和频率的同步，并且确定小区的物理层 ID。 小区搜索过程 物理层小区搜索的过程主要涉及两个同步信号： 主同步信号（PSS） 辅同步信号（SSS） 过程中包括了 下行时间和频率的同步 小区物理 ID 的检测 OFDM 信号 CP 长度的检测（Normal 或者 Extended CP） 完成这些操作后，终端就可以开始读取服务小区的广播信道（PBCH）中的系统信息了。 通过同步信号的检测与服务小区获得同步以后，终端还可以利用下行导频信号（CRS），进行更精确的时间与频率的同步，以及同步的维持。 ","date":"2019-09-15","objectID":"/lte_cell_synchronize/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：小区搜索和下行同步","uri":"/lte_cell_synchronize/#终端的小区搜索和下行同步"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-09-15","objectID":"/lte_cell_synchronize/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：小区搜索和下行同步","uri":"/lte_cell_synchronize/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 基本物理资源及分配方法 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/#"},{"categories":["WirelessCommunication"],"content":" 基本物理资源","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/#基本物理资源"},{"categories":["WirelessCommunication"],"content":" 物理资源块（PRB）物理层定义了物理资源块（Physical Resource Block，PRB）作为空中接口物理资源分配的单位。1 个 PRB 在频域上包含 12 个连续的子载波，在时域上包含 7 个连续的 OFDM 符号（在 Extended CP 的情况下为 6 个），即 1 个 PRB 包括了频域宽度等于 180kHz、时间长度等于 0.5ms（1 个时隙）的物理资源。 物理资源块（PRB）的结构 通过设置不同的子载波数目可以映射到不同的资源块（PRB）数目。LTE Release 8 版本定义的 6 种不同的系统带宽与子载波数目以及 PRB 数目之间的对应关系如下表所示： 系统带宽与资源块数目 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/#物理资源块prb"},{"categories":["WirelessCommunication"],"content":" 逻辑资源块（VRB）为了方便物理信道向空中接口物理资源的映射，在物理资源块（PRB）的基础上还定义了逻辑资源块（Virtual Resource Block，VRB）。 逻辑资源块的大小与物理资源块相同，即 1 个时隙（0.5ms）、12 个子载波。逻辑资源块主要定义了资源的分配方式，位于 1 个子帧内 2 个时隙的 2 个 VRB（即 VRB pair）是物理资源分配信令的指示单位。 逻辑资源块和物理资源块分别对应有各自的资源块序号 nVRB 和 nPRB 。 物理资源块 PRB 的序号 nPRB 按照频域的物理位置进行顺序编号 逻辑资源块 VRB 的序号 nVRB 是系统进行资源分配时所指示的逻辑序号，通过它与 PRB 序号之间的映射关系来进一步地确定实际物理资源的位置 物理层定义了两种类型的逻辑资源块： 集中式 VRB（Localized VRB，LVRB） LVRB 直接映射到 PRB 上，即 nPRB =nVRB 分布式 VRB（Distributed VRB，DVRB） DVRB 逻辑资源序号与物理资源序号具有一定的映射关系，可以表示为 nPRB =f(nVRB ，ns )，其中 0≤ns ≤19 是 1 个无线帧内的时隙序号。通常情况下，连续的 DVBR 序号将映射到不连续的 PRB 序号上，并且 1 个子帧内的 2 个时隙也有着不同的映射关系，即属于 1 个 DVRB pair 的两个具有相同逻辑序号的 DVRB 将映射到两个时隙不同频率位置的 PRB 上。通过这样的机制实现了分布式的资源分配 基于 VRB 的资源分配 下行方向的信号传输，支持 LVRB 和 DVRB 的分配，具体采用的方式在下行资源的调度信令中进行指示 上行方向的信号传输，仅支持 LVRB 方式的资源分配 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/#逻辑资源块vrb"},{"categories":["WirelessCommunication"],"content":" 资源单元组（REG）PRB 和 VRB 用于数据信道的资源分配和映射，物理层还定义了 REG（Resource Element Group）的概念，用于物理层下行控制信道的资源映射。 1 个 REG 对应除掉导频符号之外在频域上连续的 4 个物理资源。 资源单元组（Resource Element Group，REG） ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/#资源单元组reg"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-09-01","objectID":"/lte_basic_physical_resource/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：基本物理资源","uri":"/lte_basic_physical_resource/#参考"},{"categories":["WirelessCommunication"],"content":" 无线网络中的时延是如何一步步进化到 5G 中的 \u003c1ms ？ 注：本文系全文转载，原文信息如下： 作者：见微 链接：https://www.zhihu.com/question/307958274/answer/712266324 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2019-08-12","objectID":"/5g_time_delay/:0:0","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#"},{"categories":["WirelessCommunication"],"content":" 网络延迟时间的定义","date":"2019-08-12","objectID":"/5g_time_delay/:1:0","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#网络延迟时间的定义"},{"categories":["WirelessCommunication"],"content":" 单向延迟单向延迟指的是信息从发送方传到接收方的所花费的时间。 单向时间延迟 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:1","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#单向延迟"},{"categories":["WirelessCommunication"],"content":" 双向延迟双向延迟（Round Trip Time, RTT）, 指的是信息从发送方到达接收方，加上接受方发信息给发送方所花费的总时间。双向延迟在工程中更加常见，因为我们可以只在信息发送方或者接收方的其中一方就可以测量到双向延迟（利用 ping 等工具）。 双向时间延迟 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:2","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#双向延迟"},{"categories":["WirelessCommunication"],"content":" 用户面时延题主提到的 5G 网络 1 毫秒时间延迟最初是由 ITU IMT-2020 M.2410-0 （4.7.1）关于 IMT-2020 系统的设计最小需求中提到的。其适用的范围是 URLLC（Ultra reliable and low latency communication）超可靠且超低的时延业务，这里的时延是针对用户面时延。用户面时延是指我们平时使用手机发送数据的时间延迟，区别于控制面时延：手机注册网络或者状态转换经过的信令流程所花费的时间（控制面时延不做讨论）。 另外一点是 1 毫秒指的是无线网络 空中接口（手机和基站之间，不包括核心网，互联网等网络节点）的延迟时间。 用户面时间延迟 明确了讨论的范围（无线网络空中接口的双向用户面时间延迟），接下来真正进入正题：网络空中接口的时间延迟是如何一步步降下来的。 ","date":"2019-08-12","objectID":"/5g_time_delay/:1:3","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#用户面时延"},{"categories":["WirelessCommunication"],"content":" 4G 网络延迟4G 网络（注：本文中提到的 4G 特指 LTE 网络）是从 2004 年开始标准化，2009 年开始商用网络部署，到现在已经历经了 10 余年的时间，是最成功的无线网络之一，已经在全球范围内广泛部署。 最初的 4G 网络主要关注的业务和应用是 MBB（Mobile broad band）移动带宽业务，通俗的讲就是提供更大的网络容量，更快的上网速度。从最初的 3GPP release8 到 release13 一直是沿着这条路走，标准定义的峰值速率从 300Mbps 到 25Gbps（载波聚合，MIMO，高阶调制方式）。当我们在速率更快这条路走得越来越远，才发现无线网络的时延水平也需要改善，时延还会从侧面影响下载的速率，谨慎的评估了 LTE 的无线网络的现状，空中接口的时间延迟是未来标准化组织重点关注的研究对象。 而在当时，LTE 网络的延迟状况是接近于～ 20ms 的双向时延。（理论延迟时间，实际根据无线环境情况一般会更长） LTE 网络空中接口上下行时延基线 上图描述了 LTE 空中接口的上行（从终端到基站）和下行（从基站到终端）时延。 ","date":"2019-08-12","objectID":"/5g_time_delay/:2:0","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#4g-网络延迟"},{"categories":["WirelessCommunication"],"content":" 上行时间延迟上行时间延迟（从手机到基站）：当手机有一个数据包需要发送到网络侧，需要向网络侧发起无线资源请求的申请（Scheduling request, SR），告诉基站我有数据要发啦，基站接收到请求后，需要 3 毫秒时间解码用户发送的调度请求，然后准备给用户调度的资源，准备好了之后，给用户发送信息 (Grant)，告诉用户在某个时间某个频率上去发送他想要发送的数据，用户收到了调度信息之后，需要 3 毫秒时间解码调度的信息，并将数据发送给基站，基站收到用户发送的信息之后需要 3 毫秒的时间解码数据信息，完成数据的传送工作，整个时间计算下来是 12.5ms。 ","date":"2019-08-12","objectID":"/5g_time_delay/:2:1","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#上行时间延迟"},{"categories":["WirelessCommunication"],"content":" 下行时间延迟下行时间延迟（从基站到手机）：当基站有一个数据包需要发送到终端，需要 3 毫秒时间解码用户发送的调度请求，然后准备给用户调度的资源，准备好了之后，给用户发送信息，告诉用户在某个时间某个频率上去接受他的数据，用户收到了调度信息之后，需要 3 毫秒时间解码调度的信息并接收解码数据信息，完成数据的传送工作，整个时间计算下来是 7.5ms。 所以总共的双向时延是 12.5ms+7.5ms = 20ms 详细的时间延迟组成请参考 3GPP 36.881 Study on latency reduction techniques for LTE（5.2.1） LTE 上行时间延迟组成（Source:3GPP 36.881 Study on latency reduction techniques for LTE） LTE 下行时间延迟组成（Source:3GPP 36.881 Study on latency reduction techniques for LTE） 从 20 毫秒开始，到 1 毫秒要走过怎样的路？ 当 LTE 标准化组织 3GPP 意识到网络的时间延迟是一个问题，而且具有很大的潜在提升的时候，相关的工作拉开了序幕。 时间来到了 2015 年，3 月初，中国上海，乍暖还寒，在 3GPP RAN 67 次会议上，终于迎来了关于减少 LTE 网络时间延迟的研究项目（SI）立项（RP-150465 New SI proposal: Study on Latency reduction techniques for LTE）。本次研究项目的立项旨在减小 LTE 网络的时间延迟，因为在此以前 LTE 网络一直向着速率更快的方向在发展，但是网络的延迟水平一直没有得到改善，而研究发现用户面网络延迟的改善能够提升网络的速率瓶颈（因为 TCP 的慢启动效应，改善 TCP 握手的时延，从而提升网络的速率），而且能够更好地支持更多对于时延要求特别高的应用，比如：VR，实时游戏，VoIP，视频会议等等。 改善 LTE 无线时延水平以支持更多的应用 （Source: Ericsson, Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication, IEEE cscn2017） 有了提升的意愿，通过什么方式提升？要解决一个问题，需要 全面的了解问题本身。 ","date":"2019-08-12","objectID":"/5g_time_delay/:2:2","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#下行时间延迟"},{"categories":["WirelessCommunication"],"content":" 网络延迟的组成LTE 网络空中接口的用户面网络延迟主要由以下及部分组成：资源调度请求和指派（Grant acquisition），传输时间间隔（Transmission time interval），终端和基站的数据包以及信令处理时间（Processing），混合重传来回时间（HARQ RTT）。 经过研究，终端和基站的数据包的处理时间根据数据包的大小时间不同，这块时延很难大幅度改善，主要的提升方向放在了前两部分：资源调度请求和指派（Grant acquisition），传输时间间隔（Transmission time interval），同时这两部分也是未来 5G 网络延迟改善的方向。 ","date":"2019-08-12","objectID":"/5g_time_delay/:3:0","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#网络延迟的组成"},{"categories":["WirelessCommunication"],"content":" 资源调度请求和指派终端在需要传送上行数据的时候需要先给基站发送资源调度请求，然后基站才会分配相关的资源给终端，终端收到相应的指派信令后再在相关的资源上去发送上行的数据，整个过程下来，从手机有发送数据的意愿到真正开始向基站传数据，花了 8.5ms，相对于整个上行的单向时延 12.5ms 来说，是相当大的一部分时间延迟。所以研究的重点转向了怎样使用户不用通过上行资源的请求流程，直接就能想发送数据就发送数据？ ","date":"2019-08-12","objectID":"/5g_time_delay/:3:1","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#资源调度请求和指派"},{"categories":["WirelessCommunication"],"content":" 传输时间间隔传输时间间隔，是网络处理数据，请求的最小时间单位，在 LTE 中传输时间间隔等于 1 毫秒，也就是一个无线子帧。如何缩小传输的时间间隔也是改善时延的研究重点。 ","date":"2019-08-12","objectID":"/5g_time_delay/:3:2","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#传输时间间隔"},{"categories":["WirelessCommunication"],"content":" 如何改善 LTE 网络的时延？对于资源调度请求和指派这个方向，在 LTE release 14 以前，设备厂家普遍采用预调度（Pre-scheduling）的方式来改善延迟，这种办法的主要思想在于：基站周期性的给终端用户分配好相应的无线资源，终端在有数据要发送的时候直接就能在预先分配好的无线资源上发送，无需再向网络侧请求资源，所以减少了整个资源请求流程的时间。但是这种办法有一些缺点： 不管终端用户是否使用预先调度的无线资源，始终会分配给用户。造成了宝贵无线资源的浪费。 终端用户在接收到无线资源调度后，如果没有数据发送，始终会使用已经分配的无线资源上传填充数据（padding data），这样会造成网络的干扰水平抬升，影响了网络的整体性能。而且手机的耗电量也增加了。 LTE 预调度（Pre-scheduling） 似乎探索有了方向… 光阴如梭，整整一年后，2016 年 3 月初，瑞典哥德堡，3GPP RAN 71 次会议，关于真正网络延迟减少工作立项了（RP-160667 L2 latency reduction techniques for LTE），此次工作项目的立项标志着网络延迟减少工作的正式开启。所要着手解决的主要集中在改善上行的网络延迟，而解决问题的思想是和预调度类似的 半静态调度，提前为终端周期性的分配好相关的无线资源，用户在需要传送上行数据的时候直接使用已经预先分配好的资源，无需再进行资源请求流程。而在这个版本中引入了更短的半静态调度周期，低至一毫秒，从而能进一步改善时间延迟。 同时针对预调度中分配了无线资源终端就得发送数据的问题（造成网络干扰和电量消耗），通过 Release 14 标准的改善，使用户即使分配了无线资源，也可以不发送填充数据。 至此，上行的网络传输延迟大大减少。根据仿真的结果，LTE 空中接口双向传输时延降至～ 8ms 更短的半静态调度周期 上行不用发送 Padding 数据 手机的能耗也下降了～ 10% 时延减少的同时对手机耗电量的改善 (Source: 3GPP R2-153490 L2 enhancements to reduce latency) 同时网络时延的改善也从侧面提升了终端的速率～ 30%-40% 时延减少的同时对终端速率提升 (Source: 3GPP R2-153490 L2 enhancements to reduce latency, Ericsson) 但是，真的这样就足够了吗？No，通信人止于至善。 以上只是解决问题的其中一个角度，针对另一个角度 改善传输间隔时间 能做点什么？ 3 个月后，又又又开会了，韩国釜山，RAN 72 次会议，立项了关于从改善 LTE 网络传输间隔时间从而减少网络时延的工作（RP-161299 New Work Item on shortened TTI and processing time for LTE），改善的方法得从 LTE 的无线帧结构说起。 无线网络的传输介质是时间和频率资源，终端在分配的时间和频率上发送相应的数据，在通信的世界里，时间的单位很短很短，一个 LTE 帧是 10 毫秒，可以分为 10 个子帧，每个子帧 1 毫秒，这就是网络最小可以调度的时间单位：1 毫秒。 1 个子帧还可以分为两个时隙，每个时隙还可以分为 7 个符号，至此，终于分完。 Short transmission time interval (sTTI) 减少传输时延 以前 LTE 网络每次的传输时间间隔是固定一个子帧 = 1 毫秒，上图红色部分是控制信道，用于传输无线资源指派等信令，绿色部分是下行数据信道，用于传输数据。本次工作要做的是将传输时间间隔从子帧级别（1ms) 降低至符号级别（1/14 ms），最小的调度间隔根据情况可以选择 3/2 个符号（3/14ms, 2/14ms），7 个符号（7/14ms），具体的子时隙 (subslot) 细分方式如下图。从而又进一步降低了整个 LTE 无线网络空口的时延。 4G LTE sTTI 上下行可选配置方式（Source: URLLC Services in 5GLow Latency Enhancements for LTE, Thomas Fehrenbach, Rohit Datta） 在 LTE release 15 中，还降低了 处理（procession）时间 (收到上行资源 grant 到上行传输数据的时间，以及从收到下行指派到反馈 HARQ ACK/NACK 指示的时间)，以前需要 4ms，降至了 3ms。 R15 处理时间的减少从 n+4 到 n+3 ms（Source: 3GPP TR 21.915 Summary of Rel-15 Work Items） 2018 年，到 LTE release 15 时，所有的大招都用上，LTE 的网络延迟理论上可以降至双向 2.7 毫秒（下行 0.7 毫秒 + 上行 2.0 毫秒） LTE 用户面时延（Source: URLLC Services in 5GLow Latency Enhancements for LTE, Thomas Fehrenbach, Rohit Datta） 至此，LTE 的无线网络延迟改善到头了。 那么梦寐以求的一毫秒时间延迟怎么实现？剩下的使命需要 5G 来完成。 ","date":"2019-08-12","objectID":"/5g_time_delay/:3:3","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#如何改善-lte-网络的时延"},{"categories":["WirelessCommunication"],"content":" 5G 网络延迟和人一样，一项技术也有自己的命运，LTE 从应运而生到如今的如日中天已经走过了 10 多个春秋，正如之前在另一个问题中讨论的从专业角度讲，为什么需要开展 5G 而不是继续提升 4G？ 因为 4G LTE 从出生伊始已经注定了其时间延迟的下限，而这个下限如今也已经被我们触摸到了。下一步需要我们转向一项延迟下限更低的技术去找寻极限。 5G 是站在巨人（4G）的肩膀上诞生的，从系统设计之初就将网络时间延迟的特性考虑了进来，成为 5G 需求的一部分: URLLC（Ultra reliable and low latency communication）超低的时延和超高可靠的通信以支持对时延和可靠性要求极高的行业应用，比如智能工厂，远程手术，自动驾驶等等。这部分的需求在 5G 的第一个版本 Release 15 中满足了一部分。 关于超低的时延：1ms 的无线空中接口双向传输时延是怎么一步步实现的呢？ 5G URLLC 满足极低时延极高可靠业务（Source: Ericsson, Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication, IEEE cscn2017） 2016 年，3GPP 开始了 5G 的需求分析和研究项目，为了满足 ITU 所设置的 URLLC 极高的可靠性和极低的时延要求，在 5G 的需求研究项目 TR38.913 Study on scenarios and requirements for next generation access technologies 中的用户面 KPI 中针对 URLLC 业务用户面时延定义了上行 0.5ms 和下行 0.5ms 的要求，加起来正好是 1ms 的双向时延。 需求的定义明确了，接下来进入了研究如何实现技术需求的阶段，2016 年 3 月，3GPP TSG RAN 71 次会议通过了 TR38.912 Study on New Radio (NR) access technology ，这项研究工作致力于提出可行的无线技术来满足 ITU-2020 制定的 5G 需求。而从研究项目伊始，URLLC 就做为一项不可缺少的 5G 需求被考虑进来。 从 2016 年的研究项目开始到 2018 年中第一版本 5G 标准（release 15 NSA\u0026SA）的出炉，低时延的设计贯穿了整个 5G 无线系统，我们就从用户面的每个层（物理层 PHY，媒体接入控制层 MAC，无线链路控制层 RLC）看看为了实现 1ms 的目标都做了怎样的努力。 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:0","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#5g-网络延迟"},{"categories":["WirelessCommunication"],"content":" 物理层5G 中物理层的主要作用是：编解码，调制 / 解调，多天线映射等。 虽然本回答主要讨论的是低时延的系统架构设计，但是低时延是与 URLLC 的另一部分需求：极高的可靠性（99.999%）被共同捆绑在一起的。如果单单考虑低时延会比低时延高可靠简单很多，因为要满足极高的可靠性惯常采用更多的控制信令开销，重传，冗余，这些手段往往会提升时间延迟的水平。所以如何在保证可靠性的同时改善时延水平在物理层的设计中是难上加难。5G 物理层用了哪些手段来改善时延呢？ 5G 用户面协议层 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:1","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#物理层"},{"categories":["WirelessCommunication"],"content":" 包结构（Packet structure）在 4G LTE 的时延分析中提到过的系统处理时间在时延中所占的分量比较大，而且改善较为不易。这部分时延包括了接收包，获取控制信息，调度信息，解调数据，以及错误检测。在 4G LTE 中是采用下图左侧这种方形的包结构，传输的信息分为三部分，导频信息（Pilot），控制信息（control information），以及数据（data）。这种设计方式被广泛的用来对抗信道衰落。但是在 5G 中 URLLC 包采用的是下图右侧这种设计方式，导频信息，控制信息，以及数据依次在时域上排列，这样做的好处是信道估计，控制信道解码，数据的获取可以串行的进行，通过这样的方式这样减少了处理时间。 4G LTE 和 5G URLLC 包结构对比 （Source: Ultra Reliable and Low LatencyCommunications in 5G Downlink: PhysicalLayer Aspects） 从手机收到资源分配（Grant）指令到数据的传输时间要求如下，中间部分是 5G 不同子载波间隔（Subcarrier Spacing）配置下的不同要求： 从手机收到资源分配（Grant）指令到数据的传输时间要求（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:2","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#包结构packet-structure"},{"categories":["WirelessCommunication"],"content":" 信道编码4G LTE 采用 Turbo 和 Simple code 来编解码数据达到无线传输的可靠性。在 5G 中使用的是 LDPC 和 Polar 码来提升数据和控制信道的编解码效率，经过编码界研究的不懈努力，编解码的性能和计算复杂度的提升对于降低时延也有所帮助。 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:3","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#信道编码"},{"categories":["WirelessCommunication"],"content":" 更短的传输时间间隔（可变的 Numerology）从更短的时间间隔这点说 5G 是天生丽质一点都不为过，LTE 规定的一个子载波 (传送信息的最小频域单位) 是 15KHz，时间域是 1ms （正常情况下）。5G 所需要支持的频率范围非常广，中低频从 450MHz6000MHz（FR1），高频从 24.25GHz52.6GHz（FR2）。高频意味着更高的相位噪声，所以需要设计更加宽的子载波间隔来抵御相位噪声的干扰。更宽的子载波间隔，意味着时域上更短的时隙，更短的传输时间间隔，我们在 4G LTE 时代千方百计想要降低的传输时间间隔在 5G 时代只需要使用更高的频段，更宽的子载波间隔就轻而易举的降低了。而且根据不同的频段可以选择从 15KHz, 30KHz 到 120KHz 的子载波间隔，可以简单的理解为，5G 子载波间隔相比于 LTE 15KHz 增加了多少倍，那么在时域上的传输时间间隔就减少相应的倍数。 频域子载波间隔成倍增加，时域符号时长相应倍数减少（Source: Ultra Reliable and Low LatencyCommunications in 5G Downlink: PhysicalLayer Aspects） 不同子载波间隔（sub-carrier spacing）对应的无线帧结构 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:4","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#更短的传输时间间隔可变的-numerology"},{"categories":["WirelessCommunication"],"content":" 微时隙调度（Mini-slot）微时隙调度继承了 LTE 中减小传输时间间隔 (subslot) 的设计理念，将最小的传输时间间隔由子帧拓展到了符号上。第一优先级最小的调度间隔根据情况可以选择 2 个符号，4 个符号，7 个符号。下图是一个下行数据传输的示例，数据包到达了基站，基站经过 4 个符号的处理以及等待合适的 sPDCCH 时间，随后通过两个符号的微时隙调度将数据传输给用户。 下行微时隙调度 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:5","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#微时隙调度mini-slot"},{"categories":["WirelessCommunication"],"content":" MAC（媒体接入控制）层MAC 的作用是多路逻辑信道的复用，HARQ（混合重传），以及调度相关的功能。关于时延的改善的技术在 MAC 层有：异步 HARQ（异步混合重传） 当无线环境出现问题等原因造成传输的数据出错，在 MAC 层会由 HARQ 功能来发起重新传输流程，在 LTE 中，HARQ 的时间间隔（从收到数据到发送反馈给发送方是否正确接收信息指令）是固定的（FDD，TDD 根据子帧结构变化）。 而在 5G 中，HARQ 的时间间隔是动态指派的，更加的灵活，也符合低时延的设计要求。 5G 与 4G HARQ 流程时间对比： 5G 与 4G LTE HARQ 时延对比（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:6","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#mac媒体接入控制层"},{"categories":["WirelessCommunication"],"content":" 上行免调度传输 （Grant free transmission）和 4G LTE 一样，5G 可以周期性的给用户分配上行资源（半静态调度）来减少上行的传输时延，而且 5G 更加进了一步。在 4G 中半静态调度的资源一般是给每个用户单独分配的，所以当网络中用户较多的时候，造成的浪费是非常大的，因为预留的无线资源终端不一定会使用。 在 5G 中可以将预留资源分配给一组终端用户，并且设计了当多个用户同时在相同的无线资源上发生冲撞的解决机制。这样在降低时延的同时使宝贵的无线资源的利用率也得到了保证。 5G 上行免调度传输 type1 和 type2 （Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:7","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#上行免调度传输-grant-free-transmission"},{"categories":["WirelessCommunication"],"content":" 预清空调度（Downlink preemption Scheduling）预清空调度的意思是为某个高优先级的用户清空原来已经分配给其他用户的资源，打个比方，我们去餐馆吃饭，没有位置了，餐馆老板认识我们是高级 VIP，所以把一桌正在吃饭的人赶走了，把桌子留给了咱们。 通过这样的方式达到了对时间延迟要求高的用户可以立即传输数据，从而降低了时延。下图是一个示例： 用户 A 已经在一个时隙上被调度了数据，但是这时用户 B 被标记为对时延要求高的数据需要传输。 如果这时有空闲的时频域资源可用，用户 B 会被优先调度空闲的资源 但是如果此时网络负荷较大，没有空闲的资源可用，用户 B 就会抢占其他用户的（例如用户 A）的资源。 这种方式有个弊端就是会影响原本被分配资源的 A 的用户的数据传输（在被用户 B 抢占的资源上），当然优秀的 5G 系统也设计了方案来解决这个问题，方式有：HARQ 重传用户 A 受影响的传输数据，或者是直接通过控制信令（DCI2-1）通知用户 A，哪些传输的数据受到了影响。 下行预清空调度示例（Source: NR: the next generation wireless access technology by ErikDahlman, JohanSkold, StefanParkvall, Ericsson） ","date":"2019-08-12","objectID":"/5g_time_delay/:4:8","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#预清空调度downlink-preemption-scheduling"},{"categories":["WirelessCommunication"],"content":" RLC（无线链路控制）层RLC 层主要负责 RLC 数据的切分，重复数据去除，RLC 重传的工作。 在 RLC 层中关于低时延的技术考量主要体现在：在 4G LTE 中 RLC 层还需要负责保证数据的按顺序传递（In-sequence delivery），即前面的包没有向上层传递之前，排在后面的包需要等待。在 5G 中去掉了这样的功能要求来保障低时延水平。这样做的好处是，如果之前有某些包因为某些原因（例如无线环境突然变差）丢失了需要重传，在 5G 中后面的包不需要等到前面的包重传完毕就可以直接向上层传递。 那么通过以上关键技术的组合，是怎么一步步使 5G 无线网络时间延迟降低到 1 毫秒的呢？ 无线网络空中接口双向时延演进 通过使用 30KHz 的子载波间隔，上行免调度，以及两个符号的微时隙的 5G 系统配置方案，可以达到低于双向时延 1ms 以下的要求。如果采用 5G 高频通信，使用 120KHz 的子载波间隔，时延可以更低。 至此，1ms 梦寐以求的目标终于达成，但是科技工作者们仍没有停下探索的脚步，目前的研究转向了 5G 物理层的增强对 URLLC 业务的支持，而新的研究项目也已经成功立项并完成：Study on physical layer enhancements for NR ultra-reliable and low latency case (URLLC), 在下一版本 5G release 16 中，URLLC 将从 PDCCH，UCI，PUSCH（上下行控制信道以及上行数据信道）获得更多的提升。同时还研究支持对时延和可靠性要求极高的工业互联网应用 Study on NR industrial Internet of Things (IoT)。探索为什么 5G 能降低网络时间延迟到 1ms 完结，但是需要引起注意的是，我们这里讨论的延迟是整个网络中的一部分，特指空中接口。但是网络的传输时延绝不是空中接口单一接口就能够保证的，还涉及到端到端的核心网以及互联网。剩下这部分属于 TSN（Time Sensitive Networking）的范围，什么是 TSN，怎么将无线 URLLC 和 TSN 结合起来为工业 4.0 服务，下次有机会再聊。 无线网络的低时延高可靠特性结合 TSN 为工业互联网服务（Source：Boosting smart manufacturing with 5G wireless connectivity, Ericsson） 历史的有趣之处就在于：总是在起起伏伏，跌跌撞撞中前行，不断的循环，却又惊人的相似。对比 5G 中时延减少的思路，很多都和 4G 类似。而从 4G 一路看过来，才不会乱花渐欲迷人眼。20 毫秒到 1 毫秒，这么短，却又那么长，背后是无数通信工作者夜以继日，年复一年，默默无闻的贡献自己的力量。 ","date":"2019-08-12","objectID":"/5g_time_delay/:4:9","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#rlc无线链路控制层"},{"categories":["WirelessCommunication"],"content":" 参考 [1] ITU-R M.2410-0 Minimum requirements related to technical performance for IMT-2020 radio interface (s) [2] 3GPP 38.913 Study on scenarios and requirements for next generation access technologies [3] 3GPP 36.881 Study on latency reduction techniques for LTE [4] RP-150465 New SI proposal: Study on Latency reduction techniques for LTE [5] RP-160667 L2 latency reduction techniques for LTE [6] RP-161299 New Work Item on shortened TTI and processing time for LTE [7] R2-153490 L2 enhancements to reduce latency [8] Thomas Fehrenbach, Rohit Datta, URLLC Services in 5G Low Latency Enhancements for LTE [9] 38.913 Study on scenarios and requirements for next generation access technologies [10] TR38.912 Study on New Radio (NR) access technology [11] Joachim Sachs: 5G Ultra-Reliable and Low Latency Communication IEEE cscn2017 [12] Ultra Reliable Low Latency Communication for 5G New Radio [13] Ultra Reliable and Low Latency Communications in 5G Downlink: Physical Layer Aspects [14] ErikDahlman, JohanSkold, StefanParkvall, Ericsson，NR: the next generation wireless access technology [15] 3GPP TS38.824 Study on physical layer enhancements for NR ultra-reliable and low latency case (URLLC) [16] 3GPP TR38.825 Study on NR industrial Internet of Things (IoT) [17] Boosting smart manufacturing with 5G wireless connectivity [18] 3GPP TR 21.915 Summary of Rel-15 Work Items ","date":"2019-08-12","objectID":"/5g_time_delay/:5:0","series":null,"tags":["5G"],"title":"5G NR 系列：如何做到空口 \u003c1ms 的延迟","uri":"/5g_time_delay/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 上行链路帧结构详细讲解 LTE 使用 SC (单载波)-FDMA 作为上行链路信号。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:0:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#"},{"categories":["WirelessCommunication"],"content":" 时隙结构从下面的时隙结构可以看出，LTE 上下行链路的时隙结构是相似的： 上行时隙结构 与下行链路相同，上行链路中的帧时间和时隙时间与下行链路中相同。并且资源块结构和下行链路上也相同。如上所述，在一个时隙中的 7 个符号在上行链路和下行链路上也是相同的。 你可能会注意到的一点区别是每个物理信道的位置。在下行链路情况下，信道通常占用整个带宽，但是上行链路时隙中的信道更局限。例如，PUCCH 仅位于整个带宽中的的最低端和最高端。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#时隙结构"},{"categories":["WirelessCommunication"],"content":" PUCCH RS携带解调 PUCCH 所需的参考信号。这意味着如果此部分配置不正确或 eNodeB 检测不到此部件，则 eNodeB 无法解码 PUCCH。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:1","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#pucch-rs"},{"categories":["WirelessCommunication"],"content":" PUCCH此信道可以承载大量信息(UCI)，但根据配置的不同，它只能承载以下信息中的一部分： ACK/NACK for the recieved PDSCH data CQI RI PMI 正如你在时隙结构中看到的，PUCCH 以子帧内两个时隙之间交替的方式位于上行链路频域的两端，这意味着如果 PUCCH 是时隙 0 (第一个时隙) 中的频域的最低部分，并且它将位于时隙 1 (第二个时隙) 中的频域的最高部分。分配给 PUCCH 的资源元素的确切数量由网络确定，并且配置通过 SIB2 广播到 UE。 详细的 PUCHH 结构参考： PUCCH Format PUCCH Format 1,1a,1b Location PUCCH Format 2,2a,2b Location ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:2","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#pucch"},{"categories":["WirelessCommunication"],"content":" PUSCH RS携带解调 PUSCH 所需的参考信号。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:3","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#pusch-rs"},{"categories":["WirelessCommunication"],"content":" PUSCH承载 UE 尝试发送的上行链路数据。并且除了上行链路数据之外，还可以携带 UE 接收的 PDSCH 的 ACK/NACK。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:4","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#pusch"},{"categories":["WirelessCommunication"],"content":" SRS参考 SRS in Quick Reference ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:1:5","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#srs"},{"categories":["WirelessCommunication"],"content":" 上行资源网格具体来说，上行资源还有一种网格格式，如下所示: 上行资源网格 最小的单元是 “资源元素 (RE)”，最小的资源分配单元是 RB (资源块)，它沿时域跨越 7 RE，沿频域跨越 12 RE。 这意味着一个 RB 有 84 个单元 (7x12)。 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:2:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#上行资源网格"},{"categories":["WirelessCommunication"],"content":" 通信中的信道下图显示了上行/下行数据传输的总体顺序。你可以将数据传输序列图与 DL/UL 帧结构中每个通道的特定位置相关联。 LTE 上下行传输顺序图 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:3:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#通信中的信道"},{"categories":["WirelessCommunication"],"content":" 帧结构总览 上行帧结构概览 ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:4:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#帧结构总览"},{"categories":["WirelessCommunication"],"content":" 参考 [1] UL FrameStructure ","date":"2019-08-10","objectID":"/lte_uplink_frame_structure/:5:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：上行链路帧结构","uri":"/lte_uplink_frame_structure/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 物理信道详解 ","date":"2019-08-05","objectID":"/lte_physical_channels/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#"},{"categories":["WirelessCommunication"],"content":" 广播信道（PBCH）物理广播信道（Physical Broadcast CHannel，PBCH）用于承载系统的 MIB 广播信息。 LTE 系统广播信息分为 MIB（Master Information Block） 系统基本的配置信息，在 PBCH 固定的物理资源上进行传输 MIB 数据块的总长度为 40 比特，包含 24 个信息比特和 16 个 CRC 比特（以加扰的方式携带关于基站发射天线数目（1/2/4）的信息）。信息比特中包括： 下行系统带宽指示（3 比特） PHICH 资源指示（3 比特） 系统帧号 SFN（8 比特） 预留的 10 个比特 MIB 信息的传输周期 TTI=40ms，在位于每个 10ms 无线帧的第一个子帧的 PBCH 信道上传输。MIB 数据块经过信道编码、速率匹配和加扰后，得到 1920 比特，映射到 40ms 内，间隔为 10ms 的 4 个子帧的 PBCH 信道的物理资源上。其中，每一个 PBCH 子帧都是可自解码的，也就是说假设信道质量足够好的话，终端可以通过 4 次中的任意一次的接收即可解调出 MIB 信息。 LTE 物理广播信道 SIB（System Information Block） PBCH 信道位于每个 10ms 无线帧的第一个子帧，占用 4 个连续的 OFDM 符号，在频域上占用下行频带中心 1.08MHz 的带宽。也就是说，对于各种不同的系统带宽（1.4MHz、3MHz、5MHz、10MHz、15MHz、20MHz），物理广播信道 PBCH 的传输带宽相同，总是占用频带中心的 1.08MHz 带宽（72 个子载波）。物理广播信道 PBCH 频域结构。 物理广播信道 PBCH 频域结构 当发射天线为 2/4 的时候，PBCH 采用发送分集（SFBC/SFBC+FSTD）的方式。在资源映射的时候，为了方便终端在不知道发射天线数目情况下的盲检测，对 1、2 或者 4 的发射天线数目，使用相同的物理资源映射方式，即总是空出 4 天线的小区公用导频 CRS 资源。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#广播信道pbch"},{"categories":["WirelessCommunication"],"content":" 下行共享信道（PDSCH）下行物理共享信道（Physical Downlink Shared CHannel，PDSCH）用于下行数据的调度传输，是 LTE 物理层主要的下行数据承载信道，可以承载来自上层的不同的传输内容（即不同的逻辑信道），包括： 寻呼信息 广播信息 控制信息和业务数据信息 作为决定物理层性能的关键因素之一，PDSCH 的传输支持各种物理层机制，包括信道自适应的调度，HARQ 和各种 MIMO 机制。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#下行共享信道pdsch"},{"categories":["WirelessCommunication"],"content":" 控制格式指示信道（PCFICH）物理控制格式指示信道（Physical Control Format Indicator CHannel，PCFICH）指示物理层控制信道的格式。 在 LTE 中，物理层控制信道（PDCCH）在每个子帧的前几个 OFDM 符号上传输，根据系统物理层控制信息负载情况的不同，该数值可能是 1、2 或者 3（在使用最小值 1.4MHz 的系统带宽的时候，为了提供足够的物理层控制信息的容量，也可以设置为 4）。PCFICH 信道正是对该数值进行了指示，即在当前子帧中，前几个 OFDM 符号用于物理层控制信道 PDCCH 的传输。 PCFICH 指示当前子帧中 PDCCH 的符号数目：1、2、3（当系统带宽 1.4MHz 的时候，取值为 2、3、4）。 PCFICH 的基带处理过程如图所示，其携带的 3 种可能性通过编码映射得到 32 比特的信息，经过 QPSK 调制后形成 16 个调制符号，这 16 个调制符号将映射到子帧第 1 个 OFDM 符号上的 4 个资源单元组 REG 上（每个 REG 包含 4 个 RE，可以承载 4 个调制符号）。为了获得充分的分集增益，这 4 个 REG 均匀地分布在系统下行带宽上。可以注意到，其中频域的起始位置 k 与小区 ID 相关，因此不同小区的 PCFICH 将形成相对的频域偏移，避免不同小区的 PCFICH 之间的干扰。 物理控制信道格式指示信道（PCFICH） PCFICH 信道采用的发射天线与 PBCH 相同，即 1、2 或者 4。当发射天线数目为 2 或者 4 的时候，使用 SFBC/SFBC+FSTD 的发送分集方式。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:2:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#控制格式指示信道pcfich"},{"categories":["WirelessCommunication"],"content":" HARQ 指示信道（PHICH）物理 HARQ 指示信道（Physical HARQ Indicator CHannel，PHICH）承载对上行数据传输的 HARQ ACK/NACK 反馈信息。 物理层 PHICH 信道的传输以 PHICH 组的形式来组织，1 个 PHICH 信道由 PHICH 组编号和组内编号共同确定。 1 个 PHICH 组内的多个 PHICH 信道占用相同的时频域物理资源，采用正交扩频序列的复用方式。 在 Normal CP 的情况下，采用扩频因子为 4 结合 I/Q 两路 BPSK 调制的复用方式，1 个 PHICH 组占用 12 个调制符号（3 个 REG），可以复用 8 个 PHICH 信道 在 Extended CP 时，针对频率选择性较强的无线信道，采用扩频因子为 2 结合 I/Q 两路 BPSK 调制的复用方式，1 个 PHICH 组占用 6 个调制符号，可以复用 4 个 PHICH 信道，此时，2 个 PHICH 组共同占用 3 个 REG 的物理资源 PHICH 信道的基带处理过程如图所示，1 个比特的 ACK/NACK（0/1）信息使用重复编码的方式得到 3 个比特的编码后信息，然后经过 BPSK 调制以及系数为 4 的扩频操作，得到 12 个符号，映射在 PHICH 组所对应的 3 个 REG 的物理资源位置上。 物理 HARQ 指示信道（PHICH） 在频域上，1 个 PHICH 组对应的 3 个 REG 采用分布式的映射方式，以获得分集增益 在时间上，PHICH 有正常（normal）和扩展（extended）两种资源映射方式 在采用正常方式的时候，PHICH 信道映射在子帧的第一个 OFDM 符号上； 当 PDCCH 的长度为 3 时（在混合载波的 MBSFN 子帧或者 TDD 特殊子帧中，PDCCH 长度为 2 时），PHICH 可以配置为采用扩展的方式，此时每 1 个 PHICH 信道将分布在 PDCCH 所占用的多个 OFDM 符号上。 在 PCFICH 所指示的前 n 个 OFDM 符号中，除了用于 PCFICH 和 PHICH 传输的资源外，其余的将用于 PDCCH 的传输。 为了确定用于 PDCCH 的资源，需要先确定用于 PCFICH 和 PHICH 的资源，其中 PCFICH 的资源是固定的，而用于 PHICH 传输的资源数目则由系统在 PBCH 广播信息进行半静态的指示。MIB 信息中有 3 个比特用于 PHICH 资源的指示，其中包括了正常或者扩展两种时间长度以及 PHICH 组数目 4 种可能性的指示。 PHICH 信道发射天线的数目与 PBCH 相同，当发射天线数目为 2、4 的时候采用 SFBC/SFBC+FSTD 的发送分集方式。 PHICH 信道的索引号与上行数据传输的资源位置相对应，也就是说，不需要采用信令进行指示，根据上行 PUSCH 数据传输的资源位置就可以确定下行 PHICH 信号的索引号。 具体来说，由相应的上行 PUSCH 数据传输使用的第 1 个物理资源块 PRB 的序号所确定。另外，为了使得各个 PHICH 组中实际使用的 PHICH 信道数量的负载均衡，相邻的上行 PRB 位置对应于不同 PHICH 组中的 PHICH 信道。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:2:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#harq-指示信道phich"},{"categories":["WirelessCommunication"],"content":" 下行控制信道（PDCCH）下行物理控制信道（Physical Downlink Control CHannel，PDCCH）用于承载物理层的下行控制消息，包括： 上／下行数据传输的调度信息 上行功率控制命令信息 PDCCH 信道的传输以控制信道单元（Control Channel Element，CCE）的形式来组织，1 个 CCE 由 9 个 REG 组成（即 9×4=36 个 RE）。根据所占用的 CCE 数目的不同，标准中定义了 4 种 PDCCH 格式，分别占用 1、2、4、8 个 CCE，相应的数值又称为 PDCCH 的聚合等级（Aggregation Level）。 一个下行子帧可以承载多个 PDCCH 信道，各个 PDCCH 信道进行独立的 CRC 计算、加扰、信道编码并根据 Aggregation Level 进行速率匹配。然后，一个子帧中所有的 PDCCH 信道将复用为 1 个数据比特流，对该数据流进行填充，使各个 PDCCH 信道符合定义的 CCE 起始位置的规则（Aggregation Level 为 n 的 PDCCH 的起始位置为 n 整数倍的 CCE 位置）；并且使填充后的数据比特流长度能够充满分配给 PDCCH 的 OFDM 符号的所有资源（除去 PCFICH 和 PHICH）。然后，对形成的数据流进行加扰、调制和多天线映射。最后映射到分配给 PDCCH 的物理资源上。 在 PDCCH 数据流向物理资源的映射过程中，包含了交织的操作，数据流以 REG（4 个调制符号）为单位进行交织。通过交织的资源映射，每个 PDCCH 信道能够获得充分的分集增益。 下行物理控制信道（PDCCH） PDCCH 信道的发射天线与 PBCH 相同，即 1、2 或者 4。当发射天线数目为 2、4 的时候采用 SFBC/SFBC+FSTD 的发送分集方式。 终端对 PDCCH 信道的接收采用盲检测的方式，即终端根据所使用的下行控制信息（DCI）的格式，解调所有可能属于自己的下行 PDCCH 信道，搜索属于自己的信息。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:3:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#下行控制信道pdcch"},{"categories":["WirelessCommunication"],"content":" 随机接入信道（PRACH）物理随机接入信道（Physical RandomAccess CHannel，PRACH）用于终端上行发送随机接入信号（random access preamble），启动随机接入的过程。 随机接入信号由 循环前缀（Cyclic Prefix，CP） 接入序列（Sequence） **保护时间（Guard Time，GT） ** 3 个部分组成。 物理随机接入信道 根据适用的场景的不同（例如：小区半径和链路的功率预算），LTE 物理层支持 5 种随机接入信号格式，具体使用过程中，由高层信令指示小区所使用的随机接入信道的配置。 随机接入信号格式 其中格式 4 的随机接入信号仅用于 TDD Type 2 中，当 TDD 配置特殊时隙 UpPTS 的长度为 2 个 OFDM 符号时，可以在 UpPTS 的位置发送格式 4 的随机接入信号，以较小的开销实现随机接入的功能。 在频域上，PRACH 占用 6 个 PRB（1.08MHz）的带宽。以 Format 0 为例，PRACH 信号的生成方式如图所示，信号占用的带宽为 1 048.75kHz，不足 1.08MHz 的部分作为频域的保护带。 PRACH preamble 生成方法（Format 0） LTE 物理层使用 Zadoff-Chu 序列作为生成随机接入信号的序列。每个小区有 64 个可用的序列，由小区的下行广播进行指示。 小区中分配给上行随机接入信道的物理资源位置由高层信令进行指示。在关于小区随机接入信道配置的信息中，指示了使用的 PRACH 格式以及物理资源的位置。 对于 FDD Type 1，每个时刻最多传输一个 PRACH 信道，即没有频分复用。结合配置信息中指示的PRACH 信道的时间位置和PRACH 信道频率位置的信息，可以确定小区中 PRACH 信道的时频资源位置。 例如：设置使用 PRACH Format 0，周期等于 10ms，时间偏移量等于 1 个子帧，频率位置等于 1，那么小区中用于 PRACH 信道的物理资源位置 随机接入信道的物理资源位置 对于 TDD Type 2，除了在 UpPTS 上支持 PRACH Format 4 的发送之外，同一个时刻还可能传输多个频分的 PRACH 信道。 TDD Type 2 中频分的 PRACH 信道 因为 TDD 支持不同的上下行时间比例的配置，在某些配置情况下上行时间较少，所以可能需要在同一个时刻支持多个 PRACH 信道，以提供足够的随机接入信道的容量。在普通子帧中，由于上行两边频带存在 PUCCH 控制信道，而中间是 PUSCH 数据信道，因此 PRACH 信道采用频率偏移结合上下交错的分配方式为 PUCCH 和 PUSCH 信道留出物理资源空间。而对于 PRACH Format 4，由于特殊时隙 UpPTS 上不存在 PUCCH 或者 PUSCH 信道，因此采用了不同的机制：从上行频域的边际开始，连续分布，在两次 UpPTS 之间采用跳频的方式，即交替地从上边带或者下边带开始，这样可以在随机接入信号需要多次传输的时候获得频率分集的增益。 TDD Type 2 中 PRACH Format 4 的频分与跳频 ","date":"2019-08-05","objectID":"/lte_physical_channels/:4:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#随机接入信道prach"},{"categories":["WirelessCommunication"],"content":" 上行控制信道（PUCCH）上行物理控制信道（Physical Uplink Control CHannel，PUCCH）传输物理层上行控制信息，包括上行调度请求、对下行数据的 ACK/NACK 信息和信道状态信息 CSI 反馈（包括 CQI/PMI/RI）。 每 1 组 PUCCH 信道占用 1 个 RB-pair 的物理资源，采用时隙跳频的方式，在系统上行频带的两边进行传输，而上行频带的中间部分用于传输上行共享信道（PUSCH）的数据。 PUCCH 信道的资源分布 根据所承载的上行控制信息，物理层设计了不同的 PUCCH 格式，对应于不同的发送方法。 PUCCH 信道不同的格式 根据不同格式的 PUCCH 信道的特点，它们在频域的分布情况如图所示。 不同格式 PUCCH 信道在频域的分布情况 PUCCH 2/2a/2b 承载的是信道状态 CSI 的反馈信息，在系统配置中，这一部分资源的数量是相对固定的，因此将它们分布在频带的最外侧，资源的具体数量通过高层信令进行半静态的指示。 PUCCH 1/1a/1b 承载的是调度请求信息和对下行数据的 ACK 信息，资源数量是动态变化的，与小区中发送的下行数据的数量相关，因此将这一部分资源放置在稍靠近频率中心的位置，方便将系统剩余的频率资源用于上行共享信道 PUSCH 的传输。 在所占用的 1 个 RB-pair 的时频域资源中，PUCCH 1/1a/1b 和 PUCCH 2/2a/2b 都采用了码分的方式进一步地复用多个 PUCCH 信道。因此当配置的 PUCCH 2/2a/2b 信道数量所占用的资源数目不是 RB-pair 整数倍的时候，在 PUCCH 2/2a/2b 和 PUCCH 1/1a/1b 频域的交界处将出现它们在某 1 个 RB-pair 内以码分的方式混合传输的情况。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:5:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#上行控制信道pucch"},{"categories":["WirelessCommunication"],"content":" PUCCH 格式 1/1a/1bPUCCH 格式 1/1a/1b 用于终端发送调度请求信息或者1、2 比特的 ACK/NACK 信息。 使用一个调制符号 $d(0)$ 来表示 PUCCH 1/1a/1b 发送的信息。对于 PUCCH 1 的调度请求信息，基站侧仅需要检测是否存在这样的发送，此时的 $d(0)$ 设置为预定义的固定值（d(0)=1）。对于 PUCCH 1a/1b 的 ACK 信息，$d(0)$ 为 BPSK 或者 QPSK 调制符号，分别对应于 1 比特或者 2 比特的 ACK 信息。 在信息的发送过程中，首先使用正交扩频序列 $w(m)$ 进行扩频，将信息分散在一个时隙内用于 PUCCH 传输的多个上行符号上；然后，在每个上行符号上使用 1 个长度为 12 的 Zadoff-Chu 序列 $r_{u,v}^{\\alpha}$ 进行调制，得到长度为 12 的复数序列对应于 1 个 RB 内的 12 个子载波。因此，PUCCH 1/1a/1b 的发送包含了正交扩频序列和Zadoff-Chu 序列两次码扩频的过程，可以复用的信道数目为二者的乘积。 例如：在使用 Normal CP 的情况下有 3 个正交扩频序列，而所使用的 Zadoff-Chu 序列的长度为 12，假设设置 Zadoff-Chu 序列循环移位（Cyclic Shift）的复用间隔为 2，那么 1 个 RB-pair 上可以复用 3×6=18 个 PUCCH 1/1a/1b 信道。 PUCCH 1/1a/1b 物理层信号发送方法（Normal CP） 为了增强信号的随机性，在 PUCCH 1/1a/1b 的发送过程中包含了跳频的概念。包括两种跳频： 子帧内的 2 个时隙使用不同的正交扩频序列 $w(m)$，即正交序列跳频 时隙内的不同上行符号之间使用 Zadoff-Chu 序列不同的循环移位，即Cyclic Shift 跳频 ","date":"2019-08-05","objectID":"/lte_physical_channels/:5:1","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#pucch-格式-11a1b"},{"categories":["WirelessCommunication"],"content":" PUCCH Format 2/2a/2bPUCCH 格式 2 用于终端发送信道状态信息（Channel State Information，CSI），包括： 信道质量指示（Channel Quality Indicator，CQI） 预编码向量指示（Precoding Matrix Indicator，PMI） 复用秩的指示（Rank Indicator，RI） 在 Normal CP 的情况下，PUCCH 格式 2 还可以扩展成 PUCCH 格式 2a/2b，在这两种格式中，通过对 PUCCH 格式 2 中的导频符号进行调制，在 CSI 信息的基础上，进一步承载 1 或者 2 比特的 ACK/NACK 信息。 CSI 信息经过信道编码和加扰后形成长度为 20 比特的数据流，经过 QPSK 调制后形成 10 个调制符号（d(0)，…，d(9)），在 PUCCH Format 2/2a/2b 上发送。 PUCCH Format 2/2a/2b 信息的发送过程与 PUCCH Format 1/1a/1b 类似，只是没有了扩频的操作，因为要发送更多的比特信息。 对于要发送的调制符号信息 d(0)，…，d(9)，在每个符号上使用长度为 12 的 Zadoff-Chu 序列 $r_{u,v}^{\\alpha}$ 进行调制，然后将各个符号调制的结果映射在子帧内相应上行符号 1 个 RB 内的 12 个子载波上。通过长度为 12 的 Zadoff-Chu 序列的不同循环移位来进行同一个 RB 内不同 PUCCH 2/2a/2b 信道的复用。 假设设置 Zadoff-Chu 序列循环移位的复用间隔为 2，那么 1 个 RB-pair 上可以复用 6 个 PUCCH 2/2a/2b 信道。 PUCCH 2/2a/2b 物理层信号发送方法（Normal CP） 在 PUCCH 2a/2b 中，除了 20 个比特的 CSI 信息之外，还承载 1 或者 2 比特的 ACK 信息。该 ACK 信息将通过 BPSK 或者 QPSK 的调制，形成一个调制符号 d(10)，然后调制在导频符号上进行传输。 PUCCH 2a/2b 仅适用于 Normal CP 的情况，对于 Extended CP 的情况，由于 PUCCH 格式 2 的每个时隙内只有 1 列上行导频，难以将 ACK/NAK 信息调制在导频中。所以，在这种情况下，如果 ACK/NAK 和 CQI 需要同时传输，那么将对它们进行联合编码，形成 20 比特的编码后数据，采用 Extended CP 的 PUCCH 格式 2 进行发送。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:5:2","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#pucch-format-22a2b"},{"categories":["WirelessCommunication"],"content":" 上行共享信道（PUSCH）上行物理共享信道（Physical Uplink Shared CHannel，PUSCH）用于上行数据的调度传输，是物理层主要的上行数据承载信道，可以承载来自上层的不同的传输内容（即不同的逻辑信道），包括： 控制信息 用户业务信息 与下行物理共享信道 PDSCH 相似，PUSCH 信道是决定系统上行数据传输性能的关键，因此，PUSCH 的传输支持各种物理层机制，包括信道自适应的调度、HARQ 等。 值得一提的是，上行物理层采用单载波（DFT-SOFDM）作为多址方式，这样的多址方式对终端上行功率效率方面带来好处的同时也带来了一些限制。 例如：为了保持上行单载波的特性，LTE Release 8 物理层不支持单用户的上行共享信道（PUSCH）和上行控制信道（PUCCH）的频分复用，即 1 个用户不能在一个时刻同时发送 PUSCH 信道和 PUCCH 信道。当用户有上行数据 PUSCH 正在发送的时候，如果需要同时发送物理层上行控制信息（CSI、ACK 或者 RI），那么这些信息不能在 PUCCH 信道上传输，而是将这些控制信息与数据信息一起复用在 PUSCH 信道上进行传输。 另外，单载波（DFT-SOFDM）多址方式的处理过程中包含了 DFT 的操作，为了降低 DFT 运算的复杂度，便于使用类似 FFT 的快速算法，标准中对上行 PUSCH 信道子载波分配的数目进行了规定，即上行分配的 RB 数目的数值必须能够被 2、3、5 这 3 个质数所分解，即必须满足条件$=2_{α2}、3_{α3}、5_{α5}$，其中 $α2 、α3 和 α5$ 是非负整数。 ","date":"2019-08-05","objectID":"/lte_physical_channels/:6:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#上行共享信道pusch"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-08-05","objectID":"/lte_physical_channels/:7:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理信道","uri":"/lte_physical_channels/#参考"},{"categories":["WirelessCommunication"],"content":" 概述 LTE 信息帧中的各类物理通道和信号 在 此前的一篇文章 中，我们详细了解 LTE 下行链路的帧结构，其中包含了各种物理信道和信号，本文将会做一个概要性的讲述，用作一个速查表。 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:0:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#"},{"categories":["WirelessCommunication"],"content":" PBCHPhysical Broadcast Channel，物理广播通道 它只携带 MIB (master information block，主系统信息块) 它使用的是 QPSK 映射到 6 个资源块（72 个子载波），以 0 号子帧中的 DC 子载波为中心 映射到不为传输参考信号、PDCCH 或 PCHICH 而保留的资源元素 详情参考 Physical Layer : PBCH 和 Matlab Toolbox : PBCH 页面（待填坑） ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:1:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#pbch"},{"categories":["WirelessCommunication"],"content":" PCFICHPhysical Control Format Indicator Channel，物理控制格式指示通道 它映射到每个下行链路子帧中的第一个 OFDM 符号 它包含了携带控制信道（PDCCH 和 PHICH）的 OFDM 符号数量的信息。UE 对该信道进行解码，以找出该帧中为控制信道（PDCCH 和 PHICH）分配了多少个 OFDM 符号 它是子帧的第一个 OFDM 符号的 16 个数据子载波 PCFICH 数据由 4 个 REG 承载，并且这 4 个 REG 均匀分布在整个频带上，与带宽无关 PCFICH 的确切位置由小区 ID 和带宽确定 详细信息参阅 Physical Layer : PCFICH 和 Matlab Toolbox : PCFICH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:2:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#pcfich"},{"categories":["WirelessCommunication"],"content":" PDCCHPhysical Downlink Control Channel，物理下行控制信道 映射到下行链路每个子帧中前 L 个 OFDM 符号 PDCCH 的符号数（L）可以是 1,2 或 3 PDCCH 的符号数由 PCFICH 指定 PDCCH 承载 DCI，而 DCI 承载传输格式，资源分配，与 DL-SCH，UL-SCH 和 PCH 相关的 H-ARQ 信息以及其他取决于 DCI 格式的信息 PDCCH 还携带用于 UL 调度分配的 DCI 0（例如，UL 授权） 可以在单个子帧中分配多个 PDCCH，并且 UE 对所有 PDCCH 进行盲解码 调制方案是 QPSK PDCCH 类似于 HSDPA 的 HS-SCCH、R99 的 PDCCH 和 HSUPA 的 E-AGCH/E-RGCH 即使 PDCCH 具有很多功能，但并非所有功能都同时使用，因此 PDCCH 配置应灵活设置 如果您对该通道中的详细信息映射感兴趣，请参阅 36.211 中的 6.8.1。简要说明如下： 物理下行链路控制信道承载调度分配和其他控制信息。物理控制信道是在一个或几个连续的控制信道元素（CCE）的聚合上发送的，其中控制信道元素对应于 9 个资源元素组。未分配给 PCFICH 或 PHICH 的资源元素组的数量为 REG N。系统中可用的 CCE 从 0 和 N_CCE-1 编号，其中 N_CCE = floor（N_REG/9）。 详细信息参阅物理层 Physical Layer : PDCCH 和 Matlab Toolbox : PDCCH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:3:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#pdcch"},{"categories":["WirelessCommunication"],"content":" PHICHPhysical Hybrid ARQ Indicator Channel，物理 HARQ 指示信道 对收到的 PUSCH 进行 H-ARQ 反馈 UE 在 UL 中传输数据后，等待 PHICH 进行 ACK 类似于 HSPA 中的 E-HICH 某些情况下，几个 PHICH 使用相同的资源元素构成 PHICH 组 详细信息参见 Physical Layer : PHICH 和 Matlab Toolbox : PHICH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:4:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#phich"},{"categories":["WirelessCommunication"],"content":" PDSCHPhysical Downlink Shared Channel，物理下行共享信道 携带用户特定的数据（DL 有效负载） 携带随机访问响应消息 它使用带有 QPSK，16 QAM，64 QAM，256 QAM 调制方案的 AMC（此调制方案由 DCI 承载的 MCS 确定） 详细信息参见 Physical Layer : PDSCH 和 Matlab Toolbox : PDSCH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:5:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#pdsch"},{"categories":["WirelessCommunication"],"content":" PRACHPhysical Random Access Channel，物理随机接入信道 携带随机访问前导码 它在频域中占用 72 个子载波（6 RB）的带宽 在该信道内是随机访问前导，该随机访问前同步码用 Zadoff-Chu 序列 生成 详细信息参见 RACH 和 Matlab Toolbox : PRACH 页面 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:6:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#prach"},{"categories":["WirelessCommunication"],"content":" P-SSPrimary Synchronization Signal，主同步信号 映射到 72 个活动子载波（6 个资源块），以时隙 0（子帧 0）和时隙 10（子帧 5）中的 DC 子载波为中心。 由 62 个 Zadoff-Chu 序列值 组成 用于下行帧同步 决定 物理小区 ID 的关键因素之一 详细信息参见 Physical Layer : PSS 和 Matlab Toolbox : PSS 页面 如何从基带捕获的 IQ 数据序列中找到 PSS 的确切位置？是定时同步中最重要的部分之一；也是理解 LTE 协议中非常棘手的部分之一，需要花费很长时间进行研究。 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:7:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#p-ss"},{"categories":["WirelessCommunication"],"content":" S-SSSecondary Synchronization Signal，副同步信号 SSS 是用于无线电帧同步的特定物理层信号，它具有以下列出的特征： 映射到 72 个活动子载波（6 个资源块），以 FDD 中的时隙 0（子帧 0）和时隙 10（子帧 5）的 DC 子载波为中心 子帧 0 中的 SSS 序列与子帧 5 中的 SSS 序列互不相同 由 62 个加扰序列（基于 m 序列）组成 奇偶索引的资源元素的值由不同方程生成 用于下行帧同步 决定 物理小区 ID 的关键因素之一 详细信息参见 Physical Layer : SSS 和 Matlab Toolbox : SSS ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:8:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#s-ss"},{"categories":["WirelessCommunication"],"content":" RSReference Signal，参考信号 大多数信道（例如，PDSCH，PDCCH，PBCH 等）都用于承载特殊信息（比特序列），它们与更高层的信道相连，但是参考信号是仅存在于 PHY 层的特殊信号，不用于传递任何特定信息。参考信号的目的是为下行链路功率提供参考点。 当 UE 尝试计算 DL 功率（即，来自 eNode-B 的信号的功率）时，它将测量参考信号的功率并将其作为下行链路小区功率。 这些参考信号由每个时隙中的多个特定资源元素承载，并且资源元素的具体位置由天线配置确定。 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#rs"},{"categories":["WirelessCommunication"],"content":" RS - Cell Specific在下图中，红色/蓝色/绿色/黄色是承载参考信号的部分，灰色标记的资源元素是为参考信号保留的部分，但未承载该特定天线的参考信号。（插图基于 36.211 的图 6.10.1.2-1： 下行链路参考信号的映射（正常循环前缀）） 小区特定参考信号 以下是 4 天线情况下物理信道配置和 RE（资源元素）映射的示例。测量结果来自 LTE 信号分析仪，它测量从 LTE 网络模拟器传出的 LTE 信号。它仅显示 20 Mhz 系统带宽中的一个 RB（RB0）（总共 100 个 RB），并且分别在 LTE 网络发送 MIB/SIB 和 UE 未连接时在天线端口 0、1、2、3 处捕获。你会注意到，每个天线的参考信号位置都不同。 由于此参考信号位置的差异，REG 分组可能由 PCFICH 的不同位置中略有不同。 各天线小区特定参考信号 有两种不同类型的参考信号：小区特定参考信号和 UE 特定参考信号 小区特定参考信号（CRS）：该参考信号在每个子帧处被发送，并且跨越整个工作带宽，通过天线端口 0、1、2、3 发送。 UE 特定参考信号：此参考信号在仅分配给特定 UE 的资源块中传输，并通过天线端口 5 传输。 特定于小区的参考信号的资源元素是否固定？ 否，位置会根据物理小区 ID 进行更改，如下所述： 参考信号的时域索引（l）= 固定（l = [0,4]） 参考信号的频域索引 k 根据 36.211 6.10.1.2 映射到资源元素中指定的物理小区 ID 而变化。 主要规则是：$k = 6m + (v + v_{shift})mod 6$，其中 v_shift=物理小区 ID mod6。详细信息参阅 36.211 6.10.1.2 下行参考信号携带什么样的值？ 该值是 36.211 6.10.1.1 序列生成中定义算法生成的伪随机序列。该序列的确定值之一是物理小区 ID，这意味着物理小区 ID 也影响参考信号的值。 CRS 是否以任何子帧类型（类型 1、2、3）传输？ 对于帧结构类型 1，在所有下行链路子帧中发送 CRS。 对于帧结构类型 2，在所有下行链路子帧和 DwPTS 中发送 CRS 对于帧结构类型 3，CRS 在非空子帧中传输 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:1","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#rs---cell-specific"},{"categories":["WirelessCommunication"],"content":" RS - MBSFN下图基于 36.211 的图 6.10.2.2-1：MBSFN 参考信号的映射（扩展循环前缀，Δf= 15 kHz） Reference Signal - MBSFN ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:2","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#rs---mbsfn"},{"categories":["WirelessCommunication"],"content":" RS - UE Specific下图基于 36.211 的图 6.10.3.2-1：特定于 UE 的参考信号，天线端口 5（正常循环前缀）的映射 Reference Signal - UE Specific - Antenna Port 5 Reference Signal - UE Specific - Antenna Port 5 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:3","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#rs---ue-specific"},{"categories":["WirelessCommunication"],"content":" RS - Positioning下图基于 36.211 的图 6.10.4.2-1：定位参考信号的映射（正常循环前缀） Reference Signal - Positioning - Antenna Port 6 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:4","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#rs---positioning"},{"categories":["WirelessCommunication"],"content":" RS - CSI下图基于 36.211 的图 6.10.5.2-1：CSI 参考信号的映射（CSI 配置 0，常规循环前缀） Reference Signal - CSI - Antenna Port 15,16,17,18,19,20,21,22 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:9:5","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#rs---csi"},{"categories":["WirelessCommunication"],"content":" 全帧快照下图展示了上述提及的所有物理信道在整个框架上的整体图像： Full Frame ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:10:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#全帧快照"},{"categories":["WirelessCommunication"],"content":" 通信过程中的物理信道下图显示了上行/下行数据传输的总体顺序： 数据传输序列图 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:11:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#通信过程中的物理信道"},{"categories":["WirelessCommunication"],"content":" 附加图 Spectrogram - LTE FDD DL - Radio Frame Spectrogram - LTE FDD DL - PBCH Spectrogram - LTE FDD DL - PSS/SSS Spectrogram - LTE FDD DL - Each Symbol ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:12:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#附加图"},{"categories":["WirelessCommunication"],"content":" 另见LTE 系列：物理信号 LTE 系列：物理信道 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:13:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#另见"},{"categories":["WirelessCommunication"],"content":" 参考 [1] Physical Channels and Signals [2] LTE 的信道 ","date":"2019-07-30","objectID":"/lte_physical_channels_and_signals/:14:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：帧中的物理信道和信号","uri":"/lte_physical_channels_and_signals/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 下行链路帧结构详细讲解 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:0:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/#"},{"categories":["WirelessCommunication"],"content":" 下行帧结构","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/#下行帧结构"},{"categories":["WirelessCommunication"],"content":" FDD——类型 136.211 中 FDD LTE 的帧结构概览图如下所示： FDD 帧结构 上图仅显示了帧在时域上的结构，而没有显示频域上的结构。 从图中可以看处： 一帧（一个无线帧，一个系统帧）的持续时间是 10 ms。 一帧（10 毫秒）的样本数是 307200（307.200 K）。 一帧中有 10 个子帧。 一个子帧中有 2 个时隙。 那么一个时隙是时域上最小的结构吗？不，如果进一步放大此结构，则会得到下图： 时隙结构 可以观察到一个时隙由 7 个符号组成。（一个符号是信号的某个时间跨度，在 I/Q 星座中的一个点。） 在符号的开头，还有一个很小的跨度，称为循环前缀，其余部分是真实的符号数据。 LTE 中有两种不同类型的循环前缀。一种是普通循环前缀；另一个是扩展循环前缀，其长度比普通循环前缀更长。（由于一个时隙的长度是固定的且不能更改，因此，如果使用扩展循环前缀，则一个时隙内则只能有 6 个符号）。 继续放大子帧以可以观察到确切的时间和采样，如下图所示： 符号结构 此图中显示的长度不随采样率而变化，但是每个符号和 CP 中的采样数随采样率而变化。此图中显示的样本数基于 30.72 Mhz 采样率的情况。 关于上述子帧结构，需要注意的几件事是： 时隙中的第一个 OFDM 符号比剩下的 OFDM 符号长一些。 上图中显示的样本数基于以下参数设置：采样率为 30.72M 个样本/秒和 2048 个 bin/IFFT（$N_{ifft}$）。实际采样率和 $N_{ifft}$ 可能会随系统带宽而变化，需要根据特定带宽来缩放。 每种系统带宽的典型 $N_{ifft}$ 如下: System BW Number of RBs $N_{ifft}$ (bins/IFFT) 1.4 6 128 3.0 15 256 5.0 25 512 10.0 50 1024 15.0 75 2048 20.0 100 2048 下图是LTE 资源网格的总体子帧结构： LTE 资源网格 以下显示所有 4 个天线信号叠加（重叠）的理想情况下的下行链路帧结构和 RE（Resource Element，资源元素）映射的示例。 4天线帧结构和 RE 映射示例 实际上，来自每个天线的信号具有略微不同的符号数据和参考信号位置。 RE 映射的顶部和底部显示的星座图是 LTE 信号分析器测量来自 LTE 网络模拟器的 LTE 信号的测量结果。这是在 LTE 网络正在传输 MIB/SIB 且 UE 未连接的情况下在天线端口 0 处捕获的。如果您使用不同的信道功率（例如 PCFICH 功率，PDCCH 功率，CRS 功率等）执行类似的操作，则可能会看到一些不同的星座图。 现在我们进一步放大结构，但这一次是在频域而不是时域扩展。我们将获得以下完整的详细图： 下行帧结构物理信道 如上所述，我们可以在二维图中表示 LTE 信号。横轴是时域，纵轴是频域。纵轴上的最小单位是子载波，横轴上的最小单位是符号。时域和频域多个较小单位组合成较大单位。 首先让我们看一下频域结构： LTE（无论 OFDM/OFDMA）频带由多个小间隔信道组成，这些小信道称为子载波。 无论 LTE 频带的系统带宽是多少，子载波间隔都相同。 如果 LTE 信道的系统带宽发生变化，则信道数（子载波）会发生变化，但信道之间的间隔不会发生变化。 子载波和下一个子载波之间的空间是多少？ 15 Khz 20 Mhz LTE 频段的信道（子载波）数量是多少？ 1200 个子载波。 10 Mhz LTE 频段的信道（子载波）数量是多少？ 600 个子载波。 5 Mhz LTE 频段的信道（子载波）数量是多少？ 300 个子载波。 接着我们看一下横轴（即时域）的上的基本组成单位。时域上的最小单位是符号，长度为 66.7 us。无论带宽如何，符号长度都不会改变。 一个时隙中有多少个符号？ A\u003e 7 个符号。 一个子帧中有多少个符号？ A\u003e 14 个符号。 一个帧中有几个时隙？ A\u003e 20 个时隙。 现在，让我们看一下由时域（横轴）和频域（竖轴）组成的单位。我们将此类型的单元称为二维单元。 最小的二维单位是 RE，它由时域中的一个符号和频域中的一个子载波组成。另一个二维单位是 RB（Resource Block，资源块），它由时域中的一个时隙和频域中的 12 个子载波组成。RB 是 LTE 中协议侧和 RF 测量侧最重要的单元。 一个资源块中有多少个符号？ 7 个符号。 一个资源块中有多少个子载波？ 12 个子载波。 一个资源块中有多少资源元素？ 84 个资源元素。 那么 20 Mhz 频带中有多少资源块？ 100 个资源块。 10 Mhz 频带中有多少资源块？ 50 个资源块。 5 Mhz 频带中有多少资源块？ 25 个资源块。 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:1","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/#fdd类型-1"},{"categories":["WirelessCommunication"],"content":" TDD——类型 2 TDD 帧结构 以下是使用 Sandesh Dhagle’s Resource Grid Tools 生成的各种配置的 TDD UL/DL 资源分配图。 类别 颜色 PDCCH 橙色 PBCH 蓝色 PSS 紫色 SSS 浅蓝色 PDSCH 白色 Reserved 黑色 Ref Signal 红色 PCFICH 浅绿色 PHICH 黄色 TDD Uplink 绿色 Guard Period 灰色 Configuration 0, Special Subframe Config 0 Configuration 1, Special Subframe Config 0 Configuration 2, Special Subframe Config 0 Configuration 3, Special Subframe Config 0 Configuration 4, Special Subframe Config 0 Configuration 5, Special Subframe Config 0 Configuration 6, Special Subframe Config 0 下面展示具有不同特殊子帧配置的资源网格的示例。在这些示例中，仅注意子帧 0 和子帧 6 中的符号结构如何变化。 Configuration 0, Special Subframe Config 0 Configuration 0, Special Subframe Config 1 Configuration 0, Special Subframe Config 2 Configuration 0, Special Subframe Config 3 Configuration 0, Special Subframe Config 4 Configuration 0, Special Subframe Config 5 Configuration 0, Special Subframe Config 6 Configuration 0, Special Subframe Config 7 Configuration 0, Special Subframe Config 8 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:2","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/#tdd类型-2"},{"categories":["WirelessCommunication"],"content":" LAA——类型 3从 3GPP Rel 13 开始，提出了一种新的帧结构，主要应用于 LAA（License Assisted Access，许可辅助访问），与 LTE-U 一样，这也是一种在未经许可的频率范围内传输 LTE 信号的技术。 然而，与 LTE-U 不同的是，LAA 使用一种特殊的物理层帧结构，称为帧结构类型 3，这是以前不存在的。这种新的帧结构旨在使 LTE 信号类似于 WLAN 突发，并使 LTE 信号更好地与现有的 WLAN 业务共存。更多详情参见 LAA。 ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:1:3","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/#laa类型-3"},{"categories":["WirelessCommunication"],"content":" 参考 [1] Frame Structure - Downlink [2] Sandesh Dhagle’s Resource Grid Tools ","date":"2019-07-29","objectID":"/lte_downlink_frame_structure/:2:0","series":null,"tags":["LTE","Translation"],"title":"LTE 系列：下行链路帧结构","uri":"/lte_downlink_frame_structure/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 无线帧结构详解 ","date":"2019-07-08","objectID":"/lte_frame_structure/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/#"},{"categories":["WirelessCommunication"],"content":" 无线帧结构物理层定义了无线帧的结构，LTE 支持两种帧结构： Type 1 ，用于 FDD Type 2，用于 TDD 1 个无线帧的长度为 10ms，分为 10 个长度等于 1ms 的子帧。 LTE 空中接口物理资源分配的最小时间单位是 1 个传输时间间隔（Transmission Time Interval，TTI），1 个 TTI 的长度是 1 个子帧，即 1ms。 在 Type 1 FDD 帧结构中，1 个 10ms 的无线帧分为 10 个长度为 1ms 的子帧（Subframe），每个子帧由两个长度为 0.5ms 的时隙（Slot）组成。 Type 1 FDD 帧结构 在 Type 2 TDD 帧结构中，1 个 10ms 的无线帧分为两个长度为 5ms 的半帧（Half Frame），每个半帧由 5 个长度为 1ms 的子帧组成，其中包括 4 个普通子帧和 1 个特殊子帧。普通子帧由两个 0.5ms 的时隙组成，而特殊子帧由 3 个特殊时隙（UpPTS、GP 和 DwPTS）组成。 Type 2 TDD 帧结构 Type 2 TDD 的特殊时隙 GP（Guard Period）是 TDD 上下行转换的保护间隔。 TDD 双工方式的系统中，由于信号的传输时延和设备收发的转换时延，为了避免上下行信号之间的干扰，需要在上下行转换的时候设置一定的保护时间间隔。 设备收发的转换时延：指的是终端／基站在发送／接收状态间转换的设备时延，典型值在 10 ～ 20μs 之间 信号的传输时延：主要与小区的覆盖半径相关，需要根据系统规划进行相应的设置。在 Release 8 版本的系统设计中，支持 GP 长度在 71 ～ 714μs 范围之内的不同设置，相对应的最大小区半径为 7 ～ 100km DwPTS（Downlink Pilot Time Slot）用于下行信号的发送，根据不同的配置，DwPTS 的长度可以是 3 ～ 12 个 OFDM 符号。LTE TDD 系统的主同步信号位于它的第 3 个符号，DwPTS 中的其他资源用作正常的下行控制信道和下行共享信道的发送。 UpPTS（Uplink Pilot Time Slot）用于上行信号的发送，它的长度可以配置为 1 ～ 2 个 OFDM 符号，UpPTS 可以用于承载物理随机接入信道（PRACH Format 4）和 Sounding 导频信号。 Type 2 TDD 帧结构支持 7 种不同的上下行时间比例分配（即配置 0 ～ 6），可以根据系统业务量的特性进行设置。 这 7 种配置包括 3 种 5ms 周期和 4 种 10ms 周期的情况: 5ms 周期的配置中，每个长度为 5ms 半帧包含 1 个下行到上行的转换时间间隔 GP 10ms 周期的配置中，每个长度为 10ms 的无线帧包含 1 个或者 2 个下行到上行的转换时间间隔 GP 在系统广播消息 SIB1 中使用 3 个比特指示 TDD 上下行时间比例的配置信息。 LTE Type 2 TDD 上下行时间配比的配置 ","date":"2019-07-08","objectID":"/lte_frame_structure/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/#无线帧结构"},{"categories":["WirelessCommunication"],"content":" 另见LTE 系列：下行链路帧结构 LTE 系列：上行链路帧结构 ","date":"2019-07-08","objectID":"/lte_frame_structure/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/#另见"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-07-08","objectID":"/lte_frame_structure/:3:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线帧结构","uri":"/lte_frame_structure/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 物理层概要综列 ","date":"2019-06-28","objectID":"/lte_physical_layer/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/#"},{"categories":["WirelessCommunication"],"content":" 物理层的功能物理层位于无线接入网协议的最底层，以传输信道为接口，通过传输信道向物理信道的映射，物理层向上层提供数据传输的服务。 物理层的主要功能包括： 传输信道向物理信道的映射 调制与解调 纠错编码与速率匹配 向高层报告数据是否正确传输 多天线的处理 功率控制 频率和时间的同步 射频信号的生成 ","date":"2019-06-28","objectID":"/lte_physical_layer/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/#物理层的功能"},{"categories":["WirelessCommunication"],"content":" 物理层的关键技术物理层的包含以下关键技术： 多址方式 无线帧结构 基本物理资源及分配方法 数据的编码、复用和交织 多天线技术（MIMO） ","date":"2019-06-28","objectID":"/lte_physical_layer/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/#物理层的关键技术"},{"categories":["WirelessCommunication"],"content":" 物理层信号和信道的设计出于对 MAC 层的传输信道以及物理层内部处理过程的需要，物理层定义了一系列的物理信道。 下行方向的物理信道包括： 物理广播信道（PBCH） 物理下行共享信道（PDSCH） 物理多播信道（PMCH） 物理下行控制信道（PDCCH） 物理控制格式指示信道（PCFICH） 物理 HARQ 指示信道（PHICH） 上行方向的物理信道包括： 物理随机接入信道（PRACH） 物理上行共享信道（PUSCH） 物理上行控制信道（PUCCH） 下行信道映射 上行信道映射 物理信号主要包括： 导频信号 同步信号（PSS/SSS） 详细内容另见： LTE 系列：物理信号 LTE 系列：物理信道 LTE 系列：帧中的物理信道和信号 ","date":"2019-06-28","objectID":"/lte_physical_layer/:3:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/#物理层信号和信道的设计"},{"categories":["WirelessCommunication"],"content":" 物理层过程讲解典型的物理层过程包括： 终端的小区搜索和下行同步 功率控制 上/下行共享信道的传输与接收 ","date":"2019-06-28","objectID":"/lte_physical_layer/:4:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/#物理层过程"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-28","objectID":"/lte_physical_layer/:5:0","series":null,"tags":["LTE"],"title":"LTE 系列：物理层概要","uri":"/lte_physical_layer/#参考"},{"categories":["WirelessCommunication"],"content":" LTE RRC 层详解 ","date":"2019-06-21","objectID":"/lte_rrc/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#"},{"categories":["WirelessCommunication"],"content":" 无线资源控制（RRC）无线资源控制（Radio Resource Control，RRC）层是 LTE 无线接入网协议中控制面部分的主要内容。 用户终端在进行数据通信之前，需要与网络建立承载信令消息的连接，通过信令消息的交互，控制数据通信的过程。因此，是否与网络建立了 RRC 连接是终端状态的判断依据。 RRC 连接状态即已经与网络建立了 RRC 连接的终端处于连接状态，此时终端可以进行数据传输、系统信息接收，以及邻小区的测量上报和小区切换 RRC 空闲状态即没有与网络建立 RRC 连接，那么终端处于空闲状态，此时终端不进行数据的传输，仍然需要执行的功能包括：系统信息的接收、侦听寻呼，以及邻小区测量和小区重选 RRC 协议包括以下的主要功能： 系统信息的广播，包括接入网的系统广播消息，以及核心网非接入层（NAS）系统信息的广播 连接控制，包括信令承载（即 RRC 连接）的建立／重配置／重建立／释放、数据无线承载的建立／配置／释放，以及相关的完整性保护的数据加密的安全机制 移动性管理，包括配置终端的测量和上报，以及终端的小区选择、重选、寻呼和切换过程 服务质量（QoS）管理 NAS 信令直接传输的功能 ","date":"2019-06-21","objectID":"/lte_rrc/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#无线资源控制rrc"},{"categories":["WirelessCommunication"],"content":" 系统信息的广播系统信息描述网络的基本情况，采用广播的方式进行发送，对应于广播控制逻辑信道（BCCH）。终端通过对系统信息的接收，获得在系统中进行通信所需要的基本网络参数。 LTE 的系统信息分为： 主信息块（Master Information Block，MIB） 主信息块（MIB）包括小区最基本的物理层信息，例如：系统下行信号的带宽、无线帧序号和发送天线的数目。终端需要获得这些基本的信息才能够进一步接收系统的其他信息。 MIB 信息在专门定义的广播传输信道（BCH）上，采用物理层广播信道（PBCH）在固定的时间和频率位置进行传输。MIB 采用 40ms 的周期重复发送，每个周期之内包括 4 次间隔为 10ms 的传输，在序号 SFN%4=0 无线帧的第 0 个子帧开始每个周期的第一次传输，其余 3 次传输发生在随后 3 个无线帧的第 0 个子帧的位置。 系统信息块（System Information Block，SIB） 系统信息块（SIB）映射在下行共享传输信道（DL-SCH）上进行传输，采用 SI-RNTI 进行指示。根据所传输信息的不同，SIB 分为多种类型：Type 1 ～ Type 12 SIB1（Type 1 信息）：包括了是否允许终端接入小区的相关信息，例如系统的公众网络标识（PLMN）、小区标识、关闭的用户组（CSG）信息以及 TDD 系统上下行时隙比例的配置信息。SIB1 中还承载了其他系统信息块（SIB2 ～ SIB13）的调度信息 SIB2：承载用于所有终端公共的无线资源配置信息，例如系统上行信号的频率／带宽、MBSFN 子帧、随机接入信道、寻呼信道、上行 sounding 导频和上行功率控制等的配置情况 SIB3 ～ SIB8：承载用于终端进行小区重选的相关参数，分别针对于同频、异频和异系统 3G/GSM/cdma2000 各种不同的情况。SIB9 指示关于家庭基站名字的信息 SIB10 ～ SIB12：用于公共灾害的警示服务，即地震和海啸警报系统（Earthquake and Tsunami Warning System，ETWS）和商用移动警报服务（Commercial MobileAlert Service，CMAS） SIB1 信息使用固定的时间位置进行传输，采用 80ms 的周期重复发送，每个周期之内包括 4 次间隔为 20ms 的传输，在序号 SFN%8=0 无线帧的第 5 个子帧开始每个周期的第一次传输，其余 3 次传输发生在随后 3 个序号为偶数的无线帧的第 5 个子帧的位置。 除了 SIB1 之外，其余的 SIB 消息映射在系统信息（System Information，SI）上进行传输，它们的映射关系可以进行灵活的配置，由 SIB1 中承载的调度信息进行指示。一个 SIB 消息只能映射在一个 SI 上进行传输，而一个 SI 可以包含多个具有相同周期的 SIB 消息。 系统广播信息向传输信道的映射如图所示: 系统广播信息向传输信道的映射 系统广播信息的更新采用更新提示和信息更新两个阶段的方式。 根据系统配置的更新周期（最小值为 640ms），当需要对系统广播消息进行更新的时候，系统在前一个更新周期使用寻呼消息提示用户，系统广播消息将发生改变，但是在这个更新周期中，仍然发送原来的系统信息。在下一个更新周期，将发送改变之后的系统信息，终端根据该信息进行更新。 系统广播信息的更新 ","date":"2019-06-21","objectID":"/lte_rrc/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#系统信息的广播"},{"categories":["WirelessCommunication"],"content":" 对连接的控制连接控制指的是对接入网中的无线承载进行控制的功能，包括信令承载的建立／重配置／重建立／释放、数据承载的建立／配置／释放，以及相关的完整性保护和数据加密的通信安全机制。 连接管理LTE 中一共定义了 3 个用于信令的无线承载（Signaling Radio Bearer，SRB）： SRB0 用于承载公用控制逻辑信道（CCCH）的 RRC 消息 SRB1 主要用于承载专用控制逻辑信道（DCCH）的 RRC 消息 通常所说的建立 RRC 连接指的是信令无线承载 SRB1 的建立。 SRB2 用于承载专用控制逻辑信道（DCCH）的核心网非接入层（NAS）控制信息。 终端开机在网络中进行注册之后处于空闲状态，终端首先建立传输 RRC 消息的信令承载 SRB1，终端进入 RRC 连接状态，然后，系统建立传输 NAS 消息的信令无线承载 SRB2 和传输数据的无线承载 DRB，由此可以开始进行数据的通信。 RRC 连接建立的过程 进入 RRC 连接状态之后，采用 RRC 连接重配置的过程来进行 SRB2 和 DRB 的建立和管理。 重配置过程在连接状态下对 RRC 连接进行更改，包括： 建立／更改／释放无线承载， 进行小区切换的过程 建立／更改／释放终端的测量和上报 对应于这些功能，RRC 连接重配置消息中可能携带的信息包括： 无线资源的配置情况（无线承载、MAC 层和物理层），其中含有如下信息： 公共的配置信息，描述了移动性控制信息和系统信息中公共的无线资源配置情况，例如随机接入信道的参数、系统上行 sounding 导频配置和上行功率控制参数等静态的物理层配置信息 专用的配置信息，专用的配置信息用于无线承载的管理，例如 MAC 层配置、SPS 调度以及专用的物理层配置等 移动性控制的相关参数 无线测量的配置信息 RRC 连接重配置的过程 按照 RRC 连接重配置消息中携带的配置信息，无线承载建立的过程包括建立一个 PDCP 实体、建立一个 RLC 实体，以及按照指定的逻辑信道标识建立一个逻辑信道。 与建立的过程相对应，当 RRC 连接重配置消息指示释放某个无线承载的时候，将释放相应的 PDCP 实体、RLC 实体和逻辑信道。通过 RRC 连接释放的过程，终端由 RRC 连接状态转变为空闲状态。这个过程释放 RRC 连接，包括所有已经建立的信令和数据的无线承载，以及所有的无线资源。 RRC连接释放的过程 通信安全的功能为了保证通信的安全，防止窃听、伪装等恶意行为，无线接入网的连接控制中包含安全通信的相关功能，包括： 信令消息的完整性保护 信令消息加密 数据消息的加密 在 RRC 连接建立的过程中，无线接入网从核心网取得终端用户的相关信息，然后可以使用安全模式激活的 RRC 消息设置用户密钥和加密算法，开启信令完整性保护和加密的功能，从而保证后续通信过程的安全（包括 SRB2 和 DRB 的建立等）。 安全模式激活的过程 在通信的过程中还可以通过计数器检查（counter check）的 RRC 消息防止中间人（man in the middle）攻击。在计数器检查的过程中，网络发送计数器检查消息要求终端确认在每个数据无线承载 DRB 上发送和接收数据的数量，通过这样的方法可以排除中间人可能进行的伪装通信。 计数器检查的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#对连接的控制"},{"categories":["WirelessCommunication"],"content":" 对连接的控制连接控制指的是对接入网中的无线承载进行控制的功能，包括信令承载的建立／重配置／重建立／释放、数据承载的建立／配置／释放，以及相关的完整性保护和数据加密的通信安全机制。 连接管理LTE 中一共定义了 3 个用于信令的无线承载（Signaling Radio Bearer，SRB）： SRB0 用于承载公用控制逻辑信道（CCCH）的 RRC 消息 SRB1 主要用于承载专用控制逻辑信道（DCCH）的 RRC 消息 通常所说的建立 RRC 连接指的是信令无线承载 SRB1 的建立。 SRB2 用于承载专用控制逻辑信道（DCCH）的核心网非接入层（NAS）控制信息。 终端开机在网络中进行注册之后处于空闲状态，终端首先建立传输 RRC 消息的信令承载 SRB1，终端进入 RRC 连接状态，然后，系统建立传输 NAS 消息的信令无线承载 SRB2 和传输数据的无线承载 DRB，由此可以开始进行数据的通信。 RRC 连接建立的过程 进入 RRC 连接状态之后，采用 RRC 连接重配置的过程来进行 SRB2 和 DRB 的建立和管理。 重配置过程在连接状态下对 RRC 连接进行更改，包括： 建立／更改／释放无线承载， 进行小区切换的过程 建立／更改／释放终端的测量和上报 对应于这些功能，RRC 连接重配置消息中可能携带的信息包括： 无线资源的配置情况（无线承载、MAC 层和物理层），其中含有如下信息： 公共的配置信息，描述了移动性控制信息和系统信息中公共的无线资源配置情况，例如随机接入信道的参数、系统上行 sounding 导频配置和上行功率控制参数等静态的物理层配置信息 专用的配置信息，专用的配置信息用于无线承载的管理，例如 MAC 层配置、SPS 调度以及专用的物理层配置等 移动性控制的相关参数 无线测量的配置信息 RRC 连接重配置的过程 按照 RRC 连接重配置消息中携带的配置信息，无线承载建立的过程包括建立一个 PDCP 实体、建立一个 RLC 实体，以及按照指定的逻辑信道标识建立一个逻辑信道。 与建立的过程相对应，当 RRC 连接重配置消息指示释放某个无线承载的时候，将释放相应的 PDCP 实体、RLC 实体和逻辑信道。通过 RRC 连接释放的过程，终端由 RRC 连接状态转变为空闲状态。这个过程释放 RRC 连接，包括所有已经建立的信令和数据的无线承载，以及所有的无线资源。 RRC连接释放的过程 通信安全的功能为了保证通信的安全，防止窃听、伪装等恶意行为，无线接入网的连接控制中包含安全通信的相关功能，包括： 信令消息的完整性保护 信令消息加密 数据消息的加密 在 RRC 连接建立的过程中，无线接入网从核心网取得终端用户的相关信息，然后可以使用安全模式激活的 RRC 消息设置用户密钥和加密算法，开启信令完整性保护和加密的功能，从而保证后续通信过程的安全（包括 SRB2 和 DRB 的建立等）。 安全模式激活的过程 在通信的过程中还可以通过计数器检查（counter check）的 RRC 消息防止中间人（man in the middle）攻击。在计数器检查的过程中，网络发送计数器检查消息要求终端确认在每个数据无线承载 DRB 上发送和接收数据的数量，通过这样的方法可以排除中间人可能进行的伪装通信。 计数器检查的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#连接管理"},{"categories":["WirelessCommunication"],"content":" 对连接的控制连接控制指的是对接入网中的无线承载进行控制的功能，包括信令承载的建立／重配置／重建立／释放、数据承载的建立／配置／释放，以及相关的完整性保护和数据加密的通信安全机制。 连接管理LTE 中一共定义了 3 个用于信令的无线承载（Signaling Radio Bearer，SRB）： SRB0 用于承载公用控制逻辑信道（CCCH）的 RRC 消息 SRB1 主要用于承载专用控制逻辑信道（DCCH）的 RRC 消息 通常所说的建立 RRC 连接指的是信令无线承载 SRB1 的建立。 SRB2 用于承载专用控制逻辑信道（DCCH）的核心网非接入层（NAS）控制信息。 终端开机在网络中进行注册之后处于空闲状态，终端首先建立传输 RRC 消息的信令承载 SRB1，终端进入 RRC 连接状态，然后，系统建立传输 NAS 消息的信令无线承载 SRB2 和传输数据的无线承载 DRB，由此可以开始进行数据的通信。 RRC 连接建立的过程 进入 RRC 连接状态之后，采用 RRC 连接重配置的过程来进行 SRB2 和 DRB 的建立和管理。 重配置过程在连接状态下对 RRC 连接进行更改，包括： 建立／更改／释放无线承载， 进行小区切换的过程 建立／更改／释放终端的测量和上报 对应于这些功能，RRC 连接重配置消息中可能携带的信息包括： 无线资源的配置情况（无线承载、MAC 层和物理层），其中含有如下信息： 公共的配置信息，描述了移动性控制信息和系统信息中公共的无线资源配置情况，例如随机接入信道的参数、系统上行 sounding 导频配置和上行功率控制参数等静态的物理层配置信息 专用的配置信息，专用的配置信息用于无线承载的管理，例如 MAC 层配置、SPS 调度以及专用的物理层配置等 移动性控制的相关参数 无线测量的配置信息 RRC 连接重配置的过程 按照 RRC 连接重配置消息中携带的配置信息，无线承载建立的过程包括建立一个 PDCP 实体、建立一个 RLC 实体，以及按照指定的逻辑信道标识建立一个逻辑信道。 与建立的过程相对应，当 RRC 连接重配置消息指示释放某个无线承载的时候，将释放相应的 PDCP 实体、RLC 实体和逻辑信道。通过 RRC 连接释放的过程，终端由 RRC 连接状态转变为空闲状态。这个过程释放 RRC 连接，包括所有已经建立的信令和数据的无线承载，以及所有的无线资源。 RRC连接释放的过程 通信安全的功能为了保证通信的安全，防止窃听、伪装等恶意行为，无线接入网的连接控制中包含安全通信的相关功能，包括： 信令消息的完整性保护 信令消息加密 数据消息的加密 在 RRC 连接建立的过程中，无线接入网从核心网取得终端用户的相关信息，然后可以使用安全模式激活的 RRC 消息设置用户密钥和加密算法，开启信令完整性保护和加密的功能，从而保证后续通信过程的安全（包括 SRB2 和 DRB 的建立等）。 安全模式激活的过程 在通信的过程中还可以通过计数器检查（counter check）的 RRC 消息防止中间人（man in the middle）攻击。在计数器检查的过程中，网络发送计数器检查消息要求终端确认在每个数据无线承载 DRB 上发送和接收数据的数量，通过这样的方法可以排除中间人可能进行的伪装通信。 计数器检查的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#通信安全的功能"},{"categories":["WirelessCommunication"],"content":" 终端移动性的管理终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括: 终端与无线接入网之间的 RRC 控制协议 终端与核心网之间非接入层（NAS）控制协议 空闲状态终端的移动性管理处于 RRC 空闲状态的终端与无线接入网没有建立 RRC 连接，终端的信息在核心网中注册并且分配有 IP 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 DRX 周期监听可能的寻呼消息。空闲状态的终端不能进行单播数据的传输。 在终端开机的过程中，首先根据 PLMN（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。 终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。 空闲状态终端的寻呼和跟踪区改变 当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网移动控制实体（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。 连接状态终端的移动性管理处于 RRC 连接状态的终端与无线接入网建立了 RRC 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。RRC 连接状态的终端可以进行单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 DRX 功能。 RRC 连接状态终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。 连接状态终端的小区间切换 切换过程首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程： 通过 eNodeB 之间互联的 X2 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。 如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 C-RNTI 标识、目标小区的系统信息，以及分配的专用随机接入序列等。 源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 RRC 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(注： 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。) 收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。 无线接入网的切换完成后，目标基站将向核心网的移动控制实体（MME）发送路径切换请求，并由 MME 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。 完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。 配置终端的测量和上报为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括： 同频测量场景 异频测量场景 异系统的测量场景 网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 RRC 连接状态的终端，通过 RRC 信令（即 RRC 连接重配置消息）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。 在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为同频测量，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，不需要测量间隔，也就是说，在对同频目标小区进行测量的时候，终端不需要中断对源服务小区的信号接收。 源服务小区和目标小区工作在不同载波频率的场景属于异频测量，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端中断对源小区的信号接收，将接收频率调整到目标小区进行测量。 对终端的测量进行配置的消息内容主要包括测量的对象和测量上报的配置。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。 适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括： A1 事件，服务小区的信号质量优于某个设定的门限 A2 事件，服务小区的信号质量差于某个设定的门限 A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限 A4 事件，相邻小区的信号质量优于某个设定的门限 A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限 另外，针对与异系统之间的移动性操作，定义了两种事件： B1 事件，异系统相邻小区的信号质量优于某个设定的门限 B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限 终端测量上报的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#终端移动性的管理"},{"categories":["WirelessCommunication"],"content":" 终端移动性的管理终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括: 终端与无线接入网之间的 RRC 控制协议 终端与核心网之间非接入层（NAS）控制协议 空闲状态终端的移动性管理处于 RRC 空闲状态的终端与无线接入网没有建立 RRC 连接，终端的信息在核心网中注册并且分配有 IP 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 DRX 周期监听可能的寻呼消息。空闲状态的终端不能进行单播数据的传输。 在终端开机的过程中，首先根据 PLMN（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。 终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。 空闲状态终端的寻呼和跟踪区改变 当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网移动控制实体（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。 连接状态终端的移动性管理处于 RRC 连接状态的终端与无线接入网建立了 RRC 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。RRC 连接状态的终端可以进行单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 DRX 功能。 RRC 连接状态终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。 连接状态终端的小区间切换 切换过程首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程： 通过 eNodeB 之间互联的 X2 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。 如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 C-RNTI 标识、目标小区的系统信息，以及分配的专用随机接入序列等。 源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 RRC 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(注： 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。) 收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。 无线接入网的切换完成后，目标基站将向核心网的移动控制实体（MME）发送路径切换请求，并由 MME 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。 完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。 配置终端的测量和上报为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括： 同频测量场景 异频测量场景 异系统的测量场景 网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 RRC 连接状态的终端，通过 RRC 信令（即 RRC 连接重配置消息）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。 在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为同频测量，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，不需要测量间隔，也就是说，在对同频目标小区进行测量的时候，终端不需要中断对源服务小区的信号接收。 源服务小区和目标小区工作在不同载波频率的场景属于异频测量，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端中断对源小区的信号接收，将接收频率调整到目标小区进行测量。 对终端的测量进行配置的消息内容主要包括测量的对象和测量上报的配置。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。 适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括： A1 事件，服务小区的信号质量优于某个设定的门限 A2 事件，服务小区的信号质量差于某个设定的门限 A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限 A4 事件，相邻小区的信号质量优于某个设定的门限 A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限 另外，针对与异系统之间的移动性操作，定义了两种事件： B1 事件，异系统相邻小区的信号质量优于某个设定的门限 B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限 终端测量上报的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#空闲状态终端的移动性管理"},{"categories":["WirelessCommunication"],"content":" 终端移动性的管理终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括: 终端与无线接入网之间的 RRC 控制协议 终端与核心网之间非接入层（NAS）控制协议 空闲状态终端的移动性管理处于 RRC 空闲状态的终端与无线接入网没有建立 RRC 连接，终端的信息在核心网中注册并且分配有 IP 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 DRX 周期监听可能的寻呼消息。空闲状态的终端不能进行单播数据的传输。 在终端开机的过程中，首先根据 PLMN（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。 终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。 空闲状态终端的寻呼和跟踪区改变 当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网移动控制实体（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。 连接状态终端的移动性管理处于 RRC 连接状态的终端与无线接入网建立了 RRC 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。RRC 连接状态的终端可以进行单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 DRX 功能。 RRC 连接状态终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。 连接状态终端的小区间切换 切换过程首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程： 通过 eNodeB 之间互联的 X2 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。 如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 C-RNTI 标识、目标小区的系统信息，以及分配的专用随机接入序列等。 源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 RRC 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(注： 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。) 收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。 无线接入网的切换完成后，目标基站将向核心网的移动控制实体（MME）发送路径切换请求，并由 MME 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。 完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。 配置终端的测量和上报为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括： 同频测量场景 异频测量场景 异系统的测量场景 网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 RRC 连接状态的终端，通过 RRC 信令（即 RRC 连接重配置消息）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。 在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为同频测量，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，不需要测量间隔，也就是说，在对同频目标小区进行测量的时候，终端不需要中断对源服务小区的信号接收。 源服务小区和目标小区工作在不同载波频率的场景属于异频测量，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端中断对源小区的信号接收，将接收频率调整到目标小区进行测量。 对终端的测量进行配置的消息内容主要包括测量的对象和测量上报的配置。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。 适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括： A1 事件，服务小区的信号质量优于某个设定的门限 A2 事件，服务小区的信号质量差于某个设定的门限 A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限 A4 事件，相邻小区的信号质量优于某个设定的门限 A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限 另外，针对与异系统之间的移动性操作，定义了两种事件： B1 事件，异系统相邻小区的信号质量优于某个设定的门限 B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限 终端测量上报的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#连接状态终端的移动性管理"},{"categories":["WirelessCommunication"],"content":" 终端移动性的管理终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括: 终端与无线接入网之间的 RRC 控制协议 终端与核心网之间非接入层（NAS）控制协议 空闲状态终端的移动性管理处于 RRC 空闲状态的终端与无线接入网没有建立 RRC 连接，终端的信息在核心网中注册并且分配有 IP 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 DRX 周期监听可能的寻呼消息。空闲状态的终端不能进行单播数据的传输。 在终端开机的过程中，首先根据 PLMN（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。 终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。 空闲状态终端的寻呼和跟踪区改变 当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网移动控制实体（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。 连接状态终端的移动性管理处于 RRC 连接状态的终端与无线接入网建立了 RRC 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。RRC 连接状态的终端可以进行单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 DRX 功能。 RRC 连接状态终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。 连接状态终端的小区间切换 切换过程首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程： 通过 eNodeB 之间互联的 X2 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。 如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 C-RNTI 标识、目标小区的系统信息，以及分配的专用随机接入序列等。 源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 RRC 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(注： 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。) 收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。 无线接入网的切换完成后，目标基站将向核心网的移动控制实体（MME）发送路径切换请求，并由 MME 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。 完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。 配置终端的测量和上报为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括： 同频测量场景 异频测量场景 异系统的测量场景 网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 RRC 连接状态的终端，通过 RRC 信令（即 RRC 连接重配置消息）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。 在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为同频测量，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，不需要测量间隔，也就是说，在对同频目标小区进行测量的时候，终端不需要中断对源服务小区的信号接收。 源服务小区和目标小区工作在不同载波频率的场景属于异频测量，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端中断对源小区的信号接收，将接收频率调整到目标小区进行测量。 对终端的测量进行配置的消息内容主要包括测量的对象和测量上报的配置。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。 适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括： A1 事件，服务小区的信号质量优于某个设定的门限 A2 事件，服务小区的信号质量差于某个设定的门限 A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限 A4 事件，相邻小区的信号质量优于某个设定的门限 A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限 另外，针对与异系统之间的移动性操作，定义了两种事件： B1 事件，异系统相邻小区的信号质量优于某个设定的门限 B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限 终端测量上报的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#切换过程"},{"categories":["WirelessCommunication"],"content":" 终端移动性的管理终端移动性的管理是 LTE 作为移动通信系统一个重要的控制功能，实现相关功能的协议包括: 终端与无线接入网之间的 RRC 控制协议 终端与核心网之间非接入层（NAS）控制协议 空闲状态终端的移动性管理处于 RRC 空闲状态的终端与无线接入网没有建立 RRC 连接，终端的信息在核心网中注册并且分配有 IP 地址，无线接入网中不存储空闲状态终端的信息。终端进行自身的移动性管理，发起小区选择／重选，当跟踪区位置发生改变的时候向核心网进行登记。核心网记录终端所处的跟踪区位置（TrackingArea，TA，通常由相邻覆盖的若干个小区组成），核心网可以发起对终端的寻呼，终端根据核心网配置的 DRX 周期监听可能的寻呼消息。空闲状态的终端不能进行单播数据的传输。 在终端开机的过程中，首先根据 PLMN（公众网络标识）进行网络的选择，选定例如某个运营商的网络，之后终端进行小区选择，确定所驻留的小区，侦听该小区的控制信道。然后采用跟踪区改变的流程向核心网注册终端所处的跟踪区位置。 终端在移动的过程中，可能由一个小区无线信号的覆盖范围进入另一个小区的覆盖范围，这时候终端将进行小区重选的操作，改变所驻留侦听控制信道的小区。如果这个小区与前一个小区属于不同的跟踪区，那么在小区重选之后，终端将发起跟踪区改变的流程，使用非接入层（NAS）信令向核心网注册新的跟踪区位置。 空闲状态终端的寻呼和跟踪区改变 当有呼叫到达或者是系统消息改变需要向空闲状态的终端发送寻呼消息的时候，核心网移动控制实体（MME）根据终端所注册的跟踪区位置，找到相对应的跟踪区列表，然后在列表中所有的跟踪区上，发送针对该终端的寻呼消息。 连接状态终端的移动性管理处于 RRC 连接状态的终端与无线接入网建立了 RRC 连接，终端的信息在核心网和无线接入网中都进行存储和管理。网络登记终端所处的小区位置，终端的移动性由网络采用切换的流程进行管理。RRC 连接状态的终端可以进行单播数据的传输。为了节省耗电，终端可以采用由无线接入网配置的 DRX 功能。 RRC 连接状态终端的移动性由网络进行控制，网络根据无线接口的情况决定是否改变终端的服务小区，即切换的过程是由网络触发的。为了获取关于无线接口情况的信息，网络可以配置终端进行相关的测量和上报，然后根据上报的结果，触发切换的流程。另外，没有收到终端的测量与上报，网络也可以自行触发进行切换。 连接状态终端的小区间切换 切换过程首先，由源服务小区配置终端进行相关的测量和上报，根据上报的信息，源服务小区判断终端是否需要进行切换并且选择目标小区，触发切换的信令流程： 通过 eNodeB 之间互联的 X2 接口，源小区向目标小区发送切换请求的消息，该消息中包含了对于目标小区无线资源需求情况的信息。 如果目标小区确定可以接受终端进行切换，那么目标小区根据要求进行无线资源的准备，并向源小区反馈切换请求确认的消息，该消息包含终端接入目标小区时需要的信息，例如新的 C-RNTI 标识、目标小区的系统信息，以及分配的专用随机接入序列等。 源服务小区在收到目标小区对于切换请求的确认消息后，采用带有移动性控制信息的 RRC 连接重配置消息将这些来自目标小区的接入配置信息转发给终端，并且命令终端向目标小区进行切换。(注： 此时，因为来自核心网数据的传输路由还没有发生改变，源基站还可能负责将数据转发给目标基站。) 收到 RRC 连接重配置消息的切换命令后，终端根据指示的信息，向目标小区发起接入，采用随机接入的过程获得与目标小区的上行同步以及上行资源的分配。然后，在所分配的上行无线资源上，终端向目标小区发送 RRC 连接重配置完成消息，确认终端已经完成了切换，目标基站已经成为终端的服务基站，可以开始向终端发送数据。 无线接入网的切换完成后，目标基站将向核心网的移动控制实体（MME）发送路径切换请求，并由 MME 协调数据网管（SGW）完成用户数据传输路径的改变，核心网将数据路径转移到目标小区。 完成数据路径的转换后，目标小区向源小区发送终端上下文释放的消息，以此来确认成功地完成了整个切换的过程，源小区释放对应于该终端用户的相关资源。 配置终端的测量和上报为了进行移动性管理的操作，终端需要根据网络的配置对无线信道的情况进行测量，包括： 同频测量场景 异频测量场景 异系统的测量场景 网络可以通过广播或者专用的控制信息配置终端的测量，对于空闲状态的终端，通过网络广播消息中配置的测量参数，终端完成小区选择／重选等移动性功能。对于 RRC 连接状态的终端，通过 RRC 信令（即 RRC 连接重配置消息）可以对终端进行专门的测量配置，终端向网络上报测量结果，协助网络进行小区切换的移动性管理。 在进行测量时，如果终端的源服务小区与目标小区工作在相同的载波频率，那么称为同频测量，例如采用频率复用系数等于 1 的同频组网的情况。进行同频测量，不需要测量间隔，也就是说，在对同频目标小区进行测量的时候，终端不需要中断对源服务小区的信号接收。 源服务小区和目标小区工作在不同载波频率的场景属于异频测量，为了对异频的目标小区进行测量，通常情况下需要配置测量间隔，终端中断对源小区的信号接收，将接收频率调整到目标小区进行测量。 对终端的测量进行配置的消息内容主要包括测量的对象和测量上报的配置。其中，每一个测量的对象对应于 LTE 系统内同频或者异频的一个载波频率，或者某一个载波频率上异系统 WCDMA 的一个小区列表。而每一个测量上报的配置包括测量上报的格式，例如上报多少个目标小区的测量结果，以及上报的触发条件，包括周期性上报和事件触发两种可能性。 适用于 LTE 系统内同频或者异频的场景一共定义有 5 种事件，包括： A1 事件，服务小区的信号质量优于某个设定的门限 A2 事件，服务小区的信号质量差于某个设定的门限 A3 事件，相邻小区的信号质量优于服务小区超过某个设定的门限 A4 事件，相邻小区的信号质量优于某个设定的门限 A5，服务小区的信号质量差于某个设定的门限的同时，相邻小区的信号质量优于某个设定的门限 另外，针对与异系统之间的移动性操作，定义了两种事件： B1 事件，异系统相邻小区的信号质量优于某个设定的门限 B2 事件，服务小区的信号质量差于某个设定的门限的同时，异系统相邻小区的信号质量优于某个设定的门限 终端测量上报的过程 ","date":"2019-06-21","objectID":"/lte_rrc/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#配置终端的测量和上报"},{"categories":["WirelessCommunication"],"content":" 服务质量（QoS）管理LTE 系统中采用 EPS 承载为单位进行端到端的服务质量（QoS）管理。 EPS（Evolved Packet System）承载是终端和分组数据网网关（P-GW）之间的连接，1 个 EPS 承载包括： 1 个无线承载，即终端和 eNodeB 基站之间的连接 1 个 S1 承载，即 eNodeB 和服务网关（S-GW）之间的连接 1 个 S5/S8 承载，即 S-GW 和 P-GW 之间的连接。 对于一个终端，网络可以建立多个 EPS 承载，每个 EPS 承载可以有不同的 QoS 参数，因此除了在不同用户之间实现不同的 QoS，属于同一个用户的多个 EPS 承载也可以实现不同的 QoS，用于一个用户在同时进行的不同业务。 LTE 系统中的承载 针对每一个 EPS 承载，由核心网分配 QoS 参数，包括QoS 类别标识（QoS Class Identifier，QCI）和分配和滞留优先级（Allocation and Retention Priority，ARP）。 QCI 参数描述了承载的 QoS 类别，每一种 QoS 类别都对应于一系列影响数据服务质量的具体系统参数，例如调度的加权、准入门限和排队门限，等等。 ARP 参数描述了承载的优先级，包括在资源受限的情况下是否允许建立承载，或者是否丢弃某个优先级较低的承载 另外还有保证数据速率（Guaranteed Bit Rate，GBR）和最大数据速率（Maximum Bit Rate，MBR），这两个参数用于具有保证速率属性的承载。而对于不具有保证速率属性的承载，使用参数最大总速率（Aggregated Maximum Bit Rate，AMBR）来限制一个终端的所有不具有保证速率属性的承载的最大总速率。 根据核心网确定的 QoS 参数，无线接入网负责执行无线承载部分的 QoS 管理，例如无线资源的调度策略和排队管理策略等。 RRC 协议可以执行一部分 QoS 管理的功能，主要包括：半持续资源调度的配置，以及通过配置终端上行逻辑信道的优先级，实现对一个终端内多个上行承载的速率控制。 ","date":"2019-06-21","objectID":"/lte_rrc/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#服务质量qos管理"},{"categories":["WirelessCommunication"],"content":" 核心网信令的直接传输除了 RRC 协议信息之外，RRC 消息还可以用于承载核心网的非接入层（NAS）信息。采用所定义的上行／下行 NAS 信息直接传输的 RRC 过程，可以通过隧道打包的方式，在终端用户和网络核心网之间传输 NAS 信息。 上行（NAS）信息的直接传输 下行（NAS）信息的直接传输 ","date":"2019-06-21","objectID":"/lte_rrc/:1:5","series":null,"tags":["LTE"],"title":"LTE 系列：RRC 层","uri":"/lte_rrc/#核心网信令的直接传输"},{"categories":["WirelessCommunication"],"content":" LTE MAC 层详解 ","date":"2019-06-10","objectID":"/lte_mac/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#"},{"categories":["WirelessCommunication"],"content":" 媒体接入控制（MAC）媒体接入控制（Medium Access Control，MAC）层接收来自上层的 RLC 层的逻辑信道，经过处理后，以传输信道的方式输出到下层的物理层。 MAC 层的主要功能包括： 逻辑信道向传输信道的映射与复用 根据不同优先级进行动态的资源调度 选择传输格式实现动态的速率自适应 混合自动重传（HybridAutomatic Repeat reQuest，HARQ）的纠错功能 ","date":"2019-06-10","objectID":"/lte_mac/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#媒体接入控制mac"},{"categories":["WirelessCommunication"],"content":" 逻辑信道逻辑信道根据所传输的信息的类型进行定义。LTE 定义的逻辑信道包括： 用于传输系统广播消息的广播控制信道（Broadcast Control CHannel，BCCH） 用于传输寻呼消息的寻呼控制信道（Paging Control CHannel，PCCH） 分别用于空闲状态和连接状态的终端传输控制信息的公用和专用控制信道（Common/ Dedicated Control CHannel，CCCH/DCCH） 用于传输用户数据信息的专用业务信道（Dedicated Traffic CHannel，DTCH） ","date":"2019-06-10","objectID":"/lte_mac/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#逻辑信道"},{"categories":["WirelessCommunication"],"content":" 传输信道传输信道根据信息传输的方式进行定义。传输信道以传输块为单位在发送时间间隔（Transmission Time Interval，TTI）所定义的时间长度内进行每一次的发送，LTE 中设计的 TTI 长度是 1ms。每个传输块都有定义的传输格式，它由网络的调度功能动态地确定，包括传输块大小、调制方式和多天线方案等。 LTE 定义的传输信道包括： 广播信道（Paging CHannel，PCH），采用固定的传输格式，用于传输广播控制信道； 上行共享信道／下行共享信道（Downlink/Uplink Shared CHannel，DL-SCH/UL-SCH），支持基于无线信道状态的实时调度、动态的速率自适应、HARQ 软合并和多天线空间复用的传输方式，是 LTE 进行上行和下行数据传输的主要的传输信道。 在 LTE 空中接口 MAC 层协议功能的处理过程中，逻辑信道向传输信道以及最终的物理信道的映射关系如下所示： 下行信道映射 上行信道映射 ","date":"2019-06-10","objectID":"/lte_mac/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#传输信道"},{"categories":["WirelessCommunication"],"content":" MAC 协议数据单元格式MAC 包头可以包含多个子包头，每个子包头对应于 MAC PDU 负荷部分的 1 个 MAC 控制单元、MAC SDU 或者填充比特字段。 MAC 协议数据单元 PDU 的格式 子包头的格式如图所示： MAC 层的子包头 R（Reserve）字段为保留字段，数值设为 0 E（Extension）字段指示本子包头后面是否还有其他的子包头，或者是包头部分已经结束，将要开始 MAC 控制单元或者 MAC SDU 的传输 LCID（Logical Channel ID）字段指示 MAC SDU 所属逻辑信道的标识、MAC 控制单元的类型或者是填充比特 F（Format）字段指示随后的 L 字段的长度，7 个比特或者 15 个比特 L（Length）字段指示与子包头相对应的 MAC SDU 或者 MAC 控制单元的字节长度 ","date":"2019-06-10","objectID":"/lte_mac/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#mac-协议数据单元格式"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#mac-层功能和-mac-控制单元"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#随机接入过程"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#冲突解决"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#数据的调度和传输"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#半持续调度"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#harq"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#上行缓存状态报告"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#功率余量报告"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#上行时间同步的保持"},{"categories":["WirelessCommunication"],"content":" MAC 层功能和 MAC 控制单元下面介绍 MAC 层的主要功能，以及在完成这些功能过程中所需要的 MAC 控制单元。 随机接入过程随机接入是由 MAC 层控制的一项功能，空闲状态的终端通过随机接入过程与网络建立连接。 首先建立执行控制功能的连接（即 RRC 连接），终端由空闲状态转变为连接状态$\\Longrightarrow$然后通过 RRC 控制功能建立数据通信的连接，开始进行数据的通信。(对于连接状态的终端，也可能因为长时间没有发送上行信号而失去上行同步，此时如果有数据需要进行发送，终端需要进行随机接入的过程，与基站重新建立上行同步。随机接入过程可以由终端发起，也可以由网络侧通过物理层下行控制信道（PDCCH）触发终端发起随机接入) 随机接入过程 在随机接入过程中，终端选择 1 个随机接入序列通过物理层随机接入信道（PRACH）进行发送（在网络侧触发的情况下，由触发消息指示终端所使用的随机接入序列）$\\Longrightarrow$基站检测到随机接入序列的信号后，在下行方向上发送随机接入响应，该消息指示了： 基站所检测到的随机接入序列的编号 发起随机接入的终端分配的上行资源位置 上行信号发送时间的调整量 冲突解决如果多个终端选择了相同的随机接入序列并且在相同的时间进行发送，那么多个终端可能针对随机接入响应的接收发生冲突，所以需要冲突解决的过程。 在收到随机接入响应的消息后，终端根据消息指示的内容进行上行信号的发送（又称为“消息 3”），对应于图中的步骤 3，该信号中可能包含终端的唯一标识。随后基站根据接收到的上行信息，向唯一标识所对应的成功接入的终端返回冲突解决消息，完成冲突解决的过程。 小区无线网络临时标识。 收到基站的随机接入响应消息后，终端发送上行消息（即消息 3）开始冲突解决的过程。对于连接状态的终端发起随机接入过程的情况，该消息中包含终端的唯一标识：小区无线网络临时标识（Cell-Radio Network Temporary Identifier，C-RNTI）。具体来说，“消息 3”中使用 MAC 控制单元来指示 C-RNTI 的信息。 C-RNTI 的 MAC 控制单元仅包含一个字段，即 16 比特 C-RNTI。 MAC 控制单元——C-RNTI 终端冲突解决标识。 在上行随机接入过程中，终端发送上行消息（即消息 3）开始冲突解决的过程，对于连接状态的终端发起随机接入的情况，“消息 3”中指示终端的唯一标识 C-RNTI，在随后的下行发送中，网络通过物理层下行控制信道（PDCCH）指示该 C-RNTI 即可完成冲突解决。在另一种情况下，对于空闲状态的终端发起随机接入过程的情况，网络在随机接入响应消息中向终端分配临时 RNTI，但是因为还存在可能发生冲突的情况，所以在随后的消息 3中终端不使用临时 RNTI，而是传输上行公用控制信道（CCCH）的 RRC 连接建立请求消息。与此相对应的，基站在随后的下行发送中通过终端冲突解决标识的 MAC 控制单元完成冲突解决的过程。成功地完成冲突解决之后，终端将使用网络分配的临时 RNTI作为 C-RNTI。 终端冲突解决标识的 MAC 控制单元仅包含一个字段：终端冲突解决标识，这个字段包含上行随机接入冲突解决过程中，终端在消息 3中发送的上行公用控制信道的服务数据单元（CCCH SDU）。 MAC 控制单元——终端冲突解决标识 数据的调度和传输数据的调度和传输是 MAC 层控制的另一项主要功能。 对于数据信息的传输，即传输信道中的上行／下行共享信道（DL/UL-SCH），可以根据无线信道状态将无线资源在用户间进行自适应的调度分配，实现系统资源的优化利用，同时满足各个用户的 QoS 要求。主要采用动态调度的方式，也支持半持续调度（Semi-Persistent Scheduling，SPS）的方式。 动态调度的情况下，根据无线信道状态和用户优先级等信息，基站按照长度等于 1ms 的 TTI 作为单位，在每个 1ms 对各个终端所使用的无线资源进行分配，并且选择合适的数据传输格式 半持续调度的情况下，基站一次性为终端分配较长时间的无线资源，可以节省进行资源调度的控制信息 半持续调度LTE 支持半持续（Semi-Persistent Scheduling，SPS）的调度方式。对于某些业务量不大而且比较规则的业务（例如 VoIP），一次性的对较长时间内的资源使用进行分配，而不需要在每次传输的时候都进行动态分配，通过这样的机制，节省了为终端进行资源调度的 PDCCH 控制信令的开销。 对于半持续调度，为了减小调度信令的开销，基站一次为终端分配一段时间内预先定义好的无线资源和相应的传输格式，主要参数是半持续调度的时间间隔。例如，根据 VoIP 业务的流量特点，设置半持续调度的时间间隔等于 20ms，为用户分配一段时间内间隔为 20ms、相同频域位置和大小的无线资源。 半持续调度 HARQMAC 层采用混合自动重传（Hybrid Automatic Repeat reQuest，HARQ）的数据纠错机制。设置多个并行的停——等机制的 HARQ 进程，每个进程独立地进行数据包的重传和合并。多个并行的进程保证数据包传输的工作效率，重传保证了数据包传输的正确性，同时合并的处理还可以提供额外的性能增益。 多个并行的 停——等 机制的 HARQ 进程 在下行的数据传输中，每个 HARQ 进程内部采用异步、自适应的机制。 异步指的是对于 1 个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间没有固定的定时关系。也就是说，对于需要重传的数据包，在满足与这个数据包上一次传输之间的时间间隔不小于规定的最小值（8ms）的条件的基础上，调度器可以灵活地选择进行重传的时间 自适应指的是在各次传输之间，调度器可以灵活地选择不同位置／大小的物理资源，以及不同的传输格式（包括调制方式和信道编码速率等） 与异步、自适应的 HARQ 机制相匹配，下行数据包的传输伴随有下行调度信令，调度信令中指示当前所传输的下行数据包的资源位置、传输格式和所对应的 ARQ 进程号码，用户终端通过检测下行调度信令，可以进行下行数据包的接收、重传数据包的合并以及数据解调的操作 对于上行数据的传输，每个 HARQ 进程内部采用同步的机制。与下行方向采用的异步机制不同，上行采用的同步机制指的是对于上行 HARQ 过程中一个数据包的多次传输（包括第一次的初传和随后可能的多次重传），各次传输之间采用固定的定时关系。 例如：在时刻 0 进行初传的数据包，如果出现接收错误需要进行重新传输，那么第一次重传将发生在时刻 8，如果仍然接收错误需要继续重传，那么第二次重传将发生在时刻 16，以此类推。根据这样的同步的定时关系，对于上行 HARQ 过程的数据重新传输，基站可以不对重传的数据包进行调度。此时，终端仅收到网络侧基站反馈的关于数据接收出错的消息，终端将根据固定的定时关系，在规定的时间采用与第一次传输相同的频率资源位置和传输格式进行重传，这种方式称为同步、非自适应的 HARQ 机制。 上行方向还可以支持同步、自适应的 HARQ 机制，网络侧基站反馈关于数据接收出错的消息的同时可以发送对于重传数据包的上行调度信息，该调度信息不改变重传数据包的传输时间，即仍然是同步的机制，但是可以调度不同位置和大小的频率资源，以及不同的传输格式，也就是说，实现自适应的 HARQ 机制。 上行缓存状态报告终端的上行发送是根据基站的调度进行的，因此，终端的缓存中等待进行发送的数据的数量是基站进行调度时需要的参考信息。 例如，如果终端的缓存中没有等待发送的数据，那么基站就不应该对该终端进行上行发送的调度。 终端通过发送缓存状态报告（Buffer Status Report，BSR），向服务基站报告终端的上行缓存中等待发送的数据的数量。根据 RRC 信令的配置，终端将上行逻辑信道进行分组，采用逻辑信道组（Logical Channel Group，LCG）为单位进行缓存状态的报告。 终端缓存状态报告的 MAC 控制单元包括两种格式——短格式／截断格式，或者长格式。 短格式进行 1 个逻辑信道组对应的缓存状态报告，相应的 MAC 控制单元由逻辑信道组标识（LCG ID）和缓存数据量大小组成 长格式进行 4 个逻辑信道组的缓存状态报告，发送的 4 个关于缓存大小的消息分别对应于编号 0 到编号 3 的 4 个逻辑信道组 MAC 控制单元——缓存状态报告 功率余量报告上行信号的发送受到终端最大发射功率的限制，所以基站在调度终端进行上行发送的时候需要参考终端发射功率的情况。 例如：如果终端处于小区边缘，已经接近最大发射功率的限制，在这种情况下，基站如果调度这个终端使用大量资源进行大数据量的上行发送，而终端由于最大发射功率的限制可能无法保证发射信号的质量，因而导致信息传输的错误。所以基站需要根据对终端发射功率情况的了解，避免出现这样的情况。 通过功率余量报告，终端向基站报告上行数据信道当前的发射功率距离终端上行最大发射功率之间的余量，该信息作为基站进行上行功率控制和上行资源调度的参考。功率余量报告的传输由 RRC 信令进行配置，包括周期性的方式或者传播损耗的变化超过设定的门限都可以触发功率余量消息的上报。 功率余量报告的 MAC 控制单元包括 2 个比特的预留字段和 6 个比特的功率余量（Power Headroom，PH）信息，指示从 −23dB 到 40dB 范围之内的数值。 MAC 控制单元——功率余量报告 上行时间同步的保持在下行方向上，终端通过检测基站的同步和导频信号，与基站","date":"2019-06-10","objectID":"/lte_mac/:1:4","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#不连续接收功能"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-10","objectID":"/lte_mac/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：MAC 层","uri":"/lte_mac/#参考"},{"categories":["WirelessCommunication"],"content":" LTE RLC 层详解 ","date":"2019-06-06","objectID":"/lte_rlc/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/#"},{"categories":["WirelessCommunication"],"content":" 无线链路控制（RLC）无线链路控制（Radio Link Control，RLC）层的主要功能是： 根据下层指示的数据包传输大小对来自上层的数据包进行连接、分段和重组 数据包的顺序传输和重复性检测 自动重传请求（Automatic Repeat Request，ARQ）的数据纠错 针对每一个无线承载配置一个 RLC 实体，经过 RLC 层协议功能的处理后，数据以逻辑信道的方式输出到下层的 MAC 层。根据所传输消息的不同特点，RLC 实体有 3 种工作模式： 透明模式（Transparent Mode，TM） 确认模式（Acknowledged Mode，AM） 非确认模式（Unacknowledged Mode，UM） ","date":"2019-06-06","objectID":"/lte_rlc/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/#无线链路控制rlc"},{"categories":["WirelessCommunication"],"content":" 透明模式（TM）此模式下，RLC 子层是完全透明的，不执行任何功能，例如不添加 RLC 包头、不进行数据分段或者连接，即来自上层的数据在 RLC 层不进行任何处理，“透明”地传输到下层的 MAC 层。透明模式用于广播、寻呼和公用控制信道等信息需要传输给多个用户的情况，相对应于广播、上下行公用控制和寻呼等逻辑信道。 TM 模式数据消息的 RLC PDU 格式 ","date":"2019-06-06","objectID":"/lte_rlc/:1:1","series":null,"tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/#透明模式tm"},{"categories":["WirelessCommunication"],"content":" 确认模式（AM）此模式用于提供高可靠性的数据传输服务，例如 TCP/IP 数据业务或者 RRC 控制信令的传输，包括承载上下行专用数据信息和专用控制信息的逻辑信道。 在此模式下，RLC 子层执行所有功能，包括： 数据包的连接、分段和重组 数据包的顺序传输和重复性检测 基于滑动窗进行错误数据包重新传输的 ARQ 纠错机制 AM 模式的 RLC PDU 由 RLC 包头和 RLC SDU 组成，RLC 包头包括 D/C，RF，P，FI， E 和 SN 字段。如果 RLC PDU 中包含多于 1 个数据字段，那么相对应的 RLC 包头还将包括 E 和 LI 字段，以分别对应于各个数据字段。 AM 模式数据消息的 RLC PDU 格式 以下是 RLC 包头各个字段的具体含义: D/C（Data/Control）字段：指示该 RLC PDU 是RLC 数据 PDU还是RLC 控制 PDU RF（Re-segmentation Flag）字段：指示该 RLC PDU 是一个 AM 模式``PDU，还是一个 AM 模式的 PDU 分段。因为，在 AM 模式的情况，数据包进行 ARQ 重传的时候，可能需要对初次传输时的 AM PDU 进行分段，因而形成 AM PDU 分段 P（Polling）字段指示是否要求接收端对等的 RLC 实体进行 1 次 RLC 状态的报告 FI（Framing Indicator）字段：指示 RLC PDU 的数据字段是否是 RLC SDU 的开始或者结尾部分。2 个比特的信息指示了是开始不是结尾、是结尾不是开始、既不是结尾也不是开始、既包含了结尾也包含了开始一共 4 种可能的状态 E（Extension）字段指示后面是否还有 E 和 LI 字段 SN（Sequence Number）字段：指示 RLC PDU 的序号，序号采用递增的方式。对于 AM 模式下重传的 AM PDU 或者 AM PDU 分段，采用初传的 AM PDU 所对应的序号 LI（Length Indicator）字段：指示对应的数据字段的字节长度 在 AM 模式下，RLC 层使用 ARQ 纠错机制对传输错误的数据包进行重传，由于下层指示的数据包传输大小可能与初次传输时候的情况有所不同，可能需要对初次传输的 AM PDU 进行分段，因此形成了AM PDU 分段的格式。与 AM PDU 相比较，AM PDU 分段在包头部分多了两个字段：LSF 和 SO。 AM 模式数据消息的 RLC PDU 分段的格式 LSF（Last Segment Flag）字段指示这个 AM PDU 分段是否是所对应的初次传输的 AM PDU 的最后一个分段。 SO（Segment Offset）字段指示这个 AM PDU 分段在所对应的初次传输的 AM PDU 中的位置，具体是这个 AM PDU 分段的第 1 个字节在所对应的初次传输的 AM PDU 中的字节位置。 除了 RLC 数据 PDU 之外，AM 模式下还可能传输 RLC 控制 PDU，进行 RLC 状态的报告。由数据接收方的 RLC 实体向数据发送方对等的 RLC 实体发送 RLC 状态 PDU，报告 AM PDU 数据包的接收状态，包括正确接收的数据包的最后序号，以及接收错误的数据包的序号。 RLC 状态 PDU CPT（Control PDU Type）字段指示该 RLC 控制 PDU 的类型 ACK_SN（Acknowledgement SN）字段指示接收正确的数据包的最后一个序列号，不包含 ACK_SN 本身所指示的数据包，以及由 NACK_SN 所指出的接收错误的数据包 E1（Extension bit 1）字段指示后面是否跟随有 NACK_SN，E1 和 E2 字段 NACK_SN（Negative Acknowledgement SN）字段指示接收错误或者部分出错的 AM PDU 数据包的序列号 E2（Extension bit 2）字段指示这个 NACK_SN 后面是否跟随有 SOstart 和 SOend 字段 SOstart 在 AM PDU 数据包部分出错的情况下，SOstart 字段指示出错部分的第一个字节在 AM PDU 数据包中的位置 SOend 在 AM PDU 数据包部分出错的情况下，SOend 字段指示出错部分的最后一个字节在 AM PDU 数据包中的位置 ","date":"2019-06-06","objectID":"/lte_rlc/:1:2","series":null,"tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/#确认模式am"},{"categories":["WirelessCommunication"],"content":" 非确认模式（UM）此模式与确认模式的区别是不进行错误数据包重传的 ARQ 纠错。UM 模式主要用于对数据传输正确性的要求不是很高的场景，例如广播信道或者 VoIP 业务，包括上下行专用数据逻辑信道和多媒体广播多播业务（Multimedia Broadcast Multicast Service，MBMS）专用的控制和数据逻辑信道。UM 模式 RLC 子层仍然执行数据包的连接、分段和重组，数据包的顺序传输和重复性检测的功能。 与 AM 模式相比较，UM 模式的 RLC PUD 少了 3 个字段：D/C、RF 和 P。因为 RLC 控制 PDU 只在 AM 模式进行传输，UM 模式仅传输 RLC 数据 PDU，因此不需要指示 RLC 控制或者 RLC 数据信息的 D/C 字段。UM 模式不进行 ARQ 纠错的重传，因此不会出现数据包重传需要重新分段的情况，所以不需要指示数据分段的 RF 字段。P 字段所指示的 RLC 状态报告也仅适用于 AM 模式，因此 UM 模式的情况下不需要这个字段。 UM 模式数据消息的 RLC PDU 格式 ","date":"2019-06-06","objectID":"/lte_rlc/:1:3","series":null,"tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/#非确认模式um"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-06","objectID":"/lte_rlc/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：RLC 层","uri":"/lte_rlc/#参考"},{"categories":["WirelessCommunication"],"content":" LTE PDCP 层详解 ","date":"2019-06-03","objectID":"/lte_pdcp/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：PDCP 层","uri":"/lte_pdcp/#"},{"categories":["WirelessCommunication"],"content":" 分组数据会聚协议（PDCP）分组数据会聚协议（Packet Data Convergence Protocol，PDCP）层的主要功能是进行 IP 数据包头压缩、数据加密和控制信令的完整性保护。 对于来自上层的数据包，将针对每一个无线承载建立一个 PDCP 实体。首先对数据包进行编号，然后根据配置对数据包进行 IP 包头压缩，数据加密和控制信令完整性保护的操作，形成 PDCP 服务数据单元（Service Data Unit，SDU），最后添加包含编号的 PDCP 包头，形成 PDCP 协议数据单元（Protocol Data Unit，PDU）作为 PDCP 子层协议功能的处理结果向下层 RLC 子层输出。 PDCP 协议数据单元格式 R 表示预留的字段，都填充为 0 D/C 字段指示控制面或者数据面的 PDCP 包，控制面为 0，数据面为 1 MAC-I 是控制信令完整性保护的字段，在不使用完整性保护功能的时候，都填充为 0 ","date":"2019-06-03","objectID":"/lte_pdcp/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：PDCP 层","uri":"/lte_pdcp/#分组数据会聚协议pdcp"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-06-03","objectID":"/lte_pdcp/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：PDCP 层","uri":"/lte_pdcp/#参考"},{"categories":["WirelessCommunication"],"content":" LTE PDCP 协议详解 ","date":"2019-05-26","objectID":"/upper_layer_protocol/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线接入网上层协议","uri":"/upper_layer_protocol/#"},{"categories":["WirelessCommunication"],"content":" 无线接入网由 E-NodeB 组成的无线接入网是系统与终端用户进行通信的接口，它的功能分为数据面和控制面两个部分： 数据面负责用户数据信息的传输 控制面负责系统控制功能以及相关信息的传输和处理 LTE 接入网协议架构 分组数据会聚协议（PDCP） 无线链路控制（RLC） 媒体接入控制（MAC） 无线资源控制（RRC） 无线接入网向核心网提供无线承载服务。 针对每一个用户可以建立 1 个或者多个的无线承载，来自核心网 S1 接口的 IP 数据包根据不同的服务质量要求（Quality of Service，QoS）可以映射在不同的无线承载上。然后，数据包将分别经过 PDCP$\\Longrightarrow$RLC$\\Longrightarrow$MAC 各层协议地处理： PDCP 层完成的功能包括 IP 数据包的头压缩、数据加密以及控制信令的完整性保护。 RLC 层主要进行自动重传请求（Automatic Repeat Request，ARQ）的功能。 MAC 层的主要功能包括动态资源调度、逻辑信道复用以及混合自动重传（Hybrid Automatic Repeat Request，HARQ）。 经过 MAC 层协议的处理后，形成 1 个或者多个传输信道。最终通过物理层的处理在无线信号上进行传输。 LTE 接入网协议功能和数据处理流程 控制面主要的控制功能包括： 无线接入网的无线资源管理（Radio Resource Control，RRC）。无线资源管理（RRC）的主要功能包括系统信息的广播、终端的移动性管理，以及信令和数据的连接控制。 来自核心网移动性管理实体（MME）的非接入层（NAS）消息的控制功能，包括 EPS 系统承载（Evolved Packet System，EPS）的管理，空闲状态终端的移动性处理和寻呼，终端鉴权以及安全性方面的控制。 ","date":"2019-05-26","objectID":"/upper_layer_protocol/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线接入网上层协议","uri":"/upper_layer_protocol/#无线接入网"},{"categories":["WirelessCommunication"],"content":" 参考 [1] LTE-Advanced 关键技术详解 ","date":"2019-05-26","objectID":"/upper_layer_protocol/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：无线接入网上层协议","uri":"/upper_layer_protocol/#参考"},{"categories":["WirelessCommunication"],"content":" LTE 系统总体架构分解 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:0:0","series":null,"tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/#"},{"categories":["WirelessCommunication"],"content":" 系统架构演进系统架构演进（又名 SAE，System Architecture Evolution）是 3GPP 所制定的 LTE 无线通信的核心网络标准。 SAE 是基于 GPRS 核心网的演进，其主要差别为： 简化架构 全 IP 网络（AIPN） 支持提供更高吞吐量和更低延迟的接入网 多个异构接入网络的互通，包括 E-UTRA（LTE 和 LTE 升级版的接入网），3GPP 已有系统（例如 GPRS 和 UMTS 的接入网 GERAN 和 UTRAN），也支持与非 3GPP 系统之间的互通（例如 WiMAX、CDMA2000 或 WIFI） SAE 是的传输使用全 IP 网络，从而支持系统的控制平面和用户平面的分离。 SAE 体系结构的主要组成部分是核心分组网演进（EPC，Evolved Packet Core )，也被称为 SAE 核心。EPC 作用与 GPRS 网络相似，包含移动性管理组件（MME），服务网关（S-GW）和 PDN 网关（PDN Gateway）等网元。 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:1:0","series":null,"tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/#系统架构演进"},{"categories":["WirelessCommunication"],"content":" 系统架构LTE 系统可以分为核心网和无线接入网两个部分，如下图所示： LTE 系统总体架构图 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:2:0","series":null,"tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/#系统架构"},{"categories":["WirelessCommunication"],"content":" 核心网核心网包括： 移动性管理实体（MME） 服务网关（S-GW） 分组数据网网关（P-GW） MME实体负责移动性管理相关的控制功能，包括： 对终端位置跟踪区域列表的管理 对处于空闲状态的终端发起寻呼 为终端选择接入的 P-GW 和 S-GW 漫游和鉴权功能 非接入层（Non-Access Stratum，NAS）信令功能 信令安全和接入层（Access Stratum，AS）的安全控制 接入网之间的移动性管理（包括接入网内切换时的 MME 选择，向 2G 或者 3G 的不同接入网切换时的 SGSN 选择） 网络承载管理的功能 服务网关（S-GW）负责数据承载的相关功能，包括： 数据包的路由和转发，E-NodeB 之间切换或者 E-NodeB 和 GSM/WCDMA/TD-SCDMA 系统的不同接入网之间切换时的数据锚点 上下行传输层数据包的优先级标识 运营商内部和运营商之间的终端计费 对用户通信进行合法侦听的功能 PDN 网关（P-GW）是核心网与外部因特网的接口，完成的主要功能包括 针对每个用户的数据包过滤 终端的 IP 地址分配 基于业务的计费功能 门控和速率强制功能 下行传输层数据包的优先级标识 进行合法侦听的功能 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:2:1","series":null,"tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/#核心网"},{"categories":["WirelessCommunication"],"content":" 无线接入网无线接入网是系统与移动用户终端进行通信的接口，LTE 无线接入网采用扁平的网络结构，仅包含一种网络节点，即 E-NodeB（LTE 基站）： E-NodeB 之间通过 X2 接口进行互连，E-NodeB 通过 S1 接口与核心网进行连接，分为 S1-MME 和 S1-U 接口分别与核心网的 MME 和 S-GW 设备进行连接。为了实现负荷分担和容灾备份的功能，E-NodeB 和 MME/S-GW 之间可以进行多对多的连接，即 1 个 MME/S-GW 可以和多个 E-NodeB 连接，1 个 E-NodeB 也可以和多个 MME/S-GW 连接。 E-NodeB 负责无线接入网部分的功能，主要包括：无线资源管理（包括无线承载控制、无线接入控制、连接的移动性控制、动态的资源调度），IP 头压缩和用户数据加密，为附着的终端选择进行控制功能的 MME 实体，将用户数据路由至 S-GW 服务网关，寻呼、广播和公共报警消息的调度与传输，以及配置用于终端移动性管理和数据调度的物理层信号测量和测量的上报。E-NodeB 之间通过 X2 接口进行互连，X2 接口主要用于支持终端在 E-NodeB 之间的切换，包括信令的交互以及切换过程中可能进行的数据转发，X2 接口还可以用于在小区之间交互无线资源管理的消息，实现小区间协调进行干扰抑制的功能。 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:2:2","series":null,"tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/#无线接入网"},{"categories":["WirelessCommunication"],"content":" 参考 [1] SAE [2] LTE-Advanced 关键技术详解 ","date":"2019-05-21","objectID":"/the_overall_architecture_of_the_lte_system/:3:0","series":null,"tags":["LTE"],"title":"LTE 系列：系统总体架构","uri":"/the_overall_architecture_of_the_lte_system/#参考"},{"categories":["VM"],"content":" 一行命令解决 Virtualbox 共享文件夹权限问题 ","date":"2018-10-10","objectID":"/virtualbox_file_share_issue/:0:0","series":null,"tags":["Q\u0026A","Linux"],"title":"Virtualbox 共享文件夹权限问题","uri":"/virtualbox_file_share_issue/#"},{"categories":["VM"],"content":" 功能使用 virtualbox 最方便的 host-guest 交换文件方案莫过于共享文件夹功能了。 比如 host 有个叫 git 的文件夹，可以直接将此文件夹设置为共享文件夹并自动 mount，这样，每次在虚拟机一开机就看到这个文件夹被挂载为/media/sf_git。 ","date":"2018-10-10","objectID":"/virtualbox_file_share_issue/:1:0","series":null,"tags":["Q\u0026A","Linux"],"title":"Virtualbox 共享文件夹权限问题","uri":"/virtualbox_file_share_issue/#功能"},{"categories":["VM"],"content":" 问题但是，在用非 root 用户方法这个文件夹时却会遇到权限不足问题。 原因在于自动 mount 的文件夹的所有者为 root，所属的组是 vboxsf，因此只有这两个用户有访问权限。 ","date":"2018-10-10","objectID":"/virtualbox_file_share_issue/:2:0","series":null,"tags":["Q\u0026A","Linux"],"title":"Virtualbox 共享文件夹权限问题","uri":"/virtualbox_file_share_issue/#问题"},{"categories":["VM"],"content":" 解决解决办法很简单，只需要将当前登录用户加入到 vboxsf 组就行了。 sudo usermod -aG vboxsf $(whoami) 重启一次系统组设置即生效。 ","date":"2018-10-10","objectID":"/virtualbox_file_share_issue/:3:0","series":null,"tags":["Q\u0026A","Linux"],"title":"Virtualbox 共享文件夹权限问题","uri":"/virtualbox_file_share_issue/#解决"},{"categories":["ChitChat"],"content":" 条形码以及二维码的过去与将来 说明 本文是最早以 TechKoala 的名字所写的文章，发布于电脑爱好者 2013 年第 06 期。说来当时以邮汇方式发的稿费至今没有收到，2333 面对我们随时可以看见的条形码，说出来你也许会不信，如果没有这个家伙，整个世界的经济都无法正常运行。这些黑白条码不但能让机场不弄丢你的行李，能对快件的包裹进行跟踪，而且还能在网上对各种信件进行查询。它们既可以用在食品包装上，也可以用在图书的扉页。这个时候看看手上的《电脑爱好者》杂志，你发现了吗？ ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:0","series":null,"tags":["QRCode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/#"},{"categories":["ChitChat"],"content":" 条形码的由来三十多年前的一天，一位名叫道森的购物者走进马什超市，购买了一包箭牌口香糖，扫扫条形码然后付钱。这在今天稀疏平常的事，当时却是标志性事件 — 由此，条形码迎来了它的里程碑，从此走到你我的眼前。 伍德蓝德 说到条形码，就不得不说它的发明者 —— 伍德蓝德。他出生于新泽西州，从小便对技术发明具有浓厚的兴趣，具备非凡的动手能力。他生长在二战前后，战争期间，他不得不中断学业，参与研发原子弹的曼哈顿工程，这个看似八竿子打不着边的事，却使他对发明愈发迷恋。二战之后，美国经济快速发展，规模宏大的超市面临着一个巨大的问题，他们无法精确掌握库存情况，唯一的办法是手工清理，但耗时又费力。于是他们向德雷赛尔大学求助，恰巧伍德蓝德得知，于是，伍德蓝德开始与自己的朋友苏沃一起研究这个解决方案。蓝德本来是出于商业目的，但随着研究的深入，这项工作彻底改变了他的人生。类似历史上的诸多发明，开始时，蓝德遇到了许多次失败，但他没有放弃。他毅然辍学全心投入，坚信成功不远，但总差那么一层窗户纸。后来，他去了迈阿密的住所放松，那里有优美的居住环境、安静的思考空间，他期待能有灵感迸发。 老天不负有心人。有一天，他在沙滩坐定，苦苦思索：“如何才能给每件物品分类呢？编号？对！莫尔斯电码？可是这样太复杂了，一般人也没办法分辨。” 想到此，他开始无聊地在沙滩上用手画沙子，一条一条，突然，一个神奇的图案出现在蓝德脑海 — 如果用粗细、间距不同的竖线构成图案，那就可以实现对商品编码。就这样，条码的原型在沙滩上诞生了。待到出现文章开头的一幕时，已经过去了三十多年，可喜的是，我们的主人公是一位有耐心的人。 ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:1","series":null,"tags":["QRCode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/#条形码的由来"},{"categories":["ChitChat"],"content":" 条形码的标准与应用与现在的条形码不同，蓝德发明的第一条条形码不是由线条构成，而是一组同心圆，通过照片扫描器读取。它形如箭靶，美国人称其为 “公牛眼”。遗憾的是，以美国当时的工艺和经济水平，他们还没有能力印制出这种编码。 公牛眼 后来，伍德蓝德加入了 IBM 公司，并把自己的专利卖给了 IBM。然而，伟大的成果却并非属于 IBM，几经转手，机遇来到了 RCA 公司。直到条形码大展宏图时，IBM 公司里的人才知道：“哦，原来发明条形码的人就在我们公司。” 我们目前所知的第一个商用条形码出现于 1966 年，但人们很快就意识到应该为其制定出一个行业标准。 两年后的夏天，应国家食物连锁协会要求，Logicon 公司开发出了食品工业统一码（UGPIC）。随后，美国统一编码协会建立了 UPC 码系统，并且实现了该码制的标准化。UPC 码首先在杂货零售业中试用，俄亥俄州的 Marsh 超级市场安装了由 NCR（IBM 公司的前身）制造的第一台 UPC 扫描器，而第一个被收银员扫描的便是文章开头所说的标价 69 美分的十片装箭牌口香糖。 直到现在，我们都不可否认的是，正是零售业的成功应用才促进了条形码技术的发展。 目前，全球每天大约要扫描 80 亿次条形码。而普华永道公司的一项研究报告表明，条形码每年仅在超市和大众零售领域就能为客户、零售商和制造商节约 300 亿美元的成本。令人感到遗憾的是，伍德兰德的朋友，条形码联合发明人苏沃并没有亲眼看到条形码的商业化应用，他在自己 38 岁的时候（1962 年）英年早逝。而伍德蓝德则在 1992 年被当时的美国总统布什授予了国家科技奖章。 令人遗憾的是，前不久，伍德蓝也不幸地告别了人世。据《纽约时代》报道，他于美国当地时间 2012 年 12 月 9 日在自己新泽西的家中逝世，享年 91 岁。蓝德的女儿苏珊评价父亲说：“他参与了整个系统的设计，从使用者的站立方式、激光扫描仪高度到如何保护人们的眼睛不受激光刺激，他是一个绝对的完美主义者。” ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:2","series":null,"tags":["QRCode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/#条形码的标准与应用"},{"categories":["ChitChat"],"content":" 条形码的未来今天，条形码已经占据我们生活的每个角落，从超市购买的食品到手中握住的杂志，我们依靠条形码管理我们的生活，条形码技术也在不断进步。 其实，如今风生水起的二维码也属于条形码，作为后起之秀，它比它的前辈更进一步。自从它出现以来，得到了人们的广泛关注，发展十分迅速。 二维条形码最早发明于日本，它是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的，在代码编制上巧妙地利用构成计算机内部逻辑基础的 “0”、“1” 比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图像输入设备或光电扫描设备自动识读以实现信息自动处理。它具有条形码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、处理图形旋转变化等特点。 一维条形码虽然提高了资料收集与资料处理的速度，但由于受到资料容量的限制，一维条形码仅能标识商品，而不能描述商品，因此相当依赖电脑网络和资料库。在没有资料库或不便连网的地方，一维条形码很难派上用场。此外一维条形码有一个明显的缺点，即垂直方向不携带资料，故资料密度偏低。当初这样设计有二个目的：（1）为了保证局部损坏的条形码仍可正确辨识；（2）使扫描容易完成。 要提高资料密度，又要在一个固定面积上印出所需资料，可用二种方法来解决：（1）在一维条形码的基础上向二维条形码方向扩展；（2）利用图像识别原理，采用新的几何形体和结构设计出二维条形码。前者发展出堆叠式（Stacked）二维条形码，后者则有矩阵式（Matrix）二维条形码之发展，构成现今二维条形码的两大类型： 引用 堆叠式二维条形码的编码原理是建立在一维条形码的基础上，将一维条形码的高度变窄，再依需要堆成多行，其在编码设计、检查原理、识读方式等方面都继承了一维条形码的特点，但由于行数增加，对行的辨别、解码算法及软件则与一维条形码有所不同。较具代表性的堆叠式二维条形码有 PDF417、Code16K、Supercode、Code49 等。 矩阵式二维条形码是以矩阵的形式组成，在矩阵相应元素位置上，用点的出现表示二进制的 “1”，不出现表示二进制的 “0”，点的排列组合确定了矩阵码所代表的意义。其中点可以是方点、圆点或其他形状的点。矩阵码是建立在电脑图像处理技术、组合编码原理等基础上的图形符号自动辨识的码制，已较不适合用 “条形码” 称之。具有代表性的矩阵式二维条形码有 Datamatrix、Maxicode、Vericode、Softstrip、Code1、Philips Dot Code 等。 二维条形码的新技术在 1980 年代晚期逐渐被重视，在 “资料储存量大”、“资讯随着产品走”、“可以传真影印”、“错误纠正能力高” 等特性下，二维条形码在 1990 年代初期已逐渐被使用。现在，几乎所有的社交软件都具备扫一扫的功能，对着抽象的图案一扫，迎来一个多彩的世界已经成为许多人的习惯。 马化腾在去年九月开幕的互联网大会的演讲中便说到：“从微信强化扫二维码的功能之后，我们希望把这个行为定义成更加普及，老百姓一看到码就去扫的概念。我们前几天还在网上看到一个新的名词，就是扫墓，看到墓碑有那个二维码，一扫描就看到这个墓碑的主人过去的生平介绍等等，这些都是非常典型的应用。” 或许，墓碑的例子有些夸张，但是，你不能否认，条形码越来越贴近我们的生活，不再只是局限于购物。也许未来，我们的一切都涵盖在那小小的方寸之间。 碰巧，时隔多年把这篇文章重新整理出来的时候，回形针正好发布了一期关于二维码的视频： 放在这里，作为补充。 ","date":"2013-03-15","objectID":"/brief_history_of_qrcode/:0:3","series":null,"tags":["QRCode"],"title":"改变世界的条形码","uri":"/brief_history_of_qrcode/#条形码的未来"},{"categories":["ChitChat"],"content":" Sybian 联盟 聊聊 Symbian 的过去 注意 这是一篇写于 2013 年的文章，文章的观点可能已经过时甚至错误，但时过境迁，仅表怀念。 毫不夸张的说，今天我们所拥有的一切，都是建立在它的肩膀上。无论多少人咒骂它的臃肿，嫌弃它的卡顿，都无法改变它作为手机智能操作系统鼻祖的地位。当山寨机还在襁褓中时，当伪智能还在浪费人们的时间时，作为先驱的它便已上路。大多数人接触的第一款真正的智能手机系统，它把软件下载，游戏安装，刷机破解等诸多名词第一次带到了大众视野。它叫 Symbian，也曾辉煌。三十年河东，三十年河西，科技领域本就没有常青树。虽然如今已经沦落，但不妨碍我们一起回味它曾经的辉煌。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:0","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#"},{"categories":["ChitChat"],"content":" 混沌之初，Symbian 伊始​ Symbian，源自一家充满梦想的公司。 1980 年，potter 在伦敦成立了 Psion 公司，这家以数字产品开发和研究为目的，为率先使用电子设备的大公司服务的小公司便是 Symbian 的生母。随着公司的发展，Psion 开始浸淫移动终端市场，他们生产的各类移动设备不仅皮实耐用还能按需求定制，凭借这种 “开放移动” 的理念，Psion 在上世纪 90 年代 成为了欧洲较成功的 PDA 生产商，进而促进了 EPOC 的诞生。在 potter 看来，EPOC 是一种面向普通大众的便携系统。正如他的全称“A new epoch of personal convenience.”（一个人人方便使用电子产品的新时代），他被 Psion 给予了对于人机交互未来的憧憬。 犹如一代闪电，EPOC 划开了混沌的天空，不过真正的风暴才刚来临。 1991 年到 1998 年，Psion 发布了几款给予 EPOC 16 的的设备，作为早期产品，免不了简陋无比，它们充其量只能算是 PDA 模块，只是方便了厂商研发新品。 真正让 EPOC 走向成熟的是一位叫做 Nicholas Myers 的程序设计师。1994 年，他在构思下一代 EPOC 时，设定了开发适应 21 世纪技术性能的系统的目标。正是这样的思路。让他把握住了市场脉搏。1997 年，他成为 Psion 旗下 Symbian 软件公司的 CEO，其上任后发布的 EPOC 32 操作系统，比起前辈，已有了翻天覆地的变化。吸引了人们以及投资者的兴趣。今天我们吧 Myers 成为 “Symbian 之父”。 EPOC 32 与 Windows 极为相似，它是一套 32 位的系统，支持多任务，拥有图形化美观的界面。鉴于当时几乎没有可以直接用于手机的操作系统，它的问世，一下子汇聚了厂商的目光。不过，任何一项新技术新产品的诞生都需要时间的推敲，智能手机系统作为新兴事物，没有哪家厂商敢冒险直接挺近。一番商榷之后，1998 年，爱立信、诺基亚、摩托罗拉和 Psion 共同成立了一家公司，目的是推进手机和 PDA 的智能化，它就是我们今天熟知的 Symbian。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:1","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#混沌之初symbian-伊始"},{"categories":["ChitChat"],"content":" 拉帮结派，飞速发展 联盟的成立不仅吸引了大量手机厂商，一些上有配件商，例如 ARM 和德州仪器都加入了合作计划。 Symbian 从一成立便秉持着开放的理念，任何组织和个人都能为其开发软件。但刚成立那几年，公司都未能推出一款真真意义上的产品，巨头们也只是作为附属项目在发展。直到 1999 年，Symbian OS v5 平台作为第一款成熟的产品被设计出来，为了争夺 “谁是世界上第一台智能手机”，爱立信没有经过完成的 DEBUG，就匆忙的把他推向市场，生产出 Erisson R380。同时期，摩托也推迟了自己的天拓 A6188。可实际上，两者中无论哪个都不能算严格意义上的智能手机，它们连软件都不能自由安装，真正算起来，搭载了 OS V5.1 的诺基亚 9210 才符合智能机最基本的定义，由此，诺基亚开始领先于其他厂商并保持到了最后。 众所周知，利益面前必有纠纷。诺基亚的崛起必然伴随了很多厂商的陨落，同时，它的存在也让联盟中其他有实力的厂商感到了危机，这为后来阵营的割分埋下了导火索。 Symbian 成立之初提出了著名的三分法：Pearl (珍珠）、Quartz (石英）和 Crystal（水晶）。分别对应手机的三大发展趋势：标砖键盘、触摸屏以及全键盘。诺基亚依靠 Pearl 迅速赢得了市场，逼迫索尼爱立信和摩托罗拉只能另寻他路 –Quartz。于是，联盟分为了两大派系，一是以诺基亚牵头的 S 系列平台，再者便是索尼爱立信主打 UIQ。诺基亚凭借标准键盘占据了大半江山，而后者则主攻触摸屏。这种同床异梦的现象愈演愈烈，直接导致了联盟崩溃的迫近。 当然，上述现象只是苗头，整个联盟正处于高速发展阶段。2002 年，微软的 WM 系统进入市场，这个原本被人们誉为 “Symbian 终结者” 的系统，却远没有它的大哥一般占据市场，反而被后者打的满地找牙。与此同时，诺基亚更是凭借 Pearl 进一步扩展帝国的领土，N70、N73、N95 的横空出世，为诺基亚扎实了自己的实力，待到 Symbian 王朝最鼎盛时，这个姓塞的家族占据了 72% 的智能手机市场，其中更是有九成乃至如日中天的诺基亚。直到现在，都没有哪一家厂商甚至哪一个操作系统打破这个纪录。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:2","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#拉帮结派飞速发展"},{"categories":["ChitChat"],"content":" 兄弟反目，联盟瓦解 正如上文所说，一家独大必然引发隐患。而事实证明那一天来了。2008 年，UIQ 宣布倒闭。究其原因，一方面是由于它自身定位与市场的极大反差，而另一方面便是来自于诺基亚的压力。相比 S60，开发者在这个平台上的收益远不及前者。应用程序的短缺自然局限了消费者的购买欲，如此一来，倒闭似乎只是时间问题了。诺基亚的持续壮大，扼杀了其他厂商的利润，长此以往，天平的过分了倾斜让别的厂商不得不退出 Symbian 的纷争。UIQ 的倒闭，标志着诺基亚对于 Symbian 掌控的最大化，后者从此只有一个主人了。 联盟名存实亡，但诺基亚为了避嫌，标榜着 “开放” 而成立了 Symbian 基金会，继续推向面向所有开发者开放的原则，明则共享资源，暗则染指一统智能市场。不幸的是，这是 iPhone 和 Android 问世了。后来的结果，各位看官一定也都清楚。诺基亚的美梦做早了，自大的它快走到了末路。 多年以后，关于那个一统江湖的传说，早已沦为笑谈罢了。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:3","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#兄弟反目联盟瓦解"},{"categories":["ChitChat"],"content":" 成也 Symbian，败也 Symbian 船大难掉头。巨头对于市场末端的变化总是慢半拍。身处多年王位的诺基亚早已麻痹了大意。UIQ 的倒闭，让其认为触摸屏不被市场接受，继续推进 S60 这个老迈的系统被诺基亚看做唯一路线。iPhone 的面市彻底颠覆了人们对于智能手机的认识，一度让人们认为 iPhone 重新定义了智能手机。市场的反应也确实印证了这一点，我们的双手确实是最适合操作的工具。但固守己见的诺基亚貌似看不到这一变化，迟迟不肯跳出键盘的定式思维。虽然后来确实推出了几款诸如 5800 这样销量很不错的触屏手机，当一切来的太晚，苹果做大了，随后的绿皮机器人也成熟了，Symbian 王朝彻底步入了晚年。 失去市场号召力的诺基亚此时的地位一落千丈，对于 Symbian 的态度也是一日三变。曾一度把源代码挂在网站上任人下载，随后又宣布只面向企业用户开源。这时的诺基亚真的急了。不愿投奔机器人阵营沦落为硬件制作商的他，竟甘心跪倒在昔日手下败将的裙下。2011 年 12 月，Symbian Belle 正式更名为诺基亚 Belle。诺基亚连名字都不行再见的 Symbian 从此已经不复存在。 然而，这并不意味着 Symbian 彻底的灭亡。名字虽然没有了，但产品依旧没有改变，与其说它灭亡不如说它失去了原来那般强大的市场号召力。毕竟，凭借 S40 在低端市场的畅销，诺基亚还能在手机市场分的一杯羹。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:4","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#成也-symbian败也-symbian"},{"categories":["ChitChat"],"content":" 未来？未来！ 向微软投怀送抱之后，诺基亚在 Symbian 的建树彻底才枯思竭。以至于不得不推出 808 这样依靠单一买点为噱头吸引市场关注的 “帐篷手机”。Symbian 的今生今世已经无话可说。而未来又在何方？原本打算有所期盼的笔者，本来打算对它的未来有所展望和揣测，不幸的是，本文截稿前的 1 月 24 日，诺基亚公布了 2012 年第四季度最新的财政业绩报告显示，该季度诺基亚实现净利润 2.02 亿欧元，告别 6 连亏，但同时诺基亚官方宣称去年在巴塞罗那发布的 808PureView 将会是最后一款塞班手机，这也意味着塞班这一已经被使用了 15 年之久的智能手机操作系统终于将告别市场，而诺基亚在智能手机领域也终于百分之百微软化。 诺基亚 CEO 斯蒂芬・埃洛普表示：“2012 财年上半年相对艰难，但第四财季表现强劲，设备和服务部门的运营利润率得到了改善。我们将继续执行既定的转移战略，包括继续提升产品竞争力，加速运营，管理成本等。” 因此，至少在看得见的未来，Symbian 已经没有了未来！ ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:5","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#未来未来"},{"categories":["ChitChat"],"content":" 末了 无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。 信息 P.S. 谨以此文献给那些成长路上的人和事，Symbian 没了，坛子没有了，但我们都还在。这些有关我们青春的事逝去也就随他去了。 ","date":"2013-01-16","objectID":"/brief_history_of_symbian/:0:6","series":null,"tags":["Symbian"],"title":"Symbian 的前世今生","uri":"/brief_history_of_symbian/#末了"},{"categories":["ChitChat"],"content":" Symbian、黑莓、苹果、微软、Android 五大手机系统，谁先会被淘汰？ ","date":"2010-04-12","objectID":"/mobile_phone_systems/:0:0","series":null,"tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/#"},{"categories":["ChitChat"],"content":" BlackBerry 这是一个很难预测的问题，先从黑莓说起吧，黑莓的成功是–针对高级白领和企业人士，提供企业移动办公的一体化解决方案，它让手机邮件发送变的更简单，所以它得到了众多商务人士及企业的青睐，但它在娱乐互联网上缺乏吸引力，一旦其它竞争对手加强在移动办公上的投入及创新，那么黑莓的优势将不复存在（最新的苹果系统 iOS4 已经加强了在企业方面的应用）。虽然它现在份额依然是世界第二、美国第一，但它依然会是第一个被淘汰的。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:1:0","series":null,"tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/#blackberry"},{"categories":["ChitChat"],"content":" Symbian Symbian 是因为诺基亚而存在的系统，它的兼容性是最差的，实用复杂，速度慢（尤其是上网速度）所以不被看好，之所以它一直以来是世界最大的智能手机系统，那是因为诺基亚的金子招牌在支撑着，除了诺基亚之外的 Symbian 手机（三星、索爱）一直以来销量都不理想。缺乏创新，所以它是第二个被淘汰的系统。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:2:0","series":null,"tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/#symbian"},{"categories":["ChitChat"],"content":" Android Android 速度最快的系统，被大家都看好，但它不可能成为第二个苹果，因为它的软件开发平台是开源的，导致了不同版本的出现，中国移动就是最好的例子，现在中国移动自主系统的手机想升级到 Android 最新版本是很困难的，加上品牌、型号不一样，硬件配置及屏幕尺寸不同，导致了同一个游戏在不同品牌及型号之间有着不同的表现，而苹果可以让一个游戏在四代上都是最佳体显（这样可以让软件的开发者利益最大化，而不需要为不同型号手机做出修改），Android 不会被淘汰，也许它会成为世界最大手机系统，但它将会沦为大众系统，我相信不久它将成为山寨手机进军低端智能市场的利器… 最后才是苹果与微软在中高端市场上的巅峰对决… ","date":"2010-04-12","objectID":"/mobile_phone_systems/:3:0","series":null,"tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/#android"},{"categories":["ChitChat"],"content":" Microsoft 虽然现在微软的 PPC 已经被淘汰，但它的 WP7 即将上线，一个替代 PPC 的时代即将到来，从最近放出的 WP7 资料来看，它是非常强大的，拥有众多新功能，凭着微软在 PC 市场上的垄断地位，加上它与 PC 之间的强兼容性，相信它前景广阔。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:4:0","series":null,"tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/#microsoft"},{"categories":["ChitChat"],"content":" Apple 苹果是一个传奇，能让一款手机买到第三年而依然拥有强大的市场竞争力，不得不说这是一个奇迹，历史上可能只有摩托罗拉的 V998 可以与之相比了，但苹果还在续写传奇，第四代已经出来了，苹果开创了一个手机的新时代，三年了，没有一个对手可以打败它，超越它，它引领着手机一次次的潮流，一次次的把手机用户体验推向一个新的水准，拥有 22 万多个应用商店、加上音乐商店，图书商店，它再一次的把资源整合到了极致，把苹果所有的娱乐产品连成了一个整体，这是其它对手所没有的优势，所以苹果会一直传奇下去… 注意 本文写于 2010 年，时过境迁，有些事情似乎沿着上文预言发展，有些却不然。正如前文《Symbian 的前世今生》中所言：无论多么强大的文明都有覆灭的一天，帝国如是，企业如是。在暗潮汹涌的科技领域，公司不能推出迎合市场口味，顺应市场变化的产品，迎来的就只有倒闭。在创新与颠覆这条路上，Symbian 不是第一个倒下的，也不会是最后一个。 ","date":"2010-04-12","objectID":"/mobile_phone_systems/:5:0","series":null,"tags":["System"],"title":"五大移动端系统谁先被淘汰？","uri":"/mobile_phone_systems/#apple"}]