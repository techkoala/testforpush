<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Linux - 标签 - TechKoala - Input/Output</title>
        <link>https://www.techkoala.net/tags/linux/</link>
        <description>Linux - 标签 - TechKoala - Input/Output</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>admin@techkoala.net (TechKoala)</managingEditor>
            <webMaster>admin@techkoala.net (TechKoala)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 11 Oct 2024 23:45:31 &#43;0800</lastBuildDate><atom:link href="https://www.techkoala.net/tags/linux/" rel="self" type="application/rss+xml" /><item>
    <title>服务器基础设置</title>
    <link>https://www.techkoala.net/server_setup_basics/</link>
    <pubDate>Fri, 11 Oct 2024 23:45:31 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/server_setup_basics/</guid>
    <description><![CDATA[<blockquote>
<p>翻译一篇服务器基本配置的好文章</p>
</blockquote>
<blockquote>
<p>这是我一直想写的一篇文章。虽然说明如何设置自托管应用程序很简单，但在薄弱的基础上托管应用程序毫无意义。在每篇教程的开头都介绍服务器设置是一件非常麻烦的事，所以我也为自己写了这篇文章，作为我如何为自己托管的应用程序设置服务器的参考。我会从基本的东西开始，比如使用 SSH 正确登录、非根用户设置以及为每个应用程序创建用户。我还会介绍 NGINX 设置、一些让服务器管理更轻松的生活质量工具、日志管理和基本网络安全。</p>
</blockquote>
<h2 id="ssh" class="headerLink">
    <a href="#ssh" class="header-mark"></a>SSH</h2><p>首先是登录。您需要一种安全访问设备的方法。不要使用用户名和密码。你需要使用 SSH（安全外壳），并确保 SSH 是唯一的登录方式。为此，你需要一个 SSH 密钥和一个新的用户账户。在新配置的 VPS 上，你将以根用户身份登录，你需要保护根用户账户。首先在 VPS 或远程机器上创建一个新的普通用户，并将其添加到 &ldquo;sudo &ldquo;组：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo adduser techkoala
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo usermod -aG sudo techkoala
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在本地电脑是执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ssh-keygen -t ed25519 -C <span class="s2">&#34;your_email@example.com&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照说明操作，它会问你想把文件保存在哪里，以及是否需要密码。请确保设置了字符串密码。要将公钥复制到服务器上，请在本地计算机上运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ssh-copy-id -i ~/.ssh/id_ed25519.pub newuser@your_server_ip
</span></span></code></pre></td></tr></table>
</div>
</div><p>请记住，newuser@your-server-ip 是用户名，也是你要将公钥复制到的远程设备。提示输入密码时，输入的是远程设备上的账户密码，而不是你刚刚为 SSH 密钥设置的密码。一旦验证通过，它就会复制公钥，现在你就可以通过 SSH 登录了。要关闭用户名和密码登录，请键入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo vim /etc/ssh/sshd_config
</span></span></code></pre></td></tr></table>
</div>
</div><p>找到下列值，并按你在这里看到的进行设置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Port <span class="m">2222</span>     <span class="c1"># Change default port (use a number between 1024 and 65535)</span>
</span></span><span class="line"><span class="cl">PermitRootLogin no                 <span class="c1"># Disable root login</span>
</span></span><span class="line"><span class="cl">PasswordAuthentication no          <span class="c1"># Disable password authentication</span>
</span></span><span class="line"><span class="cl">PubkeyAuthentication yes           <span class="c1"># Enable public key authentication</span>
</span></span><span class="line"><span class="cl">AuthorizedKeysFile .ssh/authorized_keys <span class="c1"># Specify authorized_keys file location</span>
</span></span><span class="line"><span class="cl">AllowUsers newuser                 <span class="c1"># Only allow specific users to login</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这将禁止除 SSH 之外的所有登录方式，只能通过你复制了公钥的用户登录。停止以 Root 身份登录，只允许你指定的用户登录。点击 CTL+S 保存，点击 CTL+x 退出文件编辑器。重启 SSH：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo systemctl restart ssh
</span></span></code></pre></td></tr></table>
</div>
</div><p>这可能会导致你退出 SSH 会话。如果出现这种情况，这时可以测试其他登录方法，看看是否被拒绝，然后再继续。此外，不言而喻，你需要妥善保管私钥，一旦丢失，你将无法再远程登录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Protocol <span class="m">2</span>                 <span class="c1"># Use only SSH protocol version 2</span>
</span></span><span class="line"><span class="cl">MaxAuthTries <span class="m">3</span>             <span class="c1"># Limit authentication attempts</span>
</span></span><span class="line"><span class="cl">ClientAliveInterval <span class="m">300</span>    <span class="c1"># Client alive interval in seconds</span>
</span></span><span class="line"><span class="cl">ClientAliveCountMax <span class="m">2</span>      <span class="c1"># Maximum client alive count</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在，让我们再深入研究一下用户，看看如何利用他们来提高组织性和安全性。</p>
<h2 id="users" class="headerLink">
    <a href="#users" class="header-mark"></a>Users</h2><p>在管理 Linux 服务器时，用户非常重要。服务器管理中有一个理念叫做 &ldquo;最小权限原则&rdquo;，其基本意思是，你要给予应用程序或进程完成工作所需的最小权限。Root 拥有无限的权限，没有应用程序真正需要它。为正在运行的应用程序设置用户权限有几个好处。如果正在运行的应用程序受到威胁，它可以限制潜在的损害。当运行多个应用程序时，它可以增加隔离性，有助于审计，让你知道哪些应用程序正在使用哪些系统资源。</p>
<p>简而言之，用户是组织系统的好帮手，在出现问题时能帮助你排除故障。要添加新用户，请运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo useradd -rms /usr/sbin/nologin -c <span class="s2">&#34;a comment&#34;</span> youruser
</span></span></code></pre></td></tr></table>
</div>
</div><p>该命令将创建一个用户，并为其提供一个存放应用程序数据的主目录，但不允许以该用户身份登录。-c标志是可选的，但最好能知道用户的用途，如 &ldquo;运行 Nextcloud &ldquo;之类。将应用程序文件克隆到 /opt 目录中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo mkdir /opt/myapp
</span></span></code></pre></td></tr></table>
</div>
</div><p>该命令会创建一个用户，并为其提供一个存放应用程序数据的主目录，但不允许以该用户身份登录。-c标志是可选的，但最好能知道用户的用途，如 &ldquo;运行 Nextcloud &ldquo;之类。将应用程序文件克隆到 /opt 目录中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo chown appuser:appuser /opt/myapp
</span></span></code></pre></td></tr></table>
</div>
</div><p>好了，这样就锁定了你的登录，你也应该对如何使用用户有了一定的了解。接下来是日志。</p>
<h2 id="logs" class="headerLink">
    <a href="#logs" class="header-mark"></a><strong>Logs</strong></h2><p>日志对系统管理至关重要。它们可以跟踪系统健康状况，帮助排除故障和检测威胁。因此，你需要设置适当的日志轮换，这样日志就不会占用系统太多空间，而且更易于阅读和管理。要设置正确的日志轮换，需要编辑位于 /etc 目录下的 logrotate.conf 文件。单个应用程序的配置通常存储在 /etc/logrotate.d/，因此 NGINX 的配置示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">/var/log/nginx/*.log <span class="o">{</span>
</span></span><span class="line"><span class="cl">    weekly
</span></span><span class="line"><span class="cl">    missingok
</span></span><span class="line"><span class="cl">    rotate <span class="m">52</span>
</span></span><span class="line"><span class="cl">    compress
</span></span><span class="line"><span class="cl">    delaycompress
</span></span><span class="line"><span class="cl">    notifempty
</span></span><span class="line"><span class="cl">    create <span class="m">0640</span> www-data adm
</span></span><span class="line"><span class="cl">    sharedscripts
</span></span><span class="line"><span class="cl">    postrotate
</span></span><span class="line"><span class="cl">        <span class="o">[</span> -f /var/run/nginx.pid <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">kill</span> -USR1 <span class="sb">`</span>cat /var/run/nginx.pid<span class="sb">`</span>
</span></span><span class="line"><span class="cl">    endscript
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该配置每周轮换日志，保留 52 周的日志，压缩旧日志，以正确的权限创建新日志，然后在轮换后向 NGINX 发出信号以重新打开日志文件。您可以使用以下配置进行测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo logrotate -d /etc/logrotate.conf
</span></span></code></pre></td></tr></table>
</div>
</div><p>这将显示它在不实际旋转日志的情况下会做什么。有了这些设置，你就可以开始做更高级的事情了，比如根据日志条目触发警报。现在，这对单台服务器来说还算不错，但如果你管理的服务器不止一台，最好还是了解一下 Grafana Loki、Graylog 和 Fluentd 等工具。在此我就不详细介绍了，但如果你想提高你的日志游戏水平，这些都是不错的起点。</p>
<h2 id="backups" class="headerLink">
    <a href="#backups" class="header-mark"></a><strong>Backups</strong></h2><p>备份，更重要的是测试备份，在服务器管理中极其重要。请记住：除非经过测试，否则备份就不是备份。未经测试的备份基本上是无用的。</p>
<p>备份主要有三种类型。完全备份、差异备份和增量备份。完全备份是磁盘上所有数据的完整副本。这种备份占用资源最多，但最容易恢复。差异备份备份的是上次完整备份后的所有变化，这是一种在空间和恢复速度上都处于中间位置的备份策略。增量备份备份自上次备份后发生变化的数据，这是最快的备份方式，但恢复起来可能最复杂。</p>
<p>我是这样想的。我使用增量备份来备份照片、文档或项目文件和经常编辑的文件夹。我会使用完全备份来备份整个服务器或磁盘。差异备份用于备份完整文件夹，如 /etc、/opt 和日志文件夹。</p>
<p>现在该如何存储呢？如果您遵循 3-2-1 原则，您就会如虎添翼。3 份数据副本、2 种存储类型和 1 个异地备份。我想说的是，如果这看起来太多，那么 &ldquo;异地 &ldquo;存储是最重要的，不能省略。万一发生灾难性的数据崩溃，拥有一个带有备份的硬盘是非常宝贵的。异地/离线备份还能让您免受勒索软件的威胁。因此，请牢记这一点。现在有大量的备份软件。我使用 Sync-thing、Borg 备份和老式 FTP 的组合。</p>
<p>请记住，备份、日志和服务器监控是一个根据您的需求不断发展的过程。您实施的具体策略应符合您的需求和数据的关键性。</p>
<h2 id="basic-network-safety" class="headerLink">
    <a href="#basic-network-safety" class="header-mark"></a><strong>Basic Network Safety</strong></h2><p>保护服务器安全的下一步是锁定那些不需要暴露在互联网上的端口，并禁止那些在不应该登录的情况下尝试登录的东西。UFW 和 Fail2Ban 是目前广泛使用的两种工具。它们简单易用，UFW 可让你为端口设置流量规则，而 Fail2Ban 则会在 IP 地址进入不应进入的端口或在某些预定义规则后仍无法登录时将其封禁。UFW 或不复杂的防火墙通常会预装在许多 VPS 服务中，Fail2Ban 也是如此，但如果你使用的是新机器且不确定，请运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt install ufw
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo apt install fail2ban
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="ufw" class="headerLink">
    <a href="#ufw" class="header-mark"></a><strong>UFW</strong></h3><p>关于 Fail2Ban，我们稍后再讨论，现在让我们重点讨论 UFW 设置。首先运行一些默认策略：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo ufw default deny incoming
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">sudo ufw allow outgoing
</span></span></code></pre></td></tr></table>
</div>
</div><p>这被认为是最佳做法，因为它遵循了我前面提到的 &ldquo;最少权限 &ldquo;理念。它减少了机器的攻击面，让你可以精确控制暴露的内容。简而言之，这种配置在安全性和功能性之间取得了平衡。你的服务器可以根据需要接入互联网，但外部实体只能通过你明确允许的方式连接到你的服务器。现在，让我们允许一些东西进入。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo ufw allow ssh
</span></span><span class="line"><span class="cl">sudo ufw allow <span class="m">80</span>
</span></span><span class="line"><span class="cl">sudo ufw allow <span class="m">443</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果要运行网络服务器，则需要打开 80 端口和 443 端口。80 端口用于 HTTP，443 端口用于 HTTPS。默认情况下，22 端口是 SSH，如果更改了端口，则需要指定端口，而不是使用 &ldquo;allow ssh &ldquo;命令。下面是其他一些有用的命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1">#List rules with numbers:</span>
</span></span><span class="line"><span class="cl">sudo ufw status numbered
</span></span><span class="line"><span class="cl"><span class="c1">#Delete by number:</span>
</span></span><span class="line"><span class="cl">sudo ufw delete NUMBER
</span></span><span class="line"><span class="cl"><span class="c1">#Delete by rule specification:</span>
</span></span><span class="line"><span class="cl">sudo ufw delete allow <span class="m">80</span>
</span></span><span class="line"><span class="cl"><span class="c1">#You can allow connections from specific IP addresses:</span>
</span></span><span class="line"><span class="cl">sudo ufw allow from 192.168.1.100
</span></span><span class="line"><span class="cl"><span class="c1">#You can also only allow an IP to connect to a specfic port with: </span>
</span></span><span class="line"><span class="cl">sudo ufw allow from 192.168.1.100 to any port <span class="m">22</span>
</span></span><span class="line"><span class="cl"><span class="c1">#If you neeed to allow a range of ports: </span>
</span></span><span class="line"><span class="cl">sudo ufw allow 6000:6007/tcp
</span></span><span class="line"><span class="cl"><span class="c1">#To further protect from brut force attacks you can rate limit specific ports with: </span>
</span></span><span class="line"><span class="cl">sudo ufw limit ssh
</span></span><span class="line"><span class="cl"><span class="c1">#This would limit port 22 to 6 connections in 30 seconds from a single IP. To see the status of the firewall you can use: </span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#Adding this goves you more info</span>
</span></span><span class="line"><span class="cl">sudo ufw status verbose
</span></span><span class="line"><span class="cl"><span class="c1">#and to reset incase you need to start over: </span>
</span></span><span class="line"><span class="cl">sudo ufw reset
</span></span><span class="line"><span class="cl"><span class="c1">#and to enable and disable: </span>
</span></span><span class="line"><span class="cl">sudo ufw <span class="nb">enable</span> 
</span></span><span class="line"><span class="cl">sudo ufw disable 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">#finaly to enable logging and adjusting the log level: </span>
</span></span><span class="line"><span class="cl">sudo ufw logging on
</span></span><span class="line"><span class="cl">sudo ufw logging medium <span class="c1"># levels are low, medium, high, full </span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在开始 Fail2Ban。</p>
<h3 id="fail2ban" class="headerLink">
    <a href="#fail2ban" class="header-mark"></a><strong>Fail2Ban</strong></h3><p>主要配置文件位于 /etc/fail2ban/jail.conf，但建议创建本地配置文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo nano /etc/fail2ban/jail.local
</span></span></code></pre></td></tr></table>
</div>
</div><p>jail.local 部分的[DEFAULT]部分有一些基本设置，它们是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">bantime</span> <span class="o">=</span> 10m
</span></span><span class="line"><span class="cl"><span class="nv">findtime</span> <span class="o">=</span> 10m
</span></span><span class="line"><span class="cl"><span class="nv">maxretry</span> <span class="o">=</span> <span class="m">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>封禁时间是指 IP 被封禁的时间。查找时间是 Fail2Ban 寻找重复失败的时间范围，最大重试次数是 IP 被禁用前的失败次数。您可以根据需要调整这些参数。您还可以设置自定义封禁，Fail2Ban 也支持 SSH 等常用服务的封禁。您还可以采取更多步骤，但我认为这已经涵盖了基本内容。</p>
<h3 id="nginx" class="headerLink">
    <a href="#nginx" class="header-mark"></a><strong>NGINX</strong></h3><p>您可以使用的网络服务器有很多。Apache, Caddy, nginx, IIS 等等。我使用 Nginx。这是我所熟悉的，而且它运行得非常好。Nginx（发音为 engine-x）是一个网络服务器、反向代理和负载平衡器。作为 Web 服务器，它擅长提供静态内容，并能以相当低的资源占用率处理大量并发连接。作为反向代理，它可以位于应用程序服务器之前，将流量转发给它们，同时确保应用程序的安全。它的负载平衡功能可有效平衡服务器之间的流量，提高可靠性和可扩展性。</p>
<p>通过 apt 安装时，nginx 的默认位置是 /etc/nginx/，nginx.conf 主要用于全局服务器配置，包括 /etc/nginx/sites-enabled 文件夹中的文件。这种模块化结构便于管理多个站点。需要注意的两个文件夹是 sites-enabled 文件夹和 sites-available 文件夹。您可以将可用站点视为测试站点配置的暂存区，而启用站点则用于实时站点和应用程序。常见的做法是在可用站点中的站点中设置和测试配置，然后当你准备上线并获得 SSL 证书时，将文件链接到启用站点文件夹。具体方法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ln -s /etc/nginx/sites-available/yoursitefile /etc/nginx/sites-enabled
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后重新加载nginx，并再次检查nginx状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo systemctl reload nginx
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">sudo systemctl status nginx
</span></span></code></pre></td></tr></table>
</div>
</div><p>您的网站现在应该已经上线。</p>
<p>下面，我将向您展示一些模板化的 Nginx 网站配置。请务必考虑您的应用程序或网站需求，因为这些只是起点。对于静态网站，这是一个不错的起点。</p>
<p>基本静态网站配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">server <span class="o">{</span>
</span></span><span class="line"><span class="cl">    listen 80<span class="p">;</span>
</span></span><span class="line"><span class="cl">    listen <span class="o">[</span>::<span class="o">]</span>:80<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server_name example.com www.example.com<span class="p">;</span>
</span></span><span class="line"><span class="cl">    root /var/www/example.com/html<span class="p">;</span>
</span></span><span class="line"><span class="cl">    index index.html index.htm<span class="p">;</span>
</span></span><span class="line"><span class="cl">    location / <span class="o">{</span>
</span></span><span class="line"><span class="cl">        try_files <span class="nv">$uri</span> <span class="nv">$uri</span>/ <span class="o">=</span>404<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Security headers</span>
</span></span><span class="line"><span class="cl">    add_header X-Frame-Options <span class="s2">&#34;SAMEORIGIN&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header X-XSS-Protection <span class="s2">&#34;1; mode=block&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header X-Content-Type-Options <span class="s2">&#34;nosniff&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header Referrer-Policy <span class="s2">&#34;no-referrer-when-downgrade&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header Content-Security-Policy <span class="s2">&#34;default-src &#39;self&#39; http: https: data: blob: &#39;unsafe-inline&#39;&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Logging</span>
</span></span><span class="line"><span class="cl">    access_log /var/log/nginx/example.com.access.log<span class="p">;</span>
</span></span><span class="line"><span class="cl">    error_log /var/log/nginx/example.com.error.log warn<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># SSL configuration (uncomment after running Certbot)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># listen 443 ssl http2;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># listen [::]:443 ssl http2;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_protocols TLSv1.2 TLSv1.3;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_prefer_server_ciphers on;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Certbot will add its own SSL certificate paths</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>代理通行证配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">server <span class="o">{</span>
</span></span><span class="line"><span class="cl">    listen 80<span class="p">;</span>
</span></span><span class="line"><span class="cl">    listen <span class="o">[</span>::<span class="o">]</span>:80<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server_name app.example.com<span class="p">;</span>
</span></span><span class="line"><span class="cl">    location / <span class="o">{</span>
</span></span><span class="line"><span class="cl">        proxy_pass http://localhost:3000<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header Host <span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header X-Real-IP <span class="nv">$remote_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header X-Forwarded-For <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header X-Forwarded-Proto <span class="nv">$scheme</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Security headers</span>
</span></span><span class="line"><span class="cl">    add_header X-Frame-Options <span class="s2">&#34;SAMEORIGIN&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header X-XSS-Protection <span class="s2">&#34;1; mode=block&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header X-Content-Type-Options <span class="s2">&#34;nosniff&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header Referrer-Policy <span class="s2">&#34;no-referrer-when-downgrade&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header Content-Security-Policy <span class="s2">&#34;default-src &#39;self&#39; http: https: data: blob: &#39;unsafe-inline&#39;&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Logging</span>
</span></span><span class="line"><span class="cl">    access_log /var/log/nginx/app.example.com.access.log<span class="p">;</span>
</span></span><span class="line"><span class="cl">    error_log /var/log/nginx/app.example.com.error.log warn<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># SSL configuration (uncomment after running Certbot)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># listen 443 ssl http2;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># listen [::]:443 ssl http2;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_protocols TLSv1.2 TLSv1.3;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_prefer_server_ciphers on;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Certbot will add its own SSL certificate paths</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_certificate /etc/letsencrypt/live/app.example.com/fullchain.pem;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_certificate_key /etc/letsencrypt/live/app.example.com/privkey.pem;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>WebSocket 升级配置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">server <span class="o">{</span>
</span></span><span class="line"><span class="cl">    listen 80<span class="p">;</span>
</span></span><span class="line"><span class="cl">    listen <span class="o">[</span>::<span class="o">]</span>:80<span class="p">;</span>
</span></span><span class="line"><span class="cl">    server_name ws.example.com<span class="p">;</span>
</span></span><span class="line"><span class="cl">    location / <span class="o">{</span>
</span></span><span class="line"><span class="cl">        proxy_pass http://localhost:8080<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_http_version 1.1<span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header Upgrade <span class="nv">$http_upgrade</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header Connection <span class="s2">&#34;upgrade&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header Host <span class="nv">$host</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header X-Real-IP <span class="nv">$remote_addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header X-Forwarded-For <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        proxy_set_header X-Forwarded-Proto <span class="nv">$scheme</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Security headers</span>
</span></span><span class="line"><span class="cl">    add_header X-Frame-Options <span class="s2">&#34;SAMEORIGIN&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header X-XSS-Protection <span class="s2">&#34;1; mode=block&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header X-Content-Type-Options <span class="s2">&#34;nosniff&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header Referrer-Policy <span class="s2">&#34;no-referrer-when-downgrade&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">    add_header Content-Security-Policy <span class="s2">&#34;default-src &#39;self&#39; http: https: data: blob: &#39;unsafe-inline&#39;&#34;</span> always<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># WebSocket timeout settings</span>
</span></span><span class="line"><span class="cl">    proxy_read_timeout 300s<span class="p">;</span>
</span></span><span class="line"><span class="cl">    proxy_send_timeout 300s<span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># Logging</span>
</span></span><span class="line"><span class="cl">    access_log /var/log/nginx/ws.example.com.access.log<span class="p">;</span>
</span></span><span class="line"><span class="cl">    error_log /var/log/nginx/ws.example.com.error.log warn<span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># SSL configuration (uncomment after running Certbot)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># listen 443 ssl http2;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># listen [::]:443 ssl http2;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_protocols TLSv1.2 TLSv1.3;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_prefer_server_ciphers on;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># Certbot will add its own SSL certificate paths</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_certificate /etc/letsencrypt/live/ws.example.com/fullchain.pem;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># ssl_certificate_key /etc/letsencrypt/live/ws.example.com/privkey.pem;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>基本配置用于为简单的静态网站提供服务。它指定了域名，IPv4 和 IPv6 都使用 80 端口监听，设置了网站的根目录，使用 try_files 配置了错误处理，添加了一些防止常见网络漏洞的基本标头，设置了访问和错误日志，还包括一个注释掉的 SSL 部分。大部分 SSL 配置将由 certbot 处理，但其中有几行添加了一些 SSL 安全性，可以在运行 certbot 后取消注释。</p>
<p>代理通行配置与基本配置类似，但它不是直接提供文件，而是将请求代理到本地应用程序（在本例中，运行于 3000 端口）。</p>
<p>第三个配置文件面向需要网站连接的应用程序，它与代理通行证配置很相似，只是在允许网络套接字方面做了一些改动。</p>
<p>如果不谈 SSL，任何有关网络服务器的内容都是不完整的。对于普通用户来说，certbot 是他们最好的朋友。它免费，速度快，还他妈的好用。我使用的是 python 版本的 certbot。安装方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo apt install certbot python3-certbot-nginx
</span></span></code></pre></td></tr></table>
</div>
</div><p>安装完成后，你只需在终端运行 &ldquo;certbot&rdquo;，它就会检测你的站点启用文件夹中的配置，并询问你要做什么（续费、重发等&hellip;&hellip;）。按照 certbot 提供的步骤操作就可以了，非常简单。</p>
<p>因此，现在 certbot 在获取新证书时会为你设置自动续费，所以这只是个 &ldquo;坐等 &ldquo;任务。但为了确保成功，你可以运行</p>
<p>如果运行正常，使用 systemd 的用户就可以放心使用了。</p>
<h2 id="quality-of-life-tools" class="headerLink">
    <a href="#quality-of-life-tools" class="header-mark"></a><strong>Quality Of Life Tools</strong></h2><p>关于 &ldquo;让系统管理更轻松的工具 &ldquo;这个话题，我将介绍一些我在服务器上使用的工具，我认为它们能让管理变得更轻松。我不会深入介绍任何工具。所有这些都是可选的，没有特定的顺序。其中很多都是我在网站上找到的，如果你和我一样是个终端迷，那么这个网站很值得浏览。</p>
<p>第一个工具，这是我的个人必备清单。Btop 是一款资源终端监控器。它能实时显示电脑的 CPU、内存、磁盘、网络和运行附魔的可视化使用统计信息，它由 C++ 编写，可通过大多数软件包管理器安装。</p>
<p>对于有大量外部连接的服务器（如 nostr 中继站），类似的工具很有帮助。Neoss 的目标是取代常用的 ss 命令，满足基本使用需求。它提供了一个使用中的 TCP 和 UDP 套接字列表及其各自的统计信息。与 SS 原始输出相比，它的主要优势在于清晰简洁的 TUI（终端用户界面），允许你对连接到机器的内容进行排序、刷新和导航。它通过 NPM 安装，这意味着你需要安装 JavaScript。</p>
<p>是一款基于终端的网络服务器日志分析器。它非常适合在终端上快速实时查看日志，还能实时生成 HTML、JSON 和 CSV 报告。GoAccess 可通过大多数软件包管理器安装，适用于所有平台。</p>
<p>接下来要介绍的是 Its，它是一款功能强大的基于文本的文件管理器，具有双面显示屏和许多操作文件和目录的功能。它还具有跨平台特性，可通过大多数软件包管理器进行安装。</p>
<p>与服务器文件管理同属一个主题的是 .NET Framework。这是我的必备清单。它是一款磁盘使用分析器，专门用于查找占用空间的文件。它运行速度快，操作简单。它可以安装在大多数系统和软件包管理器上。Windows 需要安装 Linux 子系统才能使用它。</p>
<p>希望你能从中找到一些有用的东西。我想谈的最后一个话题是 DNS，这是个比较大的话题，所以我不会做大规模的深入探讨，但如果你是自助托管，掌握一些 DNS 的基本知识还是有帮助的。</p>
<h2 id="dns" class="headerLink">
    <a href="#dns" class="header-mark"></a><strong>DNS</strong></h2><p>DNS 或域名系统是我们所熟知的互联网运作方式的核心部分。不管你喜欢还是讨厌，如果你想访问更广泛的互联网，我们就必须使用它。(我不喜欢它现在的样子，但我不会在这里说这个）。基本上，把 DNS 想象成电话簿。它可以让你在每次需要搜索互联网时输入 duckduckgo.com，而不是 &ldquo;52.250.42.157&rdquo;。它将人类容易记住的东西转化为计算机所需的信息，从而真正到达 &ldquo;duckduckgo.com&rdquo;。</p>
<p>如果您使用的是 VPS 主机，您唯一需要知道的就是在决定使用某个域名后，如何将 A 记录指向您的服务器 IP。几乎所有的 VPS 主机都可以为你提供一个静态 IP，所以这主要是一种设置和遗忘类型的交易。</p>
<p>在家托管会遇到一些挑战。一个突出的问题是（我经常听到的一个有效问题）没有静态 IP 地址。如今，由于需要 IP 地址的在线设备数量众多，我们要做的事情很多，而且大多数 IP 地址都是动态分配的，除非你从 ISP 付费购买。但还是有解决办法的。这就是动态 DNS 或 DDNS。每当 IP 地址发生变化时，DNS 服务器就会自动更新。设置动态 DNS 的方法多种多样。您可以托管自己的服务或使用主机。下面是一些主机和项目的链接，可供参考。</p>
<p>简而言之，它是这样工作的。你可以选择一个服务提供商，也可以自己设置。你可以获得一个域名，将客户端安装在家庭路由器或服务器上，客户端会定期检查 IP 地址是否发生变化，如果发生变化，它就会更新该域名的 DNS 记录。</p>
<h2 id="docker" class="headerLink">
    <a href="#docker" class="header-mark"></a><strong>Docker</strong></h2><p>在这里我不会介绍如何安装 docker。无论如何，最好还是按照官方的安装指南来安装。但我想谈几点。首先，docker 在测试新应用程序时非常有用。但我认为也仅此而已。我个人不太喜欢使用 docker，而是尽可能直接运行应用程序。以下是一些值得注意的利弊。</p>
<h3 id="优点" class="headerLink">
    <a href="#%e4%bc%98%e7%82%b9" class="header-mark"></a>优点</h3><p>如果你的系统可以运行 docker，你就可以运行大多数 docker 应用程序。它有助于隔离，减少应用程序之间的冲突。在某些情况下，它可以帮助提高效率，因为它比传统的虚拟机占用更少的资源。微服务架构也很有用，因为它可以将应用程序分解成更小的可管理服务，从而实现服务的独立扩展。最后，该社区规模庞大，文档完善，社区支持总是很有帮助，而且还有大量现成的 docker 映像可供部署。</p>
<h3 id="缺点" class="headerLink">
    <a href="#%e7%bc%ba%e7%82%b9" class="header-mark"></a>缺点</h3><p>首先是开销。虽然它比传统的虚拟机要好，但它比直接在主机上运行要耗费更多的资源，而且输入/输出操作可能会更慢。docker 共享系统内核的事实意味着，一个受损的应用程序可能会影响系统。持久化数据是可行的，但增加了一层复杂性，可能会导致新用户的数据丢失，也会使备份变得更加复杂。使用 docker 时，网络连接也会变得更加复杂，因此不会那么简单。值得注意的是，如果使用 UFW 或 firewalld 作为防火墙，docker 会绕过这些规则。Docker 只与 iptables 兼容。此外，管理良好的 docker 容器有助于管理服务器资源，但管理不当也会对资源造成损害。容器可能会变得过大，从而影响磁盘大小，而错误的配置则会占用过多的服务器资源。在监控和调试应用程序时，尤其是跨多个容器时，它还会增加额外的复杂性。</p>
<h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>好了，关于服务器设置和工具的基础知识就介绍到这里。有一个工具可以帮你完成大部分工作。我写它是为了让自己的服务器设置更快。你可以在这里获得它，它包含了我所有的必备工具，并做了一些基本配置。请根据自己的需要进行调整，并一如既往地注意安全。</p>
<h2 id="原文" class="headerLink">
    <a href="#%e5%8e%9f%e6%96%87" class="header-mark"></a>原文</h2><ul>
<li>[1] <a href="https://becomesovran.com/blog/server-setup-basics.html" target="_blank" rel="noopener noreferrer">Server Setup Basics</a></li>
</ul>
]]></description>
</item><item>
    <title>快速调整 Hyper-V 虚拟机磁盘大小</title>
    <link>https://www.techkoala.net/resize_vm_lvm_disk_size/</link>
    <pubDate>Thu, 02 Sep 2021 11:25:59 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/resize_vm_lvm_disk_size/</guid>
    <description><![CDATA[<blockquote>
<p>如何调整已建立的 Hyper-V 虚拟机磁盘大小？本文以 Ubuntu 为例，对此进行介绍。</p>
</blockquote>
<h2 id="说明" class="headerLink">
    <a href="#%e8%af%b4%e6%98%8e" class="header-mark"></a>说明</h2><p>此教程适用于使用 LVM 格式化的任何 Ubuntu 文件系统。</p>
<p>如果你在使用 VMware，基本步骤与下面的教程类似，区别参见<a href="https://unix.stackexchange.com/questions/196512/how-to-extend-filesystem-partition-on-ubuntu-vm" target="_blank" rel="noopener noreferrer">这里</a>。</p>
<h2 id="tldr" class="headerLink">
    <a href="#tldr" class="header-mark"></a>TL;DR</h2><ol>
<li>fdisk -l (note it’s partition 3 by looking at the current Size)</li>
<li>parted</li>
<li>resizepart, Fix, 3, 100% (type this instead), quit</li>
<li>pvresize /dev/sda3</li>
<li>lvextend -l +100%FREE /dev/mapper/ubuntu–vg-ubuntu–lv</li>
<li>resize2fs /dev/mapper/ubuntu–vg-ubuntu–lv</li>
<li>df -h</li>
</ol>
<h2 id="具体步骤" class="headerLink">
    <a href="#%e5%85%b7%e4%bd%93%e6%ad%a5%e9%aa%a4" class="header-mark"></a>具体步骤</h2><h3 id="查看剩余磁盘大小" class="headerLink">
    <a href="#%e6%9f%a5%e7%9c%8b%e5%89%a9%e4%bd%99%e7%a3%81%e7%9b%98%e5%a4%a7%e5%b0%8f" class="header-mark"></a>查看剩余磁盘大小</h3><p>在下面的输出中，请注意 /root 卷只有 3.9 GB 的磁盘空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~$ df -h
</span></span><span class="line"><span class="cl">Filesystem Size Used Avail Use% Mounted on
</span></span><span class="line"><span class="cl">udev 1.9G <span class="m">0</span> 1.9G 0% /dev
</span></span><span class="line"><span class="cl">tmpfs 394M 1.1M 393M 1% /run
</span></span><span class="line"><span class="cl">/dev/mapper/ubuntu--vg-ubuntu--lv 3.9G 3.2G 489M 87% /
</span></span><span class="line"><span class="cl">tmpfs 2.0G <span class="m">0</span> 2.0G 0% /dev/shm
</span></span><span class="line"><span class="cl">tmpfs 5.0M <span class="m">0</span> 5.0M 0% /run/lock
</span></span><span class="line"><span class="cl">tmpfs 2.0G <span class="m">0</span> 2.0G 0% /sys/fs/cgroup
</span></span><span class="line"><span class="cl">/dev/loop0 89M 89M <span class="m">0</span> 100% /snap/core/7270
</span></span><span class="line"><span class="cl">/dev/sda2 976M 77M 833M 9% /boot
</span></span><span class="line"><span class="cl">/dev/loop1 90M 90M <span class="m">0</span> 100% /snap/core/7713
</span></span><span class="line"><span class="cl">tmpfs 394M <span class="m">0</span> 394M 0% /run/user/1000
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来，在输出中可以看出实际上还有更多可用空间未利用。例如 /dev/sda3 卷上有 24G。另一个 1GB 用于启动卷和 BIOS 启动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~# fdisk -l
</span></span><span class="line"><span class="cl">Disk /dev/loop0: 88.5 MiB, <span class="m">92778496</span> bytes, <span class="m">181208</span> sectors
</span></span><span class="line"><span class="cl">Units: sectors of <span class="m">1</span> * <span class="nv">512</span> <span class="o">=</span> <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">I/O size <span class="o">(</span>minimum/optimal<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Disk /dev/loop1: <span class="m">89</span> MiB, <span class="m">93327360</span> bytes, <span class="m">182280</span> sectors
</span></span><span class="line"><span class="cl">Units: sectors of <span class="m">1</span> * <span class="nv">512</span> <span class="o">=</span> <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">I/O size <span class="o">(</span>minimum/optimal<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Disk /dev/sda: <span class="m">25</span> GiB, <span class="m">26843545600</span> bytes, <span class="m">52428800</span> sectors
</span></span><span class="line"><span class="cl">Units: sectors of <span class="m">1</span> * <span class="nv">512</span> <span class="o">=</span> <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">4096</span> bytes
</span></span><span class="line"><span class="cl">I/O size <span class="o">(</span>minimum/optimal<span class="o">)</span>: <span class="m">4096</span> bytes / <span class="m">4096</span> bytes
</span></span><span class="line"><span class="cl">Disklabel type: gpt
</span></span><span class="line"><span class="cl">Disk identifier: ED41F7A6-5D09-457B-A55C-C7F1E30DE419
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Device Start End Sectors Size Type
</span></span><span class="line"><span class="cl">/dev/sda1 <span class="m">2048</span> <span class="m">4095</span> <span class="m">2048</span> 1M BIOS boot
</span></span><span class="line"><span class="cl">/dev/sda2 <span class="m">4096</span> <span class="m">2101247</span> <span class="m">2097152</span> 1G Linux filesystem
</span></span><span class="line"><span class="cl">/dev/sda3 <span class="m">2101248</span> <span class="m">52426751</span> <span class="m">50325504</span> 24G Linux filesystem
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Disk /dev/mapper/ubuntu--vg-ubuntu--lv: <span class="m">4</span> GiB, <span class="m">4294967296</span> bytes, <span class="m">8388608</span> sectors
</span></span><span class="line"><span class="cl">Units: sectors of <span class="m">1</span> * <span class="nv">512</span> <span class="o">=</span> <span class="m">512</span> bytes
</span></span><span class="line"><span class="cl">Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: <span class="m">512</span> bytes / <span class="m">4096</span> bytes
</span></span><span class="line"><span class="cl">I/O size <span class="o">(</span>minimum/optimal<span class="o">)</span>: <span class="m">4096</span> bytes / <span class="m">4096</span> bytes
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整虚拟机磁盘大小" class="headerLink">
    <a href="#%e8%b0%83%e6%95%b4%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%a3%81%e7%9b%98%e5%a4%a7%e5%b0%8f" class="header-mark"></a>调整虚拟机磁盘大小</h3><p>进入 Hyper-V 虚拟机设置界面，编辑硬盘驱动器，然后对此进行扩容，此后重启虚拟机。</p>
<h3 id="重新分区" class="headerLink">
    <a href="#%e9%87%8d%e6%96%b0%e5%88%86%e5%8c%ba" class="header-mark"></a>重新分区</h3><p>下面利用 parted 进行对新加的磁盘进行分区。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~# parted
</span></span><span class="line"><span class="cl">GNU Parted 3.2
</span></span><span class="line"><span class="cl">Using /dev/sda
</span></span><span class="line"><span class="cl">Welcome to GNU Parted! Type <span class="s1">&#39;help&#39;</span> to view a list of commands.
</span></span><span class="line"><span class="cl"><span class="o">(</span>parted<span class="o">)</span> print
</span></span><span class="line"><span class="cl">Model: Msft Virtual Disk <span class="o">(</span>scsi<span class="o">)</span>
</span></span><span class="line"><span class="cl">Disk /dev/sda: 26.8GB
</span></span><span class="line"><span class="cl">Sector size <span class="o">(</span>logical/physical<span class="o">)</span>: 512B/4096B
</span></span><span class="line"><span class="cl">Partition Table: gpt
</span></span><span class="line"><span class="cl">Disk Flags:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Number Start End Size File system Name Flags
</span></span><span class="line"><span class="cl"><span class="m">1</span> 1049kB 2097kB 1049kB bios_grub
</span></span><span class="line"><span class="cl"><span class="m">2</span> 2097kB 1076MB 1074MB ext4
</span></span><span class="line"><span class="cl"><span class="m">3</span> 1076MB 26.8GB 25.8GB
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">(</span>parted<span class="o">)</span> quit
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~# parted
</span></span><span class="line"><span class="cl">GNU Parted 3.2
</span></span><span class="line"><span class="cl">Using /dev/sda
</span></span><span class="line"><span class="cl">Welcome to GNU Parted! Type <span class="s1">&#39;help&#39;</span> to view a list of commands.
</span></span><span class="line"><span class="cl"><span class="o">(</span>parted<span class="o">)</span> resizepart
</span></span><span class="line"><span class="cl">Partition number? <span class="m">3</span>
</span></span><span class="line"><span class="cl">End? <span class="o">[</span>26.8GB<span class="o">]</span>?
</span></span><span class="line"><span class="cl"><span class="o">(</span>parted<span class="o">)</span> quit
</span></span><span class="line"><span class="cl">Information: You may need to update /etc/fstab.
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~# pvresize /dev/sda3
</span></span><span class="line"><span class="cl">Physical volume <span class="s2">&#34;/dev/sda3&#34;</span> changed
</span></span><span class="line"><span class="cl"><span class="m">1</span> physical volume<span class="o">(</span>s<span class="o">)</span> resized / <span class="m">0</span> physical volume<span class="o">(</span>s<span class="o">)</span> not resized
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="扩容" class="headerLink">
    <a href="#%e6%89%a9%e5%ae%b9" class="header-mark"></a>扩容</h3><p>接下来，对 LVM 虚拟磁盘进行扩容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~# resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv
</span></span><span class="line"><span class="cl">resize2fs 1.44.1 <span class="o">(</span>24-Mar-2018<span class="o">)</span>
</span></span><span class="line"><span class="cl">Filesystem at /dev/mapper/ubuntu--vg-ubuntu--lv is mounted on /<span class="p">;</span> on-line resizing required
</span></span><span class="line"><span class="cl"><span class="nv">old_desc_blocks</span> <span class="o">=</span> 1, <span class="nv">new_desc_blocks</span> <span class="o">=</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">The filesystem on /dev/mapper/ubuntu--vg-ubuntu--lv is now <span class="m">6029312</span> <span class="o">(</span>4k<span class="o">)</span> blocks long.
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="确认" class="headerLink">
    <a href="#%e7%a1%ae%e8%ae%a4" class="header-mark"></a>确认</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">user@server:~# df -h
</span></span><span class="line"><span class="cl">Filesystem Size Used Avail Use% Mounted on
</span></span><span class="line"><span class="cl">udev 1.9G <span class="m">0</span> 1.9G 0% /dev
</span></span><span class="line"><span class="cl">tmpfs 394M 1.1M 393M 1% /run
</span></span><span class="line"><span class="cl">/dev/mapper/ubuntu--vg-ubuntu--lv 23G 3.2G 19G 15% /
</span></span><span class="line"><span class="cl">tmpfs 2.0G <span class="m">0</span> 2.0G 0% /dev/shm
</span></span><span class="line"><span class="cl">tmpfs 5.0M <span class="m">0</span> 5.0M 0% /run/lock
</span></span><span class="line"><span class="cl">tmpfs 2.0G <span class="m">0</span> 2.0G 0% /sys/fs/cgroup
</span></span><span class="line"><span class="cl">/dev/loop0 89M 89M <span class="m">0</span> 100% /snap/core/7270
</span></span><span class="line"><span class="cl">/dev/sda2 976M 77M 833M 9% /boot
</span></span><span class="line"><span class="cl">/dev/loop1 90M 90M <span class="m">0</span> 100% /snap/core/7713
</span></span><span class="line"><span class="cl">tmpfs 394M <span class="m">0</span> 394M 0% /run/user/1000
</span></span><span class="line"><span class="cl">user@server:~#
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>[1] <a href="https://vander.host/knowledgebase/operating-systems/how-to-resize-an-ubuntu-18-04-lvm-disk/" target="_blank" rel="noopener noreferrer">How to resize an Ubuntu 18.04/20.04 LVM disk</a></li>
</ul>]]></description>
</item><item>
    <title>不容错过的 Bash 技巧</title>
    <link>https://www.techkoala.net/bash_tricks/</link>
    <pubDate>Fri, 04 Jun 2021 11:06:47 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/bash_tricks/</guid>
    <description><![CDATA[<blockquote>
<p>一些提升 Bash 使用效率的小技巧</p>
</blockquote>
<p>在使用 Bash 时，我们通常使用 上 ↑ 下 ↓ 箭头来快速切换历史命令，然而一些重复的、不想要的命令（例如最简单的 ls，敲击比切换快，同时也会增加切换到别的命令的按键次数）也在历史记录里保存，这降低了切换的效率。下面一些技巧可以更好的帮助我们切换到想要的命令：</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>下文中需要编辑的内容均在<code>.bashrc</code>中，使用常用的文本编辑器打开它，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ vim ~/.bashrc
</span></span></code></pre></td></tr></table>
</div>
</div></div>
        </div>
    </div>
<h2 id="使用-histignore-移除历史记录中无意义的命令" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-histignore-%e7%a7%bb%e9%99%a4%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95%e4%b8%ad%e6%97%a0%e6%84%8f%e4%b9%89%e7%9a%84%e5%91%bd%e4%bb%a4" class="header-mark"></a>使用 HISTIGNORE 移除历史记录中无意义的命令</h2><p>有一些命令极为常用常用、或者敲击简单，我们不想它出现在历史记录里，那么在<code>.bashrc</code>中添加下述内容忽略它即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">HISTIGNORE</span><span class="o">=</span><span class="s1">&#39;pwd:exit:fg:bg:top:clear:history:ls:uptime:df&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>作为补充，如果我们不希望某些敏感的命令出现在历史记录中，例如在命令行中指定密码或 API 密钥，那么可以使用下面的选项来确保任何以<strong>空格</strong>开头的命令不会出现在历史文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">HISTCONTROL</span><span class="o">=</span>ignorespace
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">HISTCONTROL</span><span class="o">=</span>ignoredups
</span></span></code></pre></td></tr></table>
</div>
</div><p>则表示当同一个命令重复出现时，只存储命令的一个副本。</p>
<h2 id="设置历史记录数量" class="headerLink">
    <a href="#%e8%ae%be%e7%bd%ae%e5%8e%86%e5%8f%b2%e8%ae%b0%e5%bd%95%e6%95%b0%e9%87%8f" class="header-mark"></a>设置历史记录数量</h2><p>为了防止不必要的丢失，可以适当的将记录数量调整的更大：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">shopt</span> -s histappend
</span></span><span class="line"><span class="cl"><span class="nb">export</span> <span class="nv">HISTSIZE</span><span class="o">=</span><span class="m">10000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="更有效的调用命令" class="headerLink">
    <a href="#%e6%9b%b4%e6%9c%89%e6%95%88%e7%9a%84%e8%b0%83%e7%94%a8%e5%91%bd%e4%bb%a4" class="header-mark"></a>更有效的调用命令</h2><p><code>!!</code>可以调用前一行的命令。</p>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ <span class="nb">pwd</span>
</span></span><span class="line"><span class="cl">/etc
</span></span><span class="line"><span class="cl">$ !!
</span></span><span class="line"><span class="cl"><span class="nb">pwd</span>
</span></span><span class="line"><span class="cl">/etc
</span></span></code></pre></td></tr></table>
</div>
</div><p>同时，<code>!!</code>也可以作为参数加入别的命令配合使用，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ sudo !!
</span></span></code></pre></td></tr></table>
</div>
</div><p>就将使用 root 权限再次执行此前的命令。</p>
<p>此外，我们还可以通过在历史命令提供的<strong>行号</strong>前加一个<code>!</code>来运行历史上的命令，但是请注意不要打错行号，避免执行出错：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ rm -r temp/
</span></span><span class="line"><span class="cl">$ mkdir temp
</span></span><span class="line"><span class="cl">$ touch temp/test
</span></span><span class="line"><span class="cl">$ !!
</span></span><span class="line"><span class="cl">touch temp/test
</span></span><span class="line"><span class="cl">$ <span class="nb">history</span> <span class="p">|</span> tail -4
</span></span><span class="line"><span class="cl">  <span class="m">179</span>  rm -r temp/
</span></span><span class="line"><span class="cl">  <span class="m">180</span>  mkdir temp
</span></span><span class="line"><span class="cl">  <span class="m">181</span>  touch temp/test
</span></span><span class="line"><span class="cl">  <span class="m">182</span>  touch temp/test
</span></span><span class="line"><span class="cl">  <span class="m">183</span>  <span class="nb">history</span> <span class="p">|</span> tail -5
</span></span><span class="line"><span class="cl">$ !179:p
</span></span><span class="line"><span class="cl">rm -r temp
</span></span><span class="line"><span class="cl">$ !180
</span></span><span class="line"><span class="cl">touch temp/test
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们也可以用前面的<code>!</code>来调用一个命令的最后一次出现，例如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ !ping
</span></span></code></pre></td></tr></table>
</div>
</div><p>将运行我们最后运行的以 <code>ping</code> 开头的命令。</p>
<p>为了上述内容出错，可以添加一个<code>:p</code>来显示命令内容，而不实际执行它们。</p>
<h2 id="使用--和--调用前一行参数" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8--%e5%92%8c--%e8%b0%83%e7%94%a8%e5%89%8d%e4%b8%80%e8%a1%8c%e5%8f%82%e6%95%b0" class="header-mark"></a>使用 !$ 和 !* 调用前一行参数</h2><p>和<code>!!</code>不同，<code>!$</code>和<code>!*</code>仅指代前一行，命令的部分内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ mv list.txt items.txt
</span></span><span class="line"><span class="cl">$ vim !$
</span></span><span class="line"><span class="cl">vim items.txt
</span></span><span class="line"><span class="cl">$ cp !$ shopping.txt
</span></span><span class="line"><span class="cl">cp items.txt shopping.txt
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到<code>!$</code>指代上一行命令的最后一个参数。</p>
<p>而<code>!*</code>指代上一行命令<strong>除了第一个</strong>以外的所有参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ rm /var/log/httpd/access.log /var/log/httpd/error.log
</span></span><span class="line"><span class="cl">$ touch !*
</span></span><span class="line"><span class="cl">touch /var/log/httpd/access.log /var/log/httpd/error.log
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="用--替换前一行的匹配词" class="headerLink">
    <a href="#%e7%94%a8--%e6%9b%bf%e6%8d%a2%e5%89%8d%e4%b8%80%e8%a1%8c%e7%9a%84%e5%8c%b9%e9%85%8d%e8%af%8d" class="header-mark"></a>用 ^ 替换前一行的匹配词</h2><p><code>^</code>符号允许你在切换一个匹配的单词后重复前一个命令，比如说：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ rm /var/log/httpd/error.log
</span></span><span class="line"><span class="cl">$ ^error^access
</span></span><span class="line"><span class="cl">rm /var/log/httpd/access.log
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>[1] <a href="https://cyb.org.uk/2021/05/03/bash-productivity.html" target="_blank" rel="noopener noreferrer">Be more productive with use of your BASH history</a></li>
</ul>]]></description>
</item><item>
    <title>文件传输系列：SFTP</title>
    <link>https://www.techkoala.net/sftp/</link>
    <pubDate>Thu, 06 Aug 2020 14:07:53 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/sftp/</guid>
    <description><![CDATA[<blockquote>
<p>SCP 的继承者</p>
</blockquote>
<h2 id="什么是-sftp" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-sftp" class="header-mark"></a>什么是 SFTP</h2><p>首先需要明确的是，SFTP（SSH File Transfer Protocol）不是运行在 SSH 上的 FTP，而是由 IETF（Internet Engineering Task Force）工作组设计的新协议，将其作为 SSH 2.0 版的扩展，提供安全的文件传输功能。因此，没有单独的 SFTP 端口，而是使用普通的 SSH 端口。协议本身不提供身份验证和安全性，而是期望底层协议提供。</p>
<p>与仅允许文件传输的 SCP 协议相比，SFTP 协议允许对远程文件进行一系列操作，这使其更像远程文件系统协议。SFTP 客户端还支持包括恢复中断的传输，目录列表和远程文件删除等功能。此外，上传的文件可以与它们的基本属性相关联，例如时间戳。相比普通 FTP 协议，这是一项优势。</p>
<p>尽管 SFTP 最常在 Unix 平台上实现，但 SFTP 在主流平台都可用。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">有关 SFTP 详细草案参见 <a href="https://assets.ctfassets.net/0lvk5dbamxpi/6jBxT5LDgMqutNK4mPTGKd/4fa27cb4a130bca3b48a10c9045b0497/draft-ietf-secsh-filexfer-02" target="_blank" rel="noopener noreferrer">draft-ietf-secsh-filexfer-02</a></div>
        </div>
    </div>
<h2 id="使用-sftp" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-sftp" class="header-mark"></a>使用 SFTP</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sftp 选项 参数
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="选项" class="headerLink">
    <a href="#%e9%80%89%e9%a1%b9" class="header-mark"></a>选项</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">-B：指定传输文件时缓冲区的大小；
</span></span><span class="line"><span class="cl">-l：使用 ssh 协议版本 1；
</span></span><span class="line"><span class="cl">-b：指定批处理文件；
</span></span><span class="line"><span class="cl">-C：使用压缩；
</span></span><span class="line"><span class="cl">-o：指定 ssh 选项；
</span></span><span class="line"><span class="cl">-F：指定 ssh 配置文件；
</span></span><span class="line"><span class="cl">-R：指定一次可以容忍多少请求数；
</span></span><span class="line"><span class="cl">-v：升高日志等级。
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="参数" class="headerLink">
    <a href="#%e5%8f%82%e6%95%b0" class="header-mark"></a>参数</h3><p>目标主机：指定 SFTP 服务器 IP 地址或者主机名。</p>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>
<p>[1] <a href="https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol" target="_blank" rel="noopener noreferrer">SSH File Transfer Protocol</a></p>
</li>
<li>
<p>[2] <a href="https://jaywcjlove.gitee.io/linux-command/c/sftp.html" target="_blank" rel="noopener noreferrer">SFTP Command</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>文件传输系列：rsync</title>
    <link>https://www.techkoala.net/rsync/</link>
    <pubDate>Wed, 05 Aug 2020 20:58:00 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/rsync/</guid>
    <description><![CDATA[<blockquote>
<p>SCP 的另一个绝佳替选</p>
</blockquote>
<h2 id="什么是-rsync" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-rsync" class="header-mark"></a>什么是 rsync</h2><p>rsync (remote synchronize) 是一款实现远程同步功能的软件，它在同步文件的同时，可以保持原来文件的权限、时间、软硬链接等附加信息。</p>
<p>rsync 是<code>类 Unix</code> 系统下的数据镜像备份工具。它能同步更新两处计算机的文件与目录，并适当利用差分编码以减少数据传输量。 rsync 中的一项同类软件不常见的重要特性是每个目标的镜像只需发送一次。rsync 可以拷贝／显示目录内容，以及拷贝文件，并可选压缩以及递归拷贝。</p>
<p>rsync 默认监听 <code>TCP</code> 端口 873，以原生 rsync 传输协议或者透过<code>远程 shell</code> 如 <code>RSH</code> 或者 <code>SSH</code> 提供文件。<code>SSH</code> 模式下，rsync 客户端运行程序必须同时在本地和远程机器上安装。</p>
<h2 id="rsync-算法" class="headerLink">
    <a href="#rsync-%e7%ae%97%e6%b3%95" class="header-mark"></a>rsync 算法</h2><div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">此部分内容转载 <a href="https://coolshell.cn/articles/7425.html" target="_blank" rel="noopener noreferrer">RSYNC 的核心算法</a></div>
        </div>
    </div>
<p>rsync 的算法如下：（假设源文件名为 <code>fileSrc</code>，目的文件叫 <code>fileDst</code>）</p>
<h3 id="分块-checksum-算法" class="headerLink">
    <a href="#%e5%88%86%e5%9d%97-checksum-%e7%ae%97%e6%b3%95" class="header-mark"></a>分块 Checksum 算法</h3><p>首先，我们会把 <code>fileDst</code> 的文件平均切分成若干个小块，比如每块 512 个字节，然后对<strong>每块</strong>计算<strong>两个</strong> <code>checksum</code>，一个叫 <code>rolling checksum</code>，是<code>弱 checksum</code>，32 位的 <code>checksum</code>，其使用的是 Mark Adler 发明的 <code>adler-32</code> 算法，另一个是<code>强 checksum</code>，128 位的，以前用 <code>md4</code>，现在用 <code>md5</code>。为什么要这样？因为若干年前的硬件上跑 <code>md4</code> 的算法太慢了，所以，需要一个快算法来鉴别文件块的不同，但是弱的 <code>adler-32</code> 算法碰撞概率太高了，所以我们还要引入强的 <code>checksum</code> 算法以保证两文件块是相同的。也就是说，弱的 <code>checksum</code> 是用来区别不同，而强的是用来确认相同。</p>
<h3 id="传输算法" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e7%ae%97%e6%b3%95" class="header-mark"></a>传输算法</h3><p>同步目标端会把 <code>fileDst</code> 的一个 <code>checksum</code> 列表传给同步源，这个列表里包括了三个东西，<code>rolling checksum</code> (32bits)，<code>md5 checksume</code> (128bits)，<code>文件块编号</code>。同步源机器拿到了这个列表后，会对 <code>fileSrc</code> 做同样的 <code>checksum</code>，然后和 <code>fileDst</code> 的 <code>checksum</code> 做对比，这样就知道哪些文件块改变了。</p>
<p><strong>但是</strong></p>
<p>如果我 <code>fileSrc</code> 这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和 <code>fileDst</code> 这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？
如果这个 <code>checksum</code> 列表特别长，而两边相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？</p>
<h3 id="checksum-查找算法" class="headerLink">
    <a href="#checksum-%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95" class="header-mark"></a>Checksum 查找算法</h3><p>同步源端拿到 <code>fileDst</code> 的 <code>checksum</code> 数组后，会把这个数据存到一个 <code>hash table</code> 中，用 <code>rolling checksum</code> 做 <code>hash</code>，以便获得 <code>O(1)</code> 时间复杂度的查找性能。这个 <code>hash table</code> 是 16 bits 的，所以，<code>hash table</code> 的尺寸是 2 的 16 次方，对 <code>rolling checksum</code> 的 <code>hash</code> 会被散列到 0 到 $ 2^{16} – 1 $ 中的某个整数值。</p>
<h3 id="比对算法" class="headerLink">
    <a href="#%e6%af%94%e5%af%b9%e7%ae%97%e6%b3%95" class="header-mark"></a>比对算法</h3><ol>
<li>
<p>取 <code>fileSrc</code> 的第一个文件块（我们假设的是 512 个长度），也就是从 <code>fileSrc</code> 的第 1 个字节到第 512 个字节，取出来后做 <code>rolling checksum</code> 计算。计算好的值到 <code>hash</code> 表中查询。</p>
</li>
<li>
<p>如果查到了，说明发现在 <code>fileDst</code> 中有潜在相同的文件块，于是就再比较 · 的 <code>checksum</code>，因为 <code>rolling checksume</code> 太弱了，可能发生碰撞。于是还要算 <code>md5</code> 的 128 bits 的 <code>checksum</code>，这样一来，我们就有 $2^{-(32+128)} = 2^{-160} $ 的概率发生碰撞，这小到可以忽略。如果 <code>rolling checksum</code> 和 <code>md5 checksum</code> 都相同，那就可以说明在 <code>fileDst</code> 中有相同的块，记下这一块在 <code>fileDst</code> 下的文件编号。</p>
</li>
<li>
<p>如果 <code>fileSrc</code> 的 <code>rolling checksum</code> 没有在 <code>hash table</code> 中找到，那就不用算 <code>md5 checksum</code> 了。表示这一块中有不同的信息。总之，只要 <code>rolling checksum</code> 或 <code>md5 checksum</code> 其中有一个在 <code>fileDst</code> 的 <code>checksum hash</code> 表中找不到匹配项，那么就会触发算法对 <code>fileSrc</code> 的 rolling 动作。于是，算法会住后 step 1 个字节，取 <code>fileSrc</code> 中字节 2-513 的文件块要做 <code>checksum</code>，然后继续第一步 – 这就是为什么叫 <code>rolling checksum</code> 。</p>
</li>
<li>
<p>这样，我们就可以找出 <code>fileSrc</code> 相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。</p>
</li>
</ol>
<h2 id="rolling-checksum-算法" class="headerLink">
    <a href="#rolling-checksum-%e7%ae%97%e6%b3%95" class="header-mark"></a>Rolling Checksum 算法</h2><p>rolling checksum 算法也叫 <code>Rabin-Karp</code> 算法，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它用来解决多模式串匹配问题。其最大的精髓是，当往后面 step 1 个字符的时候，不用全部重新计算所有的 <code>checksum</code>，也就是说，从 [0, 512] rolling 到 [1, 513] 时，不需要重新计算从 1 到 513 的 <code>checksum</code>，而是重用 [0，512] 的 <code>checksum</code> 直接算出来。</p>
<p>其公式可以表示为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中的 b 是一个常数基数，在 Rabin-Karp 算法中，一般取值为 256。</p>
<p>于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1)  + t[m] * b ^0
</span></span></code></pre></td></tr></table>
</div>
</div><figure><a class="lightgallery" href="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg" title="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg" data-thumbnail="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg" data-sub-html="<h2>rsync 算法示意</h2>">
        <img
            
            loading="lazy"
            src="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg"
            srcset="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg, https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg 1.5x, https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg 2x"
            sizes="auto"
            alt="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/Rsync/rsync-algorithm.jpg">
    </a><figcaption class="image-caption">rsync 算法示意</figcaption>
    </figure>
<p>最终，得到的数据组可以想象为 BT 协议下载 torrent ：一些文件块已下载（匹配上），其他的文件块还未下载（未匹配上）。然后，同步端将这些未匹配上的文件打上标号发送，目的端根据标号重组文件就完成了同步。</p>
<h2 id="使用-rsync" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-rsync" class="header-mark"></a>使用 rsync</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">rsync <span class="o">[</span>OPTION<span class="o">]</span>... SRC DEST
</span></span><span class="line"><span class="cl">rsync <span class="o">[</span>OPTION<span class="o">]</span>... SRC <span class="o">[</span>USER@<span class="o">]</span> host:DEST
</span></span><span class="line"><span class="cl">rsync <span class="o">[</span>OPTION<span class="o">]</span>... <span class="o">[</span>USER@<span class="o">]</span> HOST:SRC DEST
</span></span><span class="line"><span class="cl">rsync <span class="o">[</span>OPTION<span class="o">]</span>... <span class="o">[</span>USER@<span class="o">]</span> HOST::SRC DEST
</span></span><span class="line"><span class="cl">rsync <span class="o">[</span>OPTION<span class="o">]</span>... SRC <span class="o">[</span>USER@<span class="o">]</span> HOST::DEST
</span></span><span class="line"><span class="cl">rsync <span class="o">[</span>OPTION<span class="o">]</span>... rsync://<span class="o">[</span>USER@<span class="o">]</span> HOST <span class="o">[</span>:PORT<span class="o">]</span>/SRC <span class="o">[</span>DEST<span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应于以上六种命令格式，<code>rsync</code> 有六种不同的工作模式：</p>
<ul>
<li>
<p>拷贝本地文件。当 <code>SRC</code> 和 <code>DES</code> 路径信息都<strong>不包含</strong>有单个冒号 &ldquo;:&rdquo; 分隔符时就启动这种工作模式。如：<code>rsync -a /data/backup</code></p>
</li>
<li>
<p>使用一个远程 <code>shell</code> 程序 (如 rsh、ssh) 来实现将本地机器的内容拷贝到远程机器。当 <code>DST</code> 路径地址<strong>包含单个</strong>冒号 &ldquo;:&rdquo; 分隔符时启动该模式。如：<code>rsync -avz *.c foo:src</code></p>
</li>
<li>
<p>使用一个远程 <code>shell</code> 程序 (如 <code>rsh</code>、<code>ssh</code>) 来实现将远程机器的内容拷贝到本地机器。当 <code>SRC</code> 地址路径<strong>包含单个</strong>冒号 &ldquo;:&rdquo; 分隔符时启动该模式。如：<code>rsync -avz foo:src/bar/data</code></p>
</li>
<li>
<p>从远程 <code>rsync</code> 服务器中拷贝文件到本地机。当 <code>SRC</code> 路径信息包含 &ldquo;::&rdquo; 分隔符时启动该模式。如：<code>rsync -av root@192.168.78.192::www /databack</code></p>
</li>
<li>
<p>从本地机器拷贝文件到远程 <code>rsync</code> 服务器中。当 <code>DST</code> 路径信息包含 &ldquo;::&rdquo; 分隔符时启动该模式。如：<code>rsync -av /databack root@192.168.78.192::www</code></p>
</li>
<li>
<p>列出远程主机的文件列表。这类似于 <code>rsync</code> 传输，不过只要在命令中省略掉本地机信息即可。如：<code>rsync -v rsync://192.168.78.192/www</code></p>
</li>
</ul>
<p>可用选项如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-v, --verbose 详细模式输出。
</span></span><span class="line"><span class="cl">-q, --quiet 精简输出模式。
</span></span><span class="line"><span class="cl">-C, --cvs-exclude 使用和 CVS 一样的方法自动忽略文件，用来排除那些不希望传输的文件。
</span></span><span class="line"><span class="cl">-c, --checksum 打开校验开关，强制对文件传输进行校验。
</span></span><span class="line"><span class="cl">-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于 - rlptgoD。
</span></span><span class="line"><span class="cl">-r, --recursive 对子目录以递归模式处理。
</span></span><span class="line"><span class="cl">-R, --relative 使用相对路径信息。
</span></span><span class="line"><span class="cl">-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为～filename。可以使用 --suffix 选项来指定不同的备份文件前缀。
</span></span><span class="line"><span class="cl">-u, --update 仅仅进行更新，也就是跳过所有已经存在于 DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。
</span></span><span class="line"><span class="cl">-l, --links 保留软链结。
</span></span><span class="line"><span class="cl">-L, --copy-links 想对待常规文件一样处理软链结。
</span></span><span class="line"><span class="cl">-H, --hard-links 保留硬链结。
</span></span><span class="line"><span class="cl">-I, --ignore-times 不跳过那些有同样的时间和长度的文件。
</span></span><span class="line"><span class="cl">-p, --perms 保持文件权限。
</span></span><span class="line"><span class="cl">-o, --owner 保持文件属主信息。
</span></span><span class="line"><span class="cl">-g, --group 保持文件属组信息。
</span></span><span class="line"><span class="cl">-D, --devices 保持设备文件信息。
</span></span><span class="line"><span class="cl">-t, --times 保持文件时间信息。
</span></span><span class="line"><span class="cl">-S, --sparse 对稀疏文件进行特殊处理以节省 DST 的空间。
</span></span><span class="line"><span class="cl">-T --temp-dir<span class="o">=</span>DIR 在 DIR 中创建临时文件。
</span></span><span class="line"><span class="cl">-n, --dry-run 现实哪些文件将被传输。
</span></span><span class="line"><span class="cl">-w, --whole-file 拷贝文件，不进行增量检测。
</span></span><span class="line"><span class="cl">-x, --one-file-system 不要跨越文件系统边界。
</span></span><span class="line"><span class="cl">-B, --block-size<span class="o">=</span>SIZE 检验算法使用的块尺寸，默认是 <span class="m">700</span> 字节。
</span></span><span class="line"><span class="cl">-e, --rsh<span class="o">=</span><span class="nb">command</span> 指定使用 rsh、ssh 方式进行数据同步。
</span></span><span class="line"><span class="cl">-P 等同于 --partial。
</span></span><span class="line"><span class="cl">-z, --compress 对备份的文件在传输时进行压缩处理。
</span></span><span class="line"><span class="cl">-h, --help 显示帮助信息。
</span></span><span class="line"><span class="cl">--backup-dir 将备份文件 <span class="o">(</span>如～filename<span class="o">)</span> 存放在在目录下。
</span></span><span class="line"><span class="cl">-suffix<span class="o">=</span>SUFFIX 定义备份文件前缀。
</span></span><span class="line"><span class="cl">--copy-unsafe-links 仅仅拷贝指向 SRC 路径目录树以外的链结。
</span></span><span class="line"><span class="cl">--safe-links 忽略指向 SRC 路径目录树以外的链结。
</span></span><span class="line"><span class="cl">--rsync-path<span class="o">=</span>PATH 指定远程服务器上的 rsync 命令所在路径信息。
</span></span><span class="line"><span class="cl">--existing 仅仅更新那些已经存在于 DST 的文件，而不备份那些新创建的文件。
</span></span><span class="line"><span class="cl">--delete 删除那些 DST 中 SRC 没有的文件。
</span></span><span class="line"><span class="cl">--delete-excluded 同样删除接收端那些被该选项指定排除的文件。
</span></span><span class="line"><span class="cl">--delete-after 传输结束以后再删除。
</span></span><span class="line"><span class="cl">--ignore-errors 及时出现 IO 错误也进行删除。
</span></span><span class="line"><span class="cl">--max-delete<span class="o">=</span>NUM 最多删除 NUM 个文件。
</span></span><span class="line"><span class="cl">--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。
</span></span><span class="line"><span class="cl">--force 强制删除目录，即使不为空。
</span></span><span class="line"><span class="cl">--numeric-ids 不将数字的用户和组 id 匹配为用户名和组名。
</span></span><span class="line"><span class="cl">--timeout<span class="o">=</span><span class="nb">time</span> ip 超时时间，单位为秒。
</span></span><span class="line"><span class="cl">--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。
</span></span><span class="line"><span class="cl">--modify-window<span class="o">=</span>NUM 决定文件是否时间相同时使用的时间戳窗口，默认为 0。
</span></span><span class="line"><span class="cl">--compare-dest<span class="o">=</span>DIR 同样比较 DIR 中的文件来决定是否需要备份。
</span></span><span class="line"><span class="cl">--progress 显示备份过程。
</span></span><span class="line"><span class="cl">--exclude<span class="o">=</span>PATTERN 指定排除不需要传输的文件模式。
</span></span><span class="line"><span class="cl">--include<span class="o">=</span>PATTERN 指定不排除而需要传输的文件模式。
</span></span><span class="line"><span class="cl">--exclude-from<span class="o">=</span>FILE 排除 FILE 中指定模式的文件。
</span></span><span class="line"><span class="cl">--include-from<span class="o">=</span>FILE 不排除 FILE 指定模式匹配的文件。
</span></span><span class="line"><span class="cl">--version 打印版本信息。
</span></span><span class="line"><span class="cl">--address 绑定到特定的地址。
</span></span><span class="line"><span class="cl">--config<span class="o">=</span>FILE 指定其他的配置文件，不使用默认的 rsyncd.conf 文件。
</span></span><span class="line"><span class="cl">--port<span class="o">=</span>PORT 指定其他的 rsync 服务端口。
</span></span><span class="line"><span class="cl">--blocking-io 对远程 shell 使用阻塞 IO。
</span></span><span class="line"><span class="cl">-stats 给出某些文件的传输状态。
</span></span><span class="line"><span class="cl">--progress 在传输时现实传输过程。
</span></span><span class="line"><span class="cl">--log-format<span class="o">=</span>formAT 指定日志文件格式。
</span></span><span class="line"><span class="cl">--password-file<span class="o">=</span>FILE 从 FILE 中得到密码。
</span></span><span class="line"><span class="cl">--bwlimit<span class="o">=</span>KBPS 限制 I/O 带宽，KBytes per second。
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>
<p>[1] <a href="https://rsync.samba.org/tech_report/tech_report.html" target="_blank" rel="noopener noreferrer">The rsync algorithm</a></p>
</li>
<li>
<p>[2] <a href="https://coolshell.cn/articles/7425.html" target="_blank" rel="noopener noreferrer">RSYNC 的核心算法</a></p>
</li>
<li>
<p>[3] <a href="https://zh.wikipedia.org/wiki/Rsync" target="_blank" rel="noopener noreferrer">rsync wikipedia</a></p>
</li>
<li>
<p>[4] <a href="https://ningyu1.github.io/linux-command/c/rsync.html" target="_blank" rel="noopener noreferrer">rsync command</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>文件传输系列：SCP</title>
    <link>https://www.techkoala.net/scp/</link>
    <pubDate>Sat, 18 Jul 2020 10:28:05 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/scp/</guid>
    <description><![CDATA[<blockquote>
<p>SCP 就是 SSH 协议的文件传输功能吗？</p>
</blockquote>
<h2 id="什么是-scp" class="headerLink">
    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-scp" class="header-mark"></a>什么是 SCP</h2><p>SCP（Secure Copy Protocol，安全复制协议）允许我们在两台计算机之间复制文件（和目录）。</p>
<p>使用起来特别方便：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl">$ scp local_file remote_host:/home
</span></span></code></pre></td></tr></table>
</div>
</div><p>这将把本地文件 <code>localfile</code> 复制到远程主机的 <code>/home</code> 文件之下。</p>
<p><code>SCP</code> 使用起来特别便利，因为他能工作在几乎所有的 <code>Unix-like</code> 的系统中，并且 <code>Windows</code> 下拥有许多客户端。但是仅仅复制文件并不是关键。<code>SCP</code> 真正的价值是对 <strong>计算机的身份进行验证</strong> 以及对 <strong>传输文件进行加密</strong>（也就是 S 代表的含义）。</p>
<p>使用前需要首先配置到远程主机的 <code>SSH</code> 连接权限。<code>SCP</code> 的验证提示和 SSH 看起很像，因为 <code>SCP</code> 跑在 <code>SSH</code> 的上层，仅仅把它作为文件数据的管道。事实上，<code>SSH</code> 负责处理所有安全相关的任务，<code>SCP</code> 只是将一些文件扔到 <code>SSH</code> 连接上。</p>
<p>维基百科上的条目讲述了 <code>SCP</code> 的历史，简而言之：在旧的 <code>BSD</code> 系统上曾经有一个叫 <code>RCP</code> 的工具，可以在电脑之间移动文件。在当时受信任的网络时代，每个人都是别人的朋友。后来人们意识到，也许并不是每个人在他们的网络上都是这么好的朋友。于是有人把 <code>RCP</code> 的实现复制到 <code>OpenSSH</code> 的前身上，然后简单地在 <code>SSH</code> 会话上运行它，以保护文件不被非好友发现。问题解决了！从此以后，它就留在了 <code>OpenSSH</code> 中。</p>
<h2 id="scp-工作原理" class="headerLink">
    <a href="#scp-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="header-mark"></a>SCP 工作原理</h2><p><code>SCP</code> 并不是一个标准协议，并没有一个 <code>RFC</code> 或者任何官方描述如何实现它。<code>OpenSSH</code> 实现是一个事实上的规范。此实现有两个部分：连接建立和之后的传输协议。</p>
<h3 id="建立连接" class="headerLink">
    <a href="#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5" class="header-mark"></a>建立连接</h3><p>实际上，这并不是真正的连接。因为它只是利用 <code>SSH</code> 执行命令后的 <code>STDIN/STDOUT</code> ，有点类似 <code>Unix</code> 管道。<code>OpenSSH</code> 中包含两个程序来完成:<code>sshd</code> 和 <code>scp</code>。<code>sshd</code> 是始终运行的服务器守护进程，接受新的 <code>SSH</code> 连接。<code>SCP</code> 是伪装成 <code>SSH</code> 的客户端程序，发送和接受文件。</p>
<p>当 <code>SCP</code> 运行时，他将开启一个新的 <code>SSH</code> 连接。在该连接上，它会在服务端执行另一个带有特殊标志的 <code>SCP</code> 程序。你可以认为是 <code>ssh exec scp [flags]</code>。主要的标志包含 <code>-t</code>（&ldquo;to&rdquo;）和 <code>-f</code>（&ldquo;from&rdquo;）用于代表接受和发送，而 <code>-d</code> 表示文件夹，<code>-r</code> 表示递归。</p>
<figure><a class="lightgallery" href="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png" title="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png" data-thumbnail="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png" data-sub-html="<h2>建立连接</h2>">
        <img
            
            loading="lazy"
            src="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png"
            srcset="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png, https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png 1.5x, https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png 2x"
            sizes="auto"
            alt="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-1.png">
    </a><figcaption class="image-caption">建立连接</figcaption>
    </figure>
<p>值得注意的是，<code>SCP</code> 协议是单向的，一端发送文件，另一端接收文件。在远程端 <code>SCP</code> 开始运行后，实际的 <code>SCP</code> 协议命令开始通过 <code>STDIN</code> 和 <code>STDOUT</code> 运行。</p>
<h3 id="传输协议" class="headerLink">
    <a href="#%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae" class="header-mark"></a>传输协议</h3><p>现在，安全的 I/O 通道建立起来，并且已经有效地切换到 <code>RCP</code> 协议上。该协议是 <strong>顺序</strong>（一次一个操作）和 <strong>同步</strong>（每个命令执行完后才执行下一个命令）执行的。</p>
<p>命令格式大致为（不带括号或空格）：<code>[command type][arguments]\n [optional data]</code></p>
<ul>
<li>
<p>[command type] 通常是一个 ASCII 字符：</p>
<ul>
<li>&lsquo;C&rsquo;- 写入文件</li>
<li>&lsquo;D&rsquo;- 输入目录</li>
<li>&lsquo;E&rsquo;- 退出最后一个目录</li>
<li>&lsquo;T&rsquo;- 设置下一个文件或目录的创建 / 更新时间戳</li>
</ul>
</li>
<li>
<p>[arguments] 是特定于命令的，如文件 / 目录名称、文件大小或时间戳。&ldquo;E&rdquo; 命令没有参数。</p>
</li>
<li>
<p>[optional data] 在上一个命令为 &ldquo;C&rdquo;（创建文件）时发送。数据的大小指定为 &ldquo;C&rdquo; 的参数。</p>
</li>
</ul>
<p>此外，还有控制字节，这些字节是在没有新行的情况下自己发送的：</p>
<ul>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;OK&rdquo;，确认完成最后一个命令（如编写本地文件）。接收方也会在启动时发送此消息，让发送方知道它已准备好接收命令。</p>
</li>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;警告&rdquo;，后面是要向用户显示的行（由新行终止）。</p>
</li>
<li>
<p>&lsquo;0x00&rsquo;-&ldquo;错误&rdquo; 后跟随可选消息（和警告相同），但连接随后终止。</p>
</li>
</ul>
<p>下面这个带有注释的图片实例，详细讲述了这个过程：</p>
<figure><a class="lightgallery" href="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png" title="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png" data-thumbnail="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png" data-sub-html="<h2>传输过程</h2>">
        <img
            
            loading="lazy"
            src="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png"
            srcset="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png, https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png 1.5x, https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png 2x"
            sizes="auto"
            alt="https://fastly.jsdelivr.net/gh/techkoala/techkoala.github.io@master/images/Software/SCP/scp-2.png">
    </a><figcaption class="image-caption">传输过程</figcaption>
    </figure>
<h2 id="使用-scp" class="headerLink">
    <a href="#%e4%bd%bf%e7%94%a8-scp" class="header-mark"></a>使用 SCP</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ scp 选项 参数
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中选项如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">-1：使用ssh协议版本1；
</span></span><span class="line"><span class="cl">-2：使用ssh协议版本2；
</span></span><span class="line"><span class="cl">-4：使用ipv4；
</span></span><span class="line"><span class="cl">-6：使用ipv6；
</span></span><span class="line"><span class="cl">-B：以批处理模式运行；
</span></span><span class="line"><span class="cl">-C：使用压缩；
</span></span><span class="line"><span class="cl">-F：指定ssh配置文件；
</span></span><span class="line"><span class="cl">-l：指定宽带限制；
</span></span><span class="line"><span class="cl">-o：指定使用的ssh选项；
</span></span><span class="line"><span class="cl">-P：指定远程主机的端口号；
</span></span><span class="line"><span class="cl">-p：保留文件的最后修改时间，最后访问时间和权限模式；
</span></span><span class="line"><span class="cl">-q：不显示复制进度；
</span></span><span class="line"><span class="cl">-r：以递归方式复制。
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数分别为：</p>
<ul>
<li>源文件：指定要复制的源文件。</li>
<li>目标文件：格式为 user@host：filename（文件名为目标文件的名称）。</li>
</ul>
<h2 id="scp-的问题" class="headerLink">
    <a href="#scp-%e7%9a%84%e9%97%ae%e9%a2%98" class="header-mark"></a>SCP 的问题</h2><p>看起来，<code>SCP</code> 听起来似乎没什么问题。它是一个简单易用的工具，然而存在一些现实问题。</p>
<h3 id="性能" class="headerLink">
    <a href="#%e6%80%a7%e8%83%bd" class="header-mark"></a>性能</h3><p>传输协议的顺序性：每个命令的强制确认都会增加大量开销。例如，如果沿途丢弃单个确认数据包，则整个连接将暂停，直到重新传输开始。最重要的是，发送所有数据而不压缩或询问接收方是否已经拥有该文件并不理想。</p>
<p>有经验的系统管理员可以告诉您，使用 <code>tar</code> 归档文件并发送比使用 <code>scp</code> 递归命令传输要快得多。事实上，这样的话你甚至无需使用 SCP：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell"><span class="line"><span class="cl"><span class="c1"># Copy a local folder with 10000 files</span>
</span></span><span class="line"><span class="cl">$ find /tmp/big_folder/-type f <span class="p">|</span> wc -l
</span></span><span class="line"><span class="cl"><span class="m">10000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Using scp</span>
</span></span><span class="line"><span class="cl">$ <span class="nb">time</span> scp -r -q /tmp/big_folder/server:/tmp/big_folder
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">________________________________________________________
</span></span><span class="line"><span class="cl">Executed in  882.99 millis	fish       	external
</span></span><span class="line"><span class="cl">   usr <span class="nb">time</span>  114.09 millis	0.00 micros  114.09 millis
</span></span><span class="line"><span class="cl">   sys <span class="nb">time</span>  278.46 millis  949.00 micros  277.51 millis
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Using tar over ssh</span>
</span></span><span class="line"><span class="cl">$ <span class="nb">time</span> sh -c <span class="s2">&#34;tar cf - /tmp/big_folder | ssh server &#39;tar xC /tmp/-f -&#39;&#34;</span>
</span></span><span class="line"><span class="cl">tar: Removing leading <span class="s1">&#39;/&#39;</span> from member names
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">________________________________________________________
</span></span><span class="line"><span class="cl">Executed in  215.68 millis	fish       	external
</span></span><span class="line"><span class="cl">   usr <span class="nb">time</span>   93.22 millis	0.00 micros   93.22 millis
</span></span><span class="line"><span class="cl">   sys <span class="nb">time</span>   66.51 millis  897.00 micros   65.62 millis
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种比较糟糕的情况下，<code>tar&amp;ssh</code> 的 215.68ms 对比 <code>SCP</code> 的 882.99ms，足足有四倍的速度提升。</p>
<h3 id="安全" class="headerLink">
    <a href="#%e5%ae%89%e5%85%a8" class="header-mark"></a>安全</h3><p>我们已经知道，<code>SCP</code> 靠 <code>SSH</code> 负担安全工作，因此它完全安全&hellip; 吗？</p>
<p><code>OpenSSH</code> 的发行说明提到：</p>
<blockquote>
<p>scp 协议已经过时、不灵活且不容易修复。我们建议使用更现代的协议，如 sftp 和 rsync 来传输文件。</p>
</blockquote>
<p>如果远程端的 <code>shell</code> 打印出任何非交互式会话，则本地 <code>SCP</code> 进程将愉快地将该输出解释为 <code>SCP</code> 命令。好的话，这仅仅是打破 <code>SCP</code> 协议中模糊的错误。但在最坏的情况下，远程 <code>shell</code> 启动脚本是恶意的，并向你发送恶意文件，而不是所需的文件。</p>
<p>此外，早在 2018 年，Harry Sintonen 就发现了流行的 <code>SCP</code> 实现（包括 <code>OpenSSH</code>）中的一堆漏洞。包括从修改目录的权限到覆盖任意文件（由于 <code>～/.ssh/authorized_keys</code> 或 <code>～/.bashrc</code>）、有效地执行代码，以及注入终端转义序列来隐藏任何追踪。这些漏洞对于任何构建网络 <code>CLI</code> 应用程序的人来说都是一个很好的教训。</p>
<h2 id="scp-的替代方案" class="headerLink">
    <a href="#scp-%e7%9a%84%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88" class="header-mark"></a>SCP 的替代方案</h2><p><code>SFTP</code> 被广泛认为是 <code>SCP</code> 的继承者。为了传输层安全性，它仍然在 <code>SSH</code> 上运行，并且不需要单独设置访问。它可以为您提供一个自定义交互式提示来探索远程文件系统，或者您可以使用预先编写的一系列命令编写脚本。
缺点是，您需要学习 <code>SFTP</code> 提示命令，协议本身尚未完全标准化（有很多 <code>RFC</code> 草稿，但作者最终放弃了）。</p>
<p><code>Rsync</code> 是另一个很好的选择。使用与 <code>SCP</code> 命令完全相同 - 它也利用 <code>SSH</code>。<code>Rsync</code> 着重优化性能 - 它执行大量的复杂本地计算从而通过网络发送尽可能少的数据。从技术上讲，它致力于数据同步而不是纯传输文件 - 如果远程和本地内容相似，则只会发送增量。</p>
<p>同样，它也有其自身的缺点：发送方使用大量的 CPU 资源来计算要发送什么，并且接收方使用大量磁盘 IO 将数据按正确的顺序放在一起。与 <code>OpenSSH</code> 不同，<code>Rsync</code> 在大多数系统上并不预安装。</p>
<h2 id="结论" class="headerLink">
    <a href="#%e7%bb%93%e8%ae%ba" class="header-mark"></a>结论</h2><p><code>SCP</code> 是一个简单的工具，它在复制文件方面做得很好，但较新的软件在很多方面都优于它。对于您信任的计算机之间的个人简单使用，<code>SCP</code> 仍然适合。</p>
<p>但是，如果您遇到性能问题或需要满足更高的安全标准，则上面列出的任何备选方案都比 <code>SCP</code> 更可取。选择最适合您需求的，然后试着开始使用。</p>
<h2 id="另见" class="headerLink">
    <a href="#%e5%8f%a6%e8%a7%81" class="header-mark"></a>另见</h2><ul>
<li><a href="/rsync/" rel="">rsync</a></li>
<li><a href="/sftp/" rel="">SFTP</a></li>
</ul>
<h2 id="参考" class="headerLink">
    <a href="#%e5%8f%82%e8%80%83" class="header-mark"></a>参考</h2><ul>
<li>
<p>[1] <a href="https://gravitational.com/blog/scp-familiar-simple-insecure-slow/" target="_blank" rel="noopener noreferrer">SCP - Familiar, Simple, Insecure, and Slow</a></p>
</li>
<li>
<p>[2] <a href="https://en.wikipedia.org/wiki/Secure_copy" target="_blank" rel="noopener noreferrer">Wikipedia Secure copy</a></p>
</li>
<li>
<p>[3] <a href="https://lists.mindrot.org/pipermail/openssh-unix-dev/2019-March/037672.html" target="_blank" rel="noopener noreferrer">Call for testing: OpenSSH 8.0</a></p>
</li>
<li>
<p>[4] <a href="https://ningyu1.github.io/linux-command/c/scp.html" target="_blank" rel="noopener noreferrer">Scp</a></p>
</li>
</ul>]]></description>
</item><item>
    <title>Virtualbox 共享文件夹权限问题</title>
    <link>https://www.techkoala.net/virtualbox_file_share_issue/</link>
    <pubDate>Wed, 10 Oct 2018 13:26:54 &#43;0800</pubDate><author>
        <name>TechKoala</name>
    </author><guid>https://www.techkoala.net/virtualbox_file_share_issue/</guid>
    <description><![CDATA[<blockquote>
<p>一行命令解决 Virtualbox 共享文件夹权限问题</p>
</blockquote>
<h2 id="功能" class="headerLink">
    <a href="#%e5%8a%9f%e8%83%bd" class="header-mark"></a>功能</h2><p>使用 virtualbox 最方便的 <code>host-guest</code> 交换文件方案莫过于共享文件夹功能了。</p>
<p>比如 <code>host</code> 有个叫 <code>git</code> 的文件夹，可以直接将此文件夹设置为共享文件夹并自动 <code>mount</code>，这样，每次在虚拟机一开机就看到这个文件夹被挂载为<code>/media/sf_git</code>。</p>
<h2 id="问题" class="headerLink">
    <a href="#%e9%97%ae%e9%a2%98" class="header-mark"></a>问题</h2><p>但是，在用非 <code>root</code> 用户方法这个文件夹时却会遇到权限不足问题。</p>
<p>原因在于自动 <code>mount</code> 的文件夹的所有者为 <code>root</code>，所属的组是 <code>vboxsf</code>，因此只有这两个用户有访问权限。</p>
<h2 id="解决" class="headerLink">
    <a href="#%e8%a7%a3%e5%86%b3" class="header-mark"></a>解决</h2><p>解决办法很简单，只需要将当前登录用户加入到 <code>vboxsf</code> 组就行了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sudo usermod -aG vboxsf <span class="k">$(</span>whoami<span class="k">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>重启一次系统组设置即生效。</p>]]></description>
</item></channel>
</rss>
